{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACjB0C;AACG;AACO;AACO;AACI;AACE;AACvB;AACI;AACE;AACZ;AACpC;AACA;AACA;AACO,6BAA6B,6CAAO;AAC3C;AACA;AACA,gBAAgB,cAAc;AAC9B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kEAAkB;AACxD;AACA;AACA,0CAA0C,kDAAK,KAAK,kDAAM;AAC1D,0CAA0C,qDAAO;AACjD;AACA;AACA;AACA,qCAAqC,qEAAqB;AAC1D,6CAA6C,wDAAQ;AACrD,uCAAuC,kDAAM;AAC7C,yBAAyB;AACzB,0CAA0C,qDAAO;AACjD;AACA;AACA;AACA,qCAAqC,oEAAoB;AACzD,4CAA4C,sDAAO;AACnD;AACA,2CAA2C,kDAAM;AACjD,6BAA6B;AAC7B,yBAAyB;AACzB,0CAA0C,qDAAO;AACjD;AACA;AACA;AACA,sCAAsC,kEAAkB;AACxD,+CAA+C,mEAAa;AAC5D,uCAAuC,kDAAM;AAC7C,yBAAyB;AACzB,0CAA0C,qDAAO;AACjD;AACA;AACA;AACA,qCAAqC,qEAAqB;AAC1D,kDAAkD,yEAAgB;AAClE;AACA,2CAA2C,kDAAM;AACjD,6BAA6B;AAC7B,yBAAyB;AACzB,0CAA0C,qDAAO;AACjD;AACA;AACA;AACA,qCAAqC,oEAAoB;AACzD,iDAAiD,uEAAe;AAChE;AACA;AACA,+CAA+C,kDAAM;AACrD,iCAAiC;AACjC,6BAA6B;AAC7B,yBAAyB;AACzB,0CAA0C,qDAAO;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AC7FuD;AACV;AAC7C;AACA;AACA;AACA;AACO,mBAAmB,kDAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC,cAAc,0BAA0B;AACxC,cAAc,4BAA4B;AAC1C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA,iCAAiC,kEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B,oBAAoB;AAChD,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,wDAAwD;AACxD,4DAA4D;AAC5D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnNuD;AACV;AAC7C;AACA;AACA;AACO,kBAAkB,kDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA,iCAAiC,kEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,4BAA4B,wBAAwB;AACpD;AACA,kEAAkE,uBAAuB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oDAAoD;AACpD,4DAA4D;AAC5D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzQ0D;AACH;AACV;AAC7C;AACA;AACA;AACA;AACA;AACO,sBAAsB,kDAAM;AACnC;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,4BAA4B,OAAO;AACnC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,4BAA4B,OAAO;AACnC;AACA,oBAAoB,OAAO;AAC3B;AACA,4BAA4B,OAAO;AACnC;AACA,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,OAAO;AAC/B;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,wBAAwB,OAAO;AAC/B;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,wBAAwB,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAY;AAC5C;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA,iCAAiC,kEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,8BAA8B;AAC9B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;;;;;;;;;;;;;;;;AChHwC;AACxC;AACA;AACA;AACA;AACA;AACO,6BAA6B,iDAAS;AAC7C;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,wBAAwB,eAAe;AACvC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;ACJ2C;AACG;AACF;AACP;AACY;AACF;AACE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,0DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAY;AACpB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,8DAA0B;AAC1F,+BAA+B,uDAAQ;AACvC;AACA,4BAA4B,oDAAgB;AAC5C,QAAQ,+CAAW;AACnB,QAAQ,+CAAW;AACnB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,uDAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAmB;AAChD,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA,QAAQ,uDAAoB;AAC5B;AACA,4BAA4B,wDAAqB;AACjD;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,QAAQ,uDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAmB;AAC3B;AACA,YAAY,uDAAmB;AAC/B;AACA;AACA;AACA,YAAY,gDAAY;AACxB,YAAY,gDAAY;AACxB;AACA;AACA;AACA,YAAY,uDAAoB;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChNqC;AACE;AACvC;AACA;AACA;AACO,4BAA4B,gDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uCAAuC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAe;AACnC,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAe;AACnC,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD,kCAAkC,+CAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxPuC;AACvC;AACA;AACA;AACO,4BAA4B,gDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpD2C;AAC3C;AACA;AACA;AACO,uBAAuB,oDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpC2C;AAC3C;AACA;AACA;AACO,4BAA4B,oDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvB0B;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,IAAI;AACnB;AACA;AACA;AACA,yBAAyB,mCAAE,iBAAiB,mCAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrJkC;AAClC;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB;AACA;AACA;AACA,yBAAyB,2CAAM,iBAAiB,2CAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,2BAA2B,2CAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2CAAM;AACxC,kCAAkC,2CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,cAAc;AAC5B;AACA;AACA;AACA,oCAAoC,2CAAM,mDAAmD,2CAAM;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpPqC;AACI;AACM;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,YAAY,iDAAc;AAC1B,YAAY,iDAAc;AAC1B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,gBAAgB,iDAAc,uBAAuB,iDAAc;AACnE;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA,mBAAmB,wDAAY;AAC/B;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChGoC;AACC;AACrC;AACA;AACA;AACA;AACO,0BAA0B,6CAAQ;AACzC;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,mBAAmB,8CAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,mBAAmB,8CAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,mBAAmB,8CAAO;AAC1B;AACA;;;;;;;;;;;;;;;;;AC7CyC;AACf;AAC1B;AACA;AACA;AACO,sBAAsB,mCAAE;AAC/B;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA,YAAY,qDAAS;AACrB,YAAY,qDAAS;AACrB;AACA;;;;;;;;;;;;;;;;;AClEoC;AACG;AACvC;AACA;AACA;AACA;AACO,2BAA2B,6CAAQ;AAC1C;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,mBAAmB,gDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA,mBAAmB,gDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA,mBAAmB,gDAAQ;AAC3B;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvDyC;AACf;AAC1B;AACA;AACA;AACO,uBAAuB,mCAAE;AAChC;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA,YAAY,qDAAS;AACrB,YAAY,qDAAS;AACrB;AACA;;;;;;;;;;;;;;;;AClEyC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA,YAAY,qDAAS;AACrB,YAAY,qDAAS;AACrB;AACA;;;;;;;;;;;;;;;;;;ACpPoC;AAC2C;AACd;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,6CAAK;AACnC;AACA;AACA;AACA,8BAA8B,wFAAiB;AAC/C,kCAAkC,0EAAc,mBAAmB,0FAAmB,4BAA4B,0FAAmB;AACrI;AACA;;;;;;;;;;;;;;;;;;AClBoC;AACoB;AACS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,6CAAK;AACnC;AACA;AACA;AACA,8BAA8B,iEAAM;AACpC,kCAAkC,0EAAc;AAChD;AACA;;;;;;;;;;;;;;;;ACtB4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,qCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxB0C;AACa;AAClB;AACkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,mBAAmB,+DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAY,oEAAoE,+CAAY;AAC7H,mBAAmB,kDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,kDAAM,oDAAoD,kDAAM;AAChJ,mBAAmB,+DAAY;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrG0C;AACc;AACR;AACH;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,mDAAU;AACtC;AACA;AACA,0BAA0B,6DAAW,KAAK,qDAAO,iBAAiB,qDAAO;AACzE;AACA;AACA,mBAAmB,qDAAO;AAC1B;AACA;AACA,mBAAmB,kDAAM;AACzB;AACA;;;;;;;;;;;;;;;;;;;AC3B6C;AACW;AACR;AACN;AAC1C;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,mDAAU;AACxC;AACA;AACA,0BAA0B,6DAAW,KAAK,qDAAO,wCAAwC,qDAAO;AAChG;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAO;AAC1B;AACA;AACA;AACA,yCAAyC,iCAAiC;AAC1E;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAM;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClCwD;AACR;AACH;AACH;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,mDAAU;AACjD;AACA;AACA,0BAA0B,6DAAW,KAAK,qDAAO,sEAAsE,qDAAO;AAC9H;AACA;AACA;AACA,mBAAmB,qDAAO;AAC1B;AACA;AACA;AACA,mBAAmB,kDAAM;AACzB;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BO;AACP;;;;;;;;;;;;;;;;;ACDgD;AACE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAO;AAC1B;AACA;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;;AC9IuD;AACnB;AAC7B,sBAAsB,+DAAa;AAC1C;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB;AACA,iCAAiC,4CAAI;AACrC;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7BoC;AACpC;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,gBAAgB;AAC/B,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,0BAA0B;AAC3C,iBAAiB,YAAY;AAC7B,iBAAiB,kBAAkB;AACnC;AACA,mCAAmC,4CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzKoE;AACf;AACE;AACA;AACF;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA,qBAAqB,yDAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAW;AAC3C;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,+DAAY;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,4DAAqB;AAC1C,qBAAqB,2DAAoB;AACzC;AACA;AACA,0BAA0B,4DAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAiB;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;ACzHuD;AACF;AACE;AACH;AACA;AACpD;AACA;AACA;AACA;AACA;AACO,8BAA8B,+CAAQ;AAC7C;AACA;AACA,qBAAqB,2DAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,gCAAgC,6DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,iCAAiC,+DAAY;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,+BAA+B,4DAAgB;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;AC5IuD;AACF;AACD;AACA;AACN;AACS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,+CAAQ;AAC9C;AACA;AACA,qBAAqB,4DAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,iCAAiC,+DAAY;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,+BAA+B,4DAAgB;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D,oBAAoB,mEAA+B;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AC9JoE;AACf;AACE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,+CAAQ;AACnC;AACA;AACA;AACA,qBAAqB,yDAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAiB;AAChD;AACA;AACA,qBAAqB,4DAAqB;AAC1C,qBAAqB,2DAAoB;AACzC;AACA;AACA,0BAA0B,4DAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxFuD;AACF;AACD;AACA;AACpD;AACA;AACA;AACA;AACA;AACO,sBAAsB,+CAAQ;AACrC;AACA;AACA,qBAAqB,2DAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,gCAAgC,6DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,+BAA+B,4DAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtHuD;AACF;AACD;AACA;AACN;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,+CAAQ;AACtC;AACA;AACA,qBAAqB,4DAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY;AAC7C;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAW;AAC3C;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B,4DAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,+BAA+B,4DAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D,gBAAgB,mEAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzIuD;AAChD,sBAAsB,+DAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C,iBAAiB,YAAY;AAC7B,iBAAiB,OAAO;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC5B2C;AACN;AACO;AACW;AACR;AACQ;AACA;AACA;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,0BAA0B,+DAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,+DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAa;AACzB;AACA;AACA,QAAQ,sDAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAoB;AAChC,8BAA8B,wDAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C,gCAAgC,eAAe;AAC/C,kDAAkD,sBAAsB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAa;AACzB,YAAY,wDAAoB;AAChC;AACA;AACA,YAAY,uDAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,sNAAsN,+DAAY,wCAAwC,uDAAQ,oDAAoD,uDAAQ;AAC9U;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uDAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D,0CAA0C,sBAAsB;AAChE,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uDAAQ;AACpF;AACA;AACA;AACA;AACA,8DAA8D,+DAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,oDAAgB;AACxB;AACA;AACA;AACA,6BAA6B,+CAAY;AACzC,2BAA2B,+CAAY;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,YAAY,wDAAqB;AACjC;AACA,aAAa;AACb;AACA,QAAQ,uDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAkB;AAC9B,YAAY,uDAAoB;AAChC,8BAA8B,wDAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAa;AAC7B,gBAAgB,wDAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA,mBAAmB,+DAAY,4FAA4F,uDAAQ;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7rB2C;AACN;AACS;AACF;AACD;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,EAAE,yBAAyB,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,IAAI,IAAI,iCAAiC,kFAAkF;AAC/L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE,wBAAwB,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE;AACnD;AACA;AACA,KAAK,EAAE,yHAAyH,2CAA2C,+CAA+C,EAAE,kBAAkB,EAAE,QAAQ,EAAE,wBAAwB,EAAE,8BAA8B;AAClT;AACA;AACA;AACA;AACA,wBAAwB,EAAE,iBAAiB,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,QAAQ,WAAW;AAC9E;AACA;AACO,0BAA0B,8CAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,uCAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAW;AACnB;AACA,SAAS;AACT,QAAQ,+CAAW;AACnB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAa;AAC5B;AACA;AACA;AACA,YAAY,gDAAa;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAY;AAC1C,+BAA+B,+CAAY;AAC3C;AACA,+BAA+B,qDAAkB;AACjD,oBAAoB,kDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAoB;AACjC,wCAAwC,qDAAkB;AAC1D;AACA;AACA;AACA;AACA,gEAAgE,qDAAkB;AAClF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzM4B;AACG;AACC;AACC;AACE;AACF;AACK;AACA;AACA;AACE;AACR;AACO;AACP;AACJ;AACM;AACC;AACG;AACC;AACb;AACM;AACD;AACA;AACa;AACO;AACE;AACU;AACX;AAChB;AACH;AACG;AACD;AACO;AACG;AACD;AACV;AACJ;AACQ;AACA;AACD;AACL;AACQ;AACD;AACD;AACS;AACT;AACE;AACK;AACb;AACE;AACM;AACN;AACQ;AACN;AACO;AACH;AACK;AACH;AACE;AAChB;AACM;AACJ;AACF;AACA;AACI;AACiB;AACJ;AACR;AACC;AACM;AACD;AACP;AACA;AACE;AACZ;AACe;AACF;AACW;AACA;;;;;;;;;;;;;;;;;;AC7EI;AACtD;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,sEAAsE,qEAAqB;AAC3F;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B,kBAAkB,OAAO;AACzB,kBAAkB,kBAAkB;AACpC,kBAAkB,0BAA0B;AAC5C,kBAAkB,YAAY;AAC9B,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;;;;;;;;;;;;;;;AC/IoC;AACU;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAI;AAC5B;AACA;AACA;AACA,6BAA6B,uDAAe;AAC5C;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;AChC6D;AAC7B;AACzB,2BAA2B,yCAAK;AACvC;AACA;AACA;AACA;AACA;AACA,6BAA6B,qEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5HgC;AACzB,2BAA2B,yCAAK;AACvC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpGuD;AACvD;AACA;AACA;AACO,oBAAoB,+DAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnFgC;AAChC;AACA;AACA;AACO,0BAA0B,yCAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7CiD;AAC1C,8BAA8B,kDAAa;AAClD;AACA;AACA;AACA;AACA;AACO,uBAAuB,2CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5E+C;AACE;AACH;AACN;AACkB;AACA;AACA;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C,yCAAyC,uBAAuB;AAChE,oCAAoC,uBAAuB;AAC3D;AACA;AACO,4BAA4B,+DAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,+DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAoB;AAChC;AACA;AACA;AACA;AACA,YAAY,kDAAc;AAC1B,YAAY,gDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,uDAAmB;AAC5F,YAAY,gDAAa;AACzB,YAAY,wDAAoB;AAChC;AACA;AACA,YAAY,uDAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA;AACA,sFAAsF,iDAAc;AACpG;AACA,YAAY,uDAAmB;AAC/B,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wDAAqB;AAC1E;AACA;AACA;AACA;AACA,2DAA2D,+DAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtN+C;AACE;AACQ;AACR;AAC1C,4BAA4B,kDAAa;AAChD;AACA;AACA;AACA;AACA;AACO,qBAAqB,2CAAM;AAClC;AACA;AACA;AACA,iCAAiC,8DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAW;AACvB,YAAY,+CAAW;AACvB,YAAY,+CAAW;AACvB;AACA;AACA;AACA;AACA,YAAY,gDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,YAAY,qDAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,oDAAgB,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxN0D;AAC1D;AACA;AACA;AACO,qCAAqC,+DAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpBwC;AACO;AACW;AACI;AACZ;AACQ;AACb;AACtC,0BAA0B,+DAAa;AAC9C;AACA;AACA;AACA,kCAAkC,mEAAe;AACjD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAgB;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAmB;AAC3B,QAAQ,uDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,kDAAM;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mPAAmP,uDAAQ;AAC3P;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAqB;AACrC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5IiD;AACS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACG,qCAAqC,+DAAa;AACzD;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAW;AACnB;AACA;AACA;AACA,QAAQ,gDAAY;AACpB;AACA;AACA,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,iDAAa;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvEqC;AACM;AACC;AACE;AACS;AACb;AACa;AACA;AACR;AACJ;AACS;AACH;AACsB;AACA;AAChB;AACd;AACI;AAC7C,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO,yBAAyB,gEAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAiB;AACzC;AACA;AACA,yCAAyC;AACzC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,+DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAQ;AAChC;AACA;AACA,6BAA6B,uDAAQ;AACrC;AACA,2BAA2B,mDAAM;AACjC;AACA;AACA,mEAAmE,aAAa;AAChF;AACA;AACA,6BAA6B,sDAAkB,IAAI,gDAAa,KAAK,sDAAmB;AACxF;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAW,cAAc,0DAAsB;AAC3D;AACA;AACA,4CAA4C,2DAAW;AACvD;AACA,mDAAmD,iFAAsB;AACzE;AACA,mDAAmD,iFAAsB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE,8CAA8C,sDAAsD;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,eAAe;AACrE;AACA;AACA;AACA;AACA,0BAA0B,gDAAa;AACvC;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,uDAAQ;AAClI,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAQ,8DAA8D,uDAAQ;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAY,KAAK,kDAAM,iBAAiB,kDAAM;AAChF;AACA;AACA;AACA;AACA,kDAAkD,cAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAY;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uBAAuB,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAc;AACtB;AACA,YAAY,uDAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,kDAAc;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,uDAAQ;AACtE,4MAA4M,+DAAY,yFAAyF,gDAAa;AAC9T;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAW;AACnB,4BAA4B,6CAAU;AACtC;AACA;AACA;AACA,2DAA2D,gDAAa;AACxE,QAAQ,oDAAgB;AACxB,aAAa,gDAAa;AAC1B,aAAa,iDAAc;AAC3B,aAAa,gDAAa;AAC1B,aAAa,iDAAc;AAC3B;AACA,yBAAyB,oDAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAmB,oBAAoB,uDAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAmB,oBAAoB,uDAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAY,GAAG,+CAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAa;AACzB;AACA;AACA;AACA;AACA,QAAQ,uDAAoB;AAC5B,8BAA8B,wDAAqB;AACnD,kCAAkC,uBAAuB;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6CAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6DAAyB;AACjF;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAmB,uBAAuB,uDAAQ;AACjE;AACA;AACA;AACA,sCAAsC,uDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H,+DAAY;AACvI;AACA;AACA;AACA,sCAAsC,uDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,+DAAY;AAC9E;AACA;AACA;AACA;AACA,uCAAuC,+DAAY;AACnD,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gDAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAc;AAClD;AACA;AACA,iBAAiB,qDAAiB;AAClC;AACA,yBAAyB,qDAAiB;AAC1C,YAAY,wDAAoB;AAChC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,kDAAc;AACtB;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAqB;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAmB;AAC/B;AACA;AACA;AACA;AACA,QAAQ,wDAAqB;AAC7B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjrCqC;AACO;AACW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,+DAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxF0C;AACa;AACvD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAY,KAAK,kDAAM,kBAAkB,kDAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5DyF;AACrC;AACd;AACA;AACtC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,+CAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAkB;AAC3C;AACA,4CAA4C,6DAAiB;AAC7D,4CAA4C,qDAAY;AACxD,8CAA8C,qDAAY;AAC1D;AACA;AACA;AACA;AACA,yBAAyB,qEAAqB;AAC9C;AACA,4CAA4C,4DAAgB;AAC5D,8CAA8C,qDAAY;AAC1D;AACA;AACA;AACA;AACA,yBAAyB,oEAAoB;AAC7C;AACA,4CAA4C,4DAAgB;AAC5D,4CAA4C,qDAAY;AACxD,8CAA8C,qDAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrGyF;AACrC;AACd;AACA;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,8CAA8C;AAC3D,wBAAwB,YAAY;AACpC;AACA;AACA,qBAAqB,kEAAkB;AACvC;AACA,wCAAwC,6DAAiB;AACzD,wCAAwC,qDAAY;AACpD,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAqB;AAC1C;AACA,wCAAwC,4DAAgB;AACxD,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAoB;AACzC;AACA,wCAAwC,4DAAgB;AACxD,wCAAwC,qDAAY;AACpD,0CAA0C,qDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzGqD;AACf;AACc;AACK;AACzD;AACA;AACA;AACO,8BAA8B,+CAAQ;AAC7C;AACA;AACA,kCAAkC,6DAAiB;AACnD,8BAA8B;AAC9B,6BAA6B;AAC7B;AACA;AACA,0BAA0B,kEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAa;AACpC;AACA;AACA;;;;;;;;;;;;;;;;;AClEqD;AACf;AACtC;AACA;AACA;AACA;AACA;AACO,0BAA0B,+CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAAiB;AAC1D;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRsC;AACtC;AACA;AACA;AACO,6BAA6B,+CAAQ;AAC5C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACRuD;AACjB;AACtC;AACA;AACA;AACA;AACA;AACO,kCAAkC,+CAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1DuD;AACR;AACR;AAChC,iCAAiC,gDAAW;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,uDAAQ;AAC9F,mBAAmB,+DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,wBAAwB,eAAe;AACvC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9EuD;AACjB;AACtC;AACA;AACA;AACO,0BAA0B,+CAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjGuD;AACR;AACT;AACC;AACvC;AACA;AACA;AACA;AACA;AACO,4BAA4B,gDAAW;AAC9C;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAU,CAAC,sDAAa,mBAAmB,sDAAa;AAC/E;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uDAAQ;AACpF,mBAAmB,+DAAY;AAC/B;AACA;;;;;;;;;;;;;;;;;;AC1IuD;AACR;AACR;AACvC;AACA;AACA;AACA;AACA;AACO,2BAA2B,gDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uDAAQ;AACpF,mBAAmB,+DAAY;AAC/B;AACA;;;;;;;;;;;;;;;;;;AClEuD;AACjB;AACtC;AACA;AACA;AACA;AACA;AACO,gCAAgC,+CAAU;AACjD;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvIuD;AACR;AACR;AAChC,0BAA0B,gDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uDAAQ;AACpF,mBAAmB,+DAAY;AAC/B;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjDuD;AACR;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uDAAQ;AACpF,mBAAmB,+DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAQ;AAC7B,qBAAqB,uDAAQ;AAC7B,mBAAmB,+DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrRA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtF+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AACnB;AACP,6BAA6B;AACtB;AACP,4BAA4B;AACrB;AACP;AACA;AACO;AACP;AACA;AACO;AACP,iCAAiC;AAC1B;AACP;AACA,oCAAoC;AAC7B;AACP,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6BAA6B;AACtB;AACP,8BAA8B;AACvB;AACP,6BAA6B;AACtB;AACP,8BAA8B;AACvB;AACA;AACP;AACA;AACO;AACP,2BAA2B;AACpB;AACP,4BAA4B;AACrB;AACP,gCAAgC;AACzB;AACP,+BAA+B;AACxB;AACP;AACA;AACO;AACP,8BAA8B;AACvB;AACP,oCAAoC;AAC7B;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mCAAmC;AAC5B;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,SAAS;AACT,2DAA2D,0CAAY;AACvE,8DAA8D,0CAAY;AAC1E;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACO;AACP;AACA,CAAC;AACD;AACA;AACA;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,kCAAkC,EAAE,aAAa,EAAE,aAAa,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClF+B;AACM;AACrC,YAAY,4CAA4C;AACxD,YAAY,gDAAgD;AACtB;AACS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uCAAuC;AAC7E;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAe;AAC/B,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uCAAuC;AAChF;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAe;AAC/B,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6CAAe;AACvB,iBAAiB,0CAAY,IAAI,4CAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAU,wBAAwB,wCAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6CAAe;AACvB;AACA;AACA;AACA,aAAa,2CAAa;AAC1B;AACA;AACA;AACA;AACA,oEAAoE,mDAAqB,KAAK,iBAAiB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAU,wBAAwB,wCAAU;AAChE;AACA;AACA;AACA,QAAQ,6CAAe;AACvB;AACA;AACA,aAAa,2CAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACO;AACP;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,uDAAQ;AAC3B;AACA,kBAAkB,mDAAQ,gDAAgD;AAC1E,eAAe,uDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAW,IAAI,4CAAc;AACpD,IAAI,2CAAa;AACjB;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,0CAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;AAC7B;AACA;AACiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1PF;AACM;AACU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,6CAAe;AACvC,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qBAAqB,uCAAS;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B,uDAAQ;AACtC;AACA;AACA,aAAa,0CAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,2CAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,uDAAQ;AAC1C;AACA;AACA;AACO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnN+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB;AACpB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uBAAuB,uDAAQ,qCAAqC,uDAAQ;AAC5E;AACO;AACP;AACA,8BAA8B;AAC9B;AACA;AACA,mCAAmC;AACnC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uDAAQ;AACpD;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1KA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO,qBAAqB;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA;AACA;AACO;AACA;AACP,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8EAA8E,EAAE,GAAG,EAAE;AACrF,4BAA4B,mBAAmB;AAC/C;AACA;AACO;AACP,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;UC5FA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;AAIiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB,sCAAG;AACrB;AACA,mBAAmB,uCAAI,UAAU,EAAE,eAAe,EAAE,EAAE,EAAE,EAAE,EAAE;AAC5D;AACA;AACA,kBAAkB,yCAAM;AACxB;AACA,6BAA6B,iDAAc,CAAC,wDAAqB;AACjE;AACA;AACA,2BAA2B,+CAAY,CAAC,wDAAqB;AAC7D;AACA,oBAAoB,wCAAK,SAAS,mDAAgB;AAClD;AACA;AACA;AACA,2BAA2B,+CAAY;AACvC;AACA;AACA,uBAAuB,iDAAc;AACrC,wBAAwB,mDAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","sources":["webpack:///../dist/adapter/adapter.js","webpack:///../dist/adapter/geojson-adapter.js","webpack:///../dist/analysis/heat/heat.js","webpack:///../dist/analysis/interpolation/idw.js","webpack:///../dist/analysis/interpolation/kriging.js","webpack:///../dist/animation/animation.js","webpack:///../dist/animation/line-animation.js","webpack:///../dist/animation/point-animation.js","webpack:///../dist/base/base-object.js","webpack:///../dist/base/draggable-object.js","webpack:///../dist/base/evented-object.js","webpack:///../dist/base/handler-object.js","webpack:///../dist/base/id-object.js","webpack:///../dist/base/options-object.js","webpack:///../dist/common/bounds.js","webpack:///../dist/common/latlng-bounds.js","webpack:///../dist/common/latlng.js","webpack:///../dist/common/plane-bounds.js","webpack:///../dist/common/plane-xy.js","webpack:///../dist/common/screen-bounds.js","webpack:///../dist/common/screen-xy.js","webpack:///../dist/common/xy.js","webpack:///../dist/crs/crs-3857.js","webpack:///../dist/crs/crs-4326.js","webpack:///../dist/crs/crs-earth.js","webpack:///../dist/crs/crs.js","webpack:///../dist/crs/projection/projection-lonlat.js","webpack:///../dist/crs/projection/projection-mercator.js","webpack:///../dist/crs/projection/projection-spherical-mercator.js","webpack:///../dist/crs/projection/projection.js","webpack:///../dist/crs/transformation/transformation.js","webpack:///../dist/feature/feature-class.js","webpack:///../dist/feature/feature.js","webpack:///../dist/feature/field.js","webpack:///../dist/geometry/geometry.js","webpack:///../dist/geometry/multiple-point.js","webpack:///../dist/geometry/multiple-polygon.js","webpack:///../dist/geometry/multiple-polyline.js","webpack:///../dist/geometry/point.js","webpack:///../dist/geometry/polygon.js","webpack:///../dist/geometry/polyline.js","webpack:///../dist/graphic/graphic.js","webpack:///../dist/grid/grid.js","webpack:///../dist/grid/tile.js","webpack:///../dist/index.js","webpack:///../dist/label/collision.js","webpack:///../dist/label/label.js","webpack:///../dist/layer/feature-layer.js","webpack:///../dist/layer/graphic-layer.js","webpack:///../dist/layer/layer.js","webpack:///../dist/layer/raster-layer.js","webpack:///../dist/map/canvas/animater.js","webpack:///../dist/map/canvas/canvas.js","webpack:///../dist/map/canvas/viewer.js","webpack:///../dist/map/handler/map-doubleclickzoom.js","webpack:///../dist/map/handler/map-drag.js","webpack:///../dist/map/handler/map-scrollwheelzoom.js","webpack:///../dist/map/map.js","webpack:///../dist/map/position-animation.js","webpack:///../dist/raster/raster.js","webpack:///../dist/renderer/category-renderer.js","webpack:///../dist/renderer/class-renderer.js","webpack:///../dist/renderer/cluster-renderer.js","webpack:///../dist/renderer/dot-renderer.js","webpack:///../dist/renderer/renderer.js","webpack:///../dist/renderer/simple-renderer.js","webpack:///../dist/symbol/alternate-line-symbol.js","webpack:///../dist/symbol/animate-symbol.js","webpack:///../dist/symbol/arrow-symbol.js","webpack:///../dist/symbol/cluster-symbol.js","webpack:///../dist/symbol/letter-symbol.js","webpack:///../dist/symbol/pattern-fill-symbol.js","webpack:///../dist/symbol/shape-symbol.js","webpack:///../dist/symbol/symbol.js","webpack:///../dist/text/text.js","webpack:///../dist/util/browser.js","webpack:///../dist/util/color.js","webpack:///../dist/util/dom-event.js","webpack:///../dist/util/dom-util.js","webpack:///../dist/util/line-util.js","webpack:///../dist/util/util.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./subway.js"],"sourcesContent":["/**\r\n * 数据适配基类\r\n */\r\nexport class Adapter {\r\n    /**\r\n      * 构造函数\r\n      * @param {GeometryType} type - 矢量数据类型\r\n      */\r\n    constructor(type) {\r\n        this._type = type;\r\n    }\r\n    /**\r\n     * 获取矢量数据类型\r\n     */\r\n    get type() {\r\n        return this._type;\r\n    }\r\n}\r\n","import { LatLng } from \"../common/latlng\";\r\nimport { Feature } from \"../feature/feature\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { MultiplePoint } from \"../geometry/multiple-point\";\r\nimport { MultiplePolygon } from \"../geometry/multiple-polygon\";\r\nimport { MultiplePolyline } from \"../geometry/multiple-polyline\";\r\nimport { Point } from \"../geometry/point\";\r\nimport { Polygon } from \"../geometry/polygon\";\r\nimport { Polyline } from \"../geometry/polyline\";\r\nimport { Adapter } from \"./adapter\";\r\n/**\r\n * GeoJSON数据适配基类\r\n */\r\nexport class GeoJSONAdapter extends Adapter {\r\n    /**\r\n      * 构造函数\r\n      * @param {GeometryType} type - 矢量数据类型\r\n      * @param {string} url - 数据文件地址\r\n      */\r\n    constructor(type, url) {\r\n        super(type);\r\n        this._url = url;\r\n    }\r\n    /**\r\n     * 获取矢量数据\r\n     * @return {Promise<Feature[]>} 返回Promise\r\n     */\r\n    async fetch() {\r\n        const response = await fetch(this._url);\r\n        const data = await response.json();\r\n        const features = [];\r\n        Array.isArray(data.features) && data.features.forEach(item => {\r\n            switch (item.geometry.type) {\r\n                case \"Point\":\r\n                    if (this._type == GeometryType.Point) {\r\n                        //TODO: each feature has one type that is ridiculous, cause geojson is a featurecollection, not a featurelayer.\r\n                        // this._type = GeometryType.Point;\r\n                        const point = new Point(new LatLng(item.geometry.coordinates[1], item.geometry.coordinates[0]));\r\n                        features.push(new Feature(point, item.properties));\r\n                    }\r\n                    break;\r\n                case \"LineString\":\r\n                    if (this._type = GeometryType.Polyline) {\r\n                        const polyline = new Polyline(item.geometry.coordinates.map(latlng => {\r\n                            return new LatLng(latlng[1], latlng[0]);\r\n                        }));\r\n                        features.push(new Feature(polyline, item.properties));\r\n                    }\r\n                    break;\r\n                case \"Polygon\":\r\n                    if (this._type = GeometryType.Polygon) {\r\n                        const polygon = new Polygon(item.geometry.coordinates.map(ring => {\r\n                            return ring.map(latlng => {\r\n                                return new LatLng(latlng[1], latlng[0]);\r\n                            });\r\n                        }));\r\n                        features.push(new Feature(polygon, item.properties));\r\n                    }\r\n                    break;\r\n                case \"MultiPoint\":\r\n                    if (this._type == GeometryType.Point) {\r\n                        const multipoint = new MultiplePoint(item.geometry.coordinates.map(latlng => {\r\n                            return new LatLng(latlng[1], latlng[0]);\r\n                        }));\r\n                        features.push(new Feature(multipoint, item.properties));\r\n                    }\r\n                    break;\r\n                case \"MultiLineString\":\r\n                    if (this._type = GeometryType.Polyline) {\r\n                        const multipolyline = new MultiplePolyline(item.geometry.coordinates.map(polyline => {\r\n                            return polyline.map(latlng => {\r\n                                return new LatLng(latlng[1], latlng[0]);\r\n                            });\r\n                        }));\r\n                        features.push(new Feature(multipolyline, item.properties));\r\n                    }\r\n                    break;\r\n                case \"MultiPolygon\":\r\n                    if (this._type = GeometryType.Polygon) {\r\n                        const multipolygon = new MultiplePolygon(item.geometry.coordinates.map(polygon => {\r\n                            return polygon.map(ring => {\r\n                                return ring.map(latlng => {\r\n                                    return new LatLng(latlng[1], latlng[0]);\r\n                                });\r\n                            });\r\n                        }));\r\n                        features.push(new Feature(multipolygon, item.properties));\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n        return features;\r\n    }\r\n}\r\n","import { GeometryType } from \"../../geometry/geometry\";\r\nimport { Raster } from \"../../raster/raster\";\r\n/*\r\n * 热力图\r\n * https://juejin.im/post/6844903709244129293\r\n */\r\nexport class Heat extends Raster {\r\n    /**\r\n     * 构造函数\r\n     */\r\n    constructor() {\r\n        super(0, 0, 0, 0);\r\n        /**\r\n         * 热力半径\r\n         */\r\n        this.radius = 40; //px\r\n        /**\r\n         * 渐变色\r\n         */\r\n        this.gradient = [\r\n            { step: 0.3, color: \"blue\" },\r\n            { step: 0.5, color: \"lime\" },\r\n            { step: 0.7, color: \"yellow\" },\r\n            { step: 1, color: \"red\" }\r\n        ];\r\n        /*\r\n        * 蜂窝显示\r\n        */\r\n        this.honey = false;\r\n        /*\r\n        * 蜂窝边长\r\n        */\r\n        this.honeySide = 10;\r\n    }\r\n    /*\r\n    * 动态栅格（实时渲染）\r\n    */\r\n    get dynamic() {\r\n        return true;\r\n    }\r\n    /**\r\n     * 数据值最小值\r\n     */\r\n    get min() {\r\n        return this._min;\r\n    }\r\n    /**\r\n     * 数据值最小值\r\n     */\r\n    set min(value) {\r\n        this._min = value;\r\n    }\r\n    /**\r\n     * 数据值最大值\r\n     */\r\n    get max() {\r\n        return this._max;\r\n    }\r\n    /**\r\n     * 数据值最大值\r\n     */\r\n    set max(value) {\r\n        this._max = value;\r\n    }\r\n    /**\r\n     * 数据投影\r\n     */\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            feature.geometry.crs = this._crs;\r\n            feature = feature.next;\r\n        }\r\n    }\r\n    /**\r\n     * 数据变换\r\n     * @param {ScreenXY} origin - 窗口坐标原点\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    transform(origin, zoom) {\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            feature.geometry.transform(origin, zoom);\r\n            feature = feature.next;\r\n        }\r\n    }\r\n    /**\r\n     * 初始化\r\n     * @param {FeatureClass} featureClass - 点要素类\r\n     * @param {Field} field - 值字段\r\n     */\r\n    generate(featureClass, field) {\r\n        if (featureClass.type != GeometryType.Point)\r\n            return;\r\n        this._featureClass = featureClass;\r\n        this._field = field;\r\n        const values = featureClass.features.map(feature => feature.properties[field.name]);\r\n        this._min = this._min || Math.min(...values), this._max = this._max || Math.max(...values);\r\n        //初始化色带，256个颜色，1个像素代表1个颜色\r\n        this._ramp = document.createElement(\"canvas\");\r\n        const ramp = this._ramp.getContext('2d');\r\n        this._ramp.width = 256;\r\n        this._ramp.height = 1;\r\n        const grd = ramp.createLinearGradient(0, 0, this._ramp.width, this._ramp.height);\r\n        this.gradient.forEach(item => {\r\n            grd.addColorStop(item.step, item.color);\r\n        });\r\n        ramp.fillStyle = grd;\r\n        ramp.fillRect(0, 0, this._ramp.width, this._ramp.height);\r\n    }\r\n    /**\r\n     * 绘制栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    draw(ctx) {\r\n        if (!this._featureClass || !this._field)\r\n            return;\r\n        //绘制alpha通道图，类似灰度图\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = ctx.canvas.width;\r\n        canvas.height = ctx.canvas.height;\r\n        canvas.style.width = ctx.canvas.style.width;\r\n        canvas.style.height = ctx.canvas.style.height;\r\n        canvas.style.transform = ctx.canvas.style.transform;\r\n        const gray = canvas.getContext(\"2d\");\r\n        // const gray = this.honey ? canvas.getContext(\"2d\") : ctx;  \r\n        const matrix = ctx.getTransform();\r\n        gray.setTransform(matrix.a, 0, 0, matrix.d, matrix.e, matrix.f);\r\n        // const gray = ctx;\r\n        //遍历要素集合，根据字段值画alpha通道图\r\n        this._featureClass.features.forEach((feature) => {\r\n            const value = feature.properties[this._field.name];\r\n            if (value != undefined) {\r\n                const alpha = (value - this._min) / (this._max - this._min);\r\n                const point = feature.geometry;\r\n                const screenX = point.screenXY.x;\r\n                const screenY = point.screenXY.y;\r\n                gray.save();\r\n                gray.lineWidth = 0;\r\n                const radgrad = gray.createRadialGradient(screenX, screenY, 0, screenX, screenY, this.radius);\r\n                radgrad.addColorStop(0, \"rgba(0, 0, 0, 1)\");\r\n                radgrad.addColorStop(1, \"rgba(0, 0, 0, 0)\");\r\n                gray.fillStyle = radgrad;\r\n                gray.globalAlpha = alpha;\r\n                gray.beginPath(); //Start path\r\n                gray.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n                gray.fill();\r\n                gray.restore();\r\n            }\r\n        });\r\n        //根据alpha值找到色带中对应颜色\r\n        const colorData = this._ramp.getContext(\"2d\").getImageData(0, 0, 256, 1).data;\r\n        const imgData = gray.getImageData(0, 0, canvas.width, canvas.height);\r\n        const data = imgData.data;\r\n        if (this.honey) {\r\n            ctx.save();\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            ctx.strokeStyle = \"#ffffff88\";\r\n            ctx.lineWidth = 1;\r\n            // let count = 0;\r\n            let flag = 0; //奇偶标志\r\n            for (let y = 0; y <= canvas.height; y = Math.floor(y + this.honeySide * 1.732 / 2)) {\r\n                for (let x = 0 + flag * (3 / 2 * this.honeySide); x <= canvas.width; x = x + 3 * this.honeySide) {\r\n                    const index = (y * canvas.width + x) * 4;\r\n                    const alpha = data[index + 3];\r\n                    //const pixelData = gray.getImageData(x, y, 1, 1);\r\n                    //const pixel = pixelData.data;\r\n                    //const alpha = pixel[3];\r\n                    if (alpha != 0) {\r\n                        ctx.fillStyle = \"rgba(\" + colorData[4 * alpha] + \",\" + colorData[4 * alpha + 1] + \",\" + colorData[4 * alpha + 2] + \",\" + alpha / 255 + \")\";\r\n                        //ctx.fillStyle =\"rgba(255,0,0,0.5)\";\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(x - this.honeySide, y);\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + this.honeySide, y);\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - this.honeySide, y);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n                        ctx.stroke();\r\n                        // count += 1;\r\n                    }\r\n                }\r\n                flag = flag === 0 ? 1 : 0;\r\n            }\r\n            // console.log(\"honey\", count);\r\n            ctx.restore();\r\n        }\r\n        else {\r\n            for (let i = 0; i < data.length; i++) {\r\n                const value = data[i];\r\n                //只有alpha是有值，R，G，B待设置\r\n                if (value > 0) {\r\n                    //alpha值，对应colorData数组下标\r\n                    data[i - 3] = colorData[4 * value]; //R\r\n                    data[i - 2] = colorData[4 * value + 1]; //G\r\n                    data[i - 1] = colorData[4 * value + 2]; //B\r\n                }\r\n            }\r\n            ctx.save();\r\n            // ctx.setTransform(1,0,0,1,0,0);\r\n            ctx.putImageData(imgData, 0, 0);\r\n            ctx.restore();\r\n        }\r\n    }\r\n}\r\n","import { GeometryType } from \"../../geometry/geometry\";\r\nimport { Raster } from \"../../raster/raster\";\r\n/*\r\n * 反距离加权法（Inverse Distance Weighted）插值\r\n */\r\nexport class IDW extends Raster {\r\n    /**\r\n     * 构造函数\r\n     */\r\n    constructor() {\r\n        super(0, 0, 0, 0);\r\n        /**\r\n         * 分辨率\r\n         */\r\n        this.resolution = 10; //\r\n        /**\r\n         * 渐变色\r\n         */\r\n        //[\"#006837\", \"#1a9850\", \"#66bd63\", \"#a6d96a\", \"#d9ef8b\", \"#ffffbf\", \"#fee08b\", \"#fdae61\", \"#f46d43\", \"#d73027\", \"#a50026\"]\r\n        this.gradient = [\r\n            { step: 0, color: \"#006837\" },\r\n            { step: 0.1, color: \"#1a9850\" },\r\n            { step: 0.2, color: \"#66bd63\" },\r\n            { step: 0.3, color: \"#a6d96a\" },\r\n            { step: 0.4, color: \"#d9ef8b\" },\r\n            { step: 0.5, color: \"#ffffbf\" },\r\n            { step: 0.6, color: \"#fee08b\" },\r\n            { step: 0.7, color: \"#fdae61\" },\r\n            { step: 0.8, color: \"#f46d43\" },\r\n            { step: 0.9, color: \"#d73027\" },\r\n            { step: 1, color: \"#a50026\" }\r\n        ];\r\n        /**\r\n         * 反距离函数\r\n         */\r\n        this.decay = (distance) => {\r\n            return 1 / Math.pow(distance, 3);\r\n        };\r\n        /*\r\n        * 蜂窝显示\r\n        */\r\n        this.honey = false;\r\n        /*\r\n        * 蜂窝边长\r\n        */\r\n        this.honeySide = 10;\r\n        /*\r\n        * 蜂窝颜色\r\n        */\r\n        this.honeyColor = \"#ffffff88\";\r\n    }\r\n    /*\r\n    * 动态栅格（实时渲染）\r\n    */\r\n    get dynamic() {\r\n        return true;\r\n    }\r\n    /**\r\n     * 数据值最小值\r\n     */\r\n    get min() {\r\n        return this._min;\r\n    }\r\n    /**\r\n     * 数据值最小值\r\n     */\r\n    set min(value) {\r\n        this._min = value;\r\n    }\r\n    /**\r\n     * 数据值最大值\r\n     */\r\n    get max() {\r\n        return this._max;\r\n    }\r\n    /**\r\n     * 数据值最大值\r\n     */\r\n    set max(value) {\r\n        this._max = value;\r\n    }\r\n    /**\r\n     * 数据投影\r\n     */\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            feature.geometry.crs = this._crs;\r\n            feature = feature.next;\r\n        }\r\n    }\r\n    /**\r\n     * 数据变换\r\n     * @param {ScreenXY} origin - 窗口坐标原点\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    transform(origin, zoom) {\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            feature.geometry.transform(origin, zoom);\r\n            feature = feature.next;\r\n        }\r\n    }\r\n    /**\r\n     * 初始化\r\n     * @param {FeatureClass} featureClass - 点要素类\r\n     * @param {Field} field - 值字段\r\n     */\r\n    generate(featureClass, field) {\r\n        if (featureClass.type != GeometryType.Point)\r\n            return;\r\n        this._featureClass = featureClass;\r\n        this._field = field;\r\n        const values = featureClass.features.map(feature => feature.properties[field.name]);\r\n        this._min = this._min || Math.min(...values), this._max = this._max || Math.max(...values);\r\n        //初始化色带，256个颜色，1个像素代表1个颜色\r\n        this._ramp = document.createElement(\"canvas\");\r\n        const ramp = this._ramp.getContext('2d');\r\n        this._ramp.width = 256;\r\n        this._ramp.height = 1;\r\n        const grd = ramp.createLinearGradient(0, 0, this._ramp.width, this._ramp.height);\r\n        this.gradient.forEach(item => {\r\n            grd.addColorStop(item.step, item.color);\r\n        });\r\n        ramp.fillStyle = grd;\r\n        ramp.fillRect(0, 0, this._ramp.width, this._ramp.height);\r\n    }\r\n    /**\r\n     * 绘制栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    draw(ctx) {\r\n        if (!this._featureClass || !this._field)\r\n            return;\r\n        const valueData = [];\r\n        // const canvas = document.createElement(\"canvas\");\r\n        // canvas.width = ctx.canvas.width;\r\n        // canvas.height = ctx.canvas.height;\r\n        // canvas.style.width = ctx.canvas.style.width;\r\n        // canvas.style.height = ctx.canvas.style.height;\r\n        // canvas.style.transform = ctx.canvas.style.transform;\r\n        // const gray = canvas.getContext(\"2d\");\r\n        // // const gray = this.honey ? canvas.getContext(\"2d\") : ctx;  \r\n        // const matrix = ctx.getTransform();\r\n        // gray.setTransform(matrix.a, 0, 0, matrix.d, matrix.e, matrix.f);\r\n        const matrix = ctx.getTransform();\r\n        //抽稀\r\n        /*const cluster = this._featureClass.features.reduce( (acc, cur) => {\r\n            if (cur.geometry instanceof Point) {\r\n                const point: Point = cur.geometry;\r\n                const item: any = acc.find((item: any) => {\r\n                    const distance = point.distance(item.geometry, CoordinateType.Screen, ctx, projection);\r\n                    return distance <= 20;\r\n                });\r\n                if (!item) acc.push(cur);\r\n                return acc;\r\n            }\r\n        }, []);*/\r\n        //生成(x,y,value),\r\n        //1.如x,y地理平面坐标，则可放到初始化代码中；\r\n        //2.如x,y屏幕平面坐标，则放在此处，每次重绘重新坐标变换；\r\n        this._featureClass.features.forEach((feature) => {\r\n            const value = feature.properties[this._field.name];\r\n            if (value != undefined) {\r\n                const point = feature.geometry;\r\n                // const screenX = point.screenXY.x;\r\n                // const screenY = point.screenXY.y;\r\n                const screenX = matrix.a * point.screenXY.x + matrix.e;\r\n                const screenY = matrix.d * point.screenXY.y + matrix.f;\r\n                valueData.push([screenX, screenY, (value - this._min) / (this._max - this._min)]);\r\n            }\r\n        });\r\n        //根据alpha值找到色带中对应颜色\r\n        const colorData = this._ramp.getContext(\"2d\").getImageData(0, 0, 256, 1).data;\r\n        //是否采用蜂窝网格渲染\r\n        if (this.honey) {\r\n            ctx.save();\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            ctx.strokeStyle = this.honeyColor;\r\n            ctx.lineWidth = 1;\r\n            let flag = 0; //奇偶标志\r\n            //循环y轴\r\n            for (let y = 0; y <= ctx.canvas.height; y = Math.floor(y + this.honeySide * 1.732 / 2)) {\r\n                //循环x轴\r\n                for (let x = 0 + flag * (3 / 2 * this.honeySide); x <= ctx.canvas.width; x = x + 3 * this.honeySide) {\r\n                    //通过蜂窝网格中心点(x,y)，计算该点的反距离插值\r\n                    let values = 0, weights = 0;\r\n                    valueData.forEach(item => {\r\n                        let distance = Math.sqrt((item[0] - x) * (item[0] - x) + (item[1] - y) * (item[1] - y));\r\n                        distance = distance < 1 ? 1 : distance;\r\n                        let weight = this.decay(distance);\r\n                        values += weight * item[2];\r\n                        weights += weight;\r\n                    });\r\n                    if (weights) {\r\n                        //插值对比色带，找到填充色，填充整个网格\r\n                        const alpha = Math.floor(values / weights * 255);\r\n                        ctx.fillStyle = \"rgba(\" + colorData[4 * alpha] + \",\" + colorData[4 * alpha + 1] + \",\" + colorData[4 * alpha + 2] + \",\" + alpha / 255 + \")\";\r\n                        ctx.beginPath();\r\n                        //绘制蜂窝网格\r\n                        ctx.moveTo(x - this.honeySide, y);\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y - this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x + this.honeySide, y);\r\n                        ctx.lineTo(x + 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - 1 / 2 * this.honeySide, Math.floor(y + this.honeySide * 1.732 / 2));\r\n                        ctx.lineTo(x - this.honeySide, y);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n                        ctx.stroke();\r\n                    }\r\n                }\r\n                //奇偶行换位\r\n                flag = flag === 0 ? 1 : 0;\r\n            }\r\n            ctx.restore();\r\n        }\r\n        else {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = ctx.canvas.width / this.resolution;\r\n            canvas.height = ctx.canvas.height / this.resolution;\r\n            // canvas.width = ctx.canvas.width;\r\n            // canvas.height = ctx.canvas.height;\r\n            // canvas.style.width = ctx.canvas.style.width;\r\n            // canvas.style.height = ctx.canvas.style.height;\r\n            // canvas.style.transform = ctx.canvas.style.transform;\r\n            const gray = canvas.getContext(\"2d\");\r\n            gray.setTransform(matrix.a, 0, 0, matrix.d, matrix.e, matrix.f);\r\n            const imgData = gray.getImageData(0, 0, canvas.width, canvas.height);\r\n            const data = imgData.data;\r\n            for (let i = 0; i < data.length; i = i + 4) {\r\n                const screenY = i / (4 * canvas.width) * this.resolution, screenX = i / 4 % canvas.width * this.resolution;\r\n                // const screenY = i / (4 * canvas.width), screenX = i / 4 % canvas.width;\r\n                let values = 0, weights = 0;\r\n                //加权\r\n                valueData.forEach(item => {\r\n                    let distance = Math.sqrt((item[0] - screenX) * (item[0] - screenX) + (item[1] - screenY) * (item[1] - screenY));\r\n                    distance = distance < 1 ? 1 : distance;\r\n                    let weight = this.decay(distance);\r\n                    values += weight * item[2];\r\n                    weights += weight;\r\n                });\r\n                //像素RGB赋值，赋值方式参考热力图\r\n                if (weights) {\r\n                    const alpha = Math.floor(values / weights * 255);\r\n                    data[i] = colorData[4 * alpha]; //R\r\n                    data[i + 1] = colorData[4 * alpha + 1]; //G\r\n                    data[i + 2] = colorData[4 * alpha + 2]; //B\r\n                    data[i + 3] = alpha;\r\n                }\r\n            }\r\n            gray.putImageData(imgData, 0, 0);\r\n            ctx.save();\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            ctx.drawImage(canvas, 0, 0, ctx.canvas.width, ctx.canvas.height);\r\n            ctx.restore();\r\n            // ctx.save();\r\n            // ctx.putImageData(imgData, 0, 0);\r\n            // ctx.restore();\r\n        }\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../../common/screen-bounds\";\r\nimport { GeometryType } from \"../../geometry/geometry\";\r\nimport { Raster } from \"../../raster/raster\";\r\n/*\r\n * 克里金插值\r\n * http://oeo4b.github.io/#documentation\r\n * https://rawgit.com/oeo4b/kriging.js/master/kriging.js\r\n */\r\nexport class Kriging extends Raster {\r\n    /**\r\n     * 构造函数\r\n     * @param {number} xmin - 经度左值\r\n     * @param {number} ymin - 纬度下值\r\n     * @param {number} xmax - 经度右值\r\n     * @param {number} ymax - 纬度上值\r\n     * @param {number} width - 栅格宽度\r\n     * @param {number} height - 栅格高度\r\n     * @param {number} cellsize - 栅格大小\r\n     */\r\n    constructor(xmin, ymin, xmax, ymax, width = 1000, height = 1000, cellsize = 4) {\r\n        super(xmin, ymin, xmax, ymax, width, height);\r\n        /*\r\n         * 渲染颜色\r\n         */\r\n        this.colors = [\"#006837\", \"#1a9850\", \"#66bd63\", \"#a6d96a\", \"#d9ef8b\", \"#ffffbf\", \"#fee08b\", \"#fdae61\", \"#f46d43\", \"#d73027\", \"#a50026\"];\r\n        /*\r\n         * 插值算法\r\n         */\r\n        this.model = \"exponential\";\r\n        /*\r\n         * 精度 分辨率 1 block = 4 px\r\n         */\r\n        this.cellSize = 4;\r\n        this.cellSize = cellsize;\r\n    }\r\n    // Matrix algebra\r\n    _kriging_matrix_diag(c, n) {\r\n        let i, Z = Array(n * n).fill(0);\r\n        for (i = 0; i < n; i++)\r\n            Z[i * n + i] = c;\r\n        return Z;\r\n    }\r\n    ;\r\n    _kriging_matrix_transpose(X, n, m) {\r\n        let i, j, Z = Array(m * n);\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < m; j++)\r\n                Z[j * n + i] = X[i * m + j];\r\n        return Z;\r\n    }\r\n    ;\r\n    _kriging_matrix_scale(X, c, n, m) {\r\n        let i, j;\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < m; j++)\r\n                X[i * m + j] *= c;\r\n    }\r\n    ;\r\n    _kriging_matrix_add(X, Y, n, m) {\r\n        let i, j, Z = Array(n * m);\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < m; j++)\r\n                Z[i * m + j] = X[i * m + j] + Y[i * m + j];\r\n        return Z;\r\n    }\r\n    ;\r\n    // Naive matrix multiplication\r\n    _kriging_matrix_multiply(X, Y, n, m, p) {\r\n        let i, j, k, Z = Array(n * p);\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < p; j++) {\r\n                Z[i * p + j] = 0;\r\n                for (k = 0; k < m; k++)\r\n                    Z[i * p + j] += X[i * m + k] * Y[k * p + j];\r\n            }\r\n        }\r\n        return Z;\r\n    }\r\n    ;\r\n    // Cholesky decomposition\r\n    _kriging_matrix_chol(X, n) {\r\n        let i, j, k, sum, p = Array(n);\r\n        for (i = 0; i < n; i++)\r\n            p[i] = X[i * n + i];\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < i; j++)\r\n                p[i] -= X[i * n + j] * X[i * n + j];\r\n            if (p[i] <= 0)\r\n                return false;\r\n            p[i] = Math.sqrt(p[i]);\r\n            for (j = i + 1; j < n; j++) {\r\n                for (k = 0; k < i; k++)\r\n                    X[j * n + i] -= X[j * n + k] * X[i * n + k];\r\n                X[j * n + i] /= p[i];\r\n            }\r\n        }\r\n        for (i = 0; i < n; i++)\r\n            X[i * n + i] = p[i];\r\n        return true;\r\n    }\r\n    ;\r\n    // Inversion of cholesky decomposition\r\n    _kriging_matrix_chol2inv(X, n) {\r\n        let i, j, k, sum;\r\n        for (i = 0; i < n; i++) {\r\n            X[i * n + i] = 1 / X[i * n + i];\r\n            for (j = i + 1; j < n; j++) {\r\n                sum = 0;\r\n                for (k = i; k < j; k++)\r\n                    sum -= X[j * n + k] * X[k * n + i];\r\n                X[j * n + i] = sum / X[j * n + j];\r\n            }\r\n        }\r\n        for (i = 0; i < n; i++)\r\n            for (j = i + 1; j < n; j++)\r\n                X[i * n + j] = 0;\r\n        for (i = 0; i < n; i++) {\r\n            X[i * n + i] *= X[i * n + i];\r\n            for (k = i + 1; k < n; k++)\r\n                X[i * n + i] += X[k * n + i] * X[k * n + i];\r\n            for (j = i + 1; j < n; j++)\r\n                for (k = j; k < n; k++)\r\n                    X[i * n + j] += X[k * n + i] * X[k * n + j];\r\n        }\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < i; j++)\r\n                X[i * n + j] = X[j * n + i];\r\n    }\r\n    ;\r\n    // Inversion via gauss-jordan elimination\r\n    _kriging_matrix_solve(X, n) {\r\n        let m = n;\r\n        let b = Array(n * n);\r\n        let indxc = Array(n);\r\n        let indxr = Array(n);\r\n        let ipiv = Array(n);\r\n        let i, icol, irow, j, k, l, ll;\r\n        let big, dum, pivinv, temp;\r\n        for (i = 0; i < n; i++)\r\n            for (j = 0; j < n; j++) {\r\n                if (i == j)\r\n                    b[i * n + j] = 1;\r\n                else\r\n                    b[i * n + j] = 0;\r\n            }\r\n        for (j = 0; j < n; j++)\r\n            ipiv[j] = 0;\r\n        for (i = 0; i < n; i++) {\r\n            big = 0;\r\n            for (j = 0; j < n; j++) {\r\n                if (ipiv[j] != 1) {\r\n                    for (k = 0; k < n; k++) {\r\n                        if (ipiv[k] == 0) {\r\n                            if (Math.abs(X[j * n + k]) >= big) {\r\n                                big = Math.abs(X[j * n + k]);\r\n                                irow = j;\r\n                                icol = k;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ++(ipiv[icol]);\r\n            if (irow != icol) {\r\n                for (l = 0; l < n; l++) {\r\n                    temp = X[irow * n + l];\r\n                    X[irow * n + l] = X[icol * n + l];\r\n                    X[icol * n + l] = temp;\r\n                }\r\n                for (l = 0; l < m; l++) {\r\n                    temp = b[irow * n + l];\r\n                    b[irow * n + l] = b[icol * n + l];\r\n                    b[icol * n + l] = temp;\r\n                }\r\n            }\r\n            indxr[i] = irow;\r\n            indxc[i] = icol;\r\n            if (X[icol * n + icol] == 0)\r\n                return false; // Singular\r\n            pivinv = 1 / X[icol * n + icol];\r\n            X[icol * n + icol] = 1;\r\n            for (l = 0; l < n; l++)\r\n                X[icol * n + l] *= pivinv;\r\n            for (l = 0; l < m; l++)\r\n                b[icol * n + l] *= pivinv;\r\n            for (ll = 0; ll < n; ll++) {\r\n                if (ll != icol) {\r\n                    dum = X[ll * n + icol];\r\n                    X[ll * n + icol] = 0;\r\n                    for (l = 0; l < n; l++)\r\n                        X[ll * n + l] -= X[icol * n + l] * dum;\r\n                    for (l = 0; l < m; l++)\r\n                        b[ll * n + l] -= b[icol * n + l] * dum;\r\n                }\r\n            }\r\n        }\r\n        for (l = (n - 1); l >= 0; l--)\r\n            if (indxr[l] != indxc[l]) {\r\n                for (k = 0; k < n; k++) {\r\n                    temp = X[k * n + indxr[l]];\r\n                    X[k * n + indxr[l]] = X[k * n + indxc[l]];\r\n                    X[k * n + indxc[l]] = temp;\r\n                }\r\n            }\r\n        return true;\r\n    }\r\n    // Variogram models\r\n    _kriging_variogram_gaussian(h, nugget, range, sill, A) {\r\n        return nugget + ((sill - nugget) / range) *\r\n            (1.0 - Math.exp(-(1.0 / A) * Math.pow(h / range, 2)));\r\n    }\r\n    ;\r\n    _kriging_variogram_exponential(h, nugget, range, sill, A) {\r\n        return nugget + ((sill - nugget) / range) *\r\n            (1.0 - Math.exp(-(1.0 / A) * (h / range)));\r\n    }\r\n    ;\r\n    _kriging_variogram_spherical(h, nugget, range, sill, A) {\r\n        if (h > range)\r\n            return nugget + (sill - nugget) / range;\r\n        return nugget + ((sill - nugget) / range) *\r\n            (1.5 * (h / range) - 0.5 * Math.pow(h / range, 3));\r\n    }\r\n    ;\r\n    // Train using gaussian processes with bayesian priors\r\n    train(t, x, y, model, sigma2, alpha) {\r\n        let variogram = {\r\n            t: t,\r\n            x: x,\r\n            y: y,\r\n            nugget: 0.0,\r\n            range: 0.0,\r\n            sill: 0.0,\r\n            A: 1 / 3,\r\n            n: 0,\r\n            model: null,\r\n            K: null,\r\n            M: null\r\n        };\r\n        switch (model) {\r\n            case \"gaussian\":\r\n                variogram.model = this._kriging_variogram_gaussian;\r\n                break;\r\n            case \"exponential\":\r\n                variogram.model = this._kriging_variogram_exponential;\r\n                break;\r\n            case \"spherical\":\r\n                variogram.model = this._kriging_variogram_spherical;\r\n                break;\r\n        }\r\n        ;\r\n        // Lag distance/semivariance\r\n        let i, j, k, l, n = t.length;\r\n        let distance = Array((n * n - n) / 2);\r\n        for (i = 0, k = 0; i < n; i++)\r\n            for (j = 0; j < i; j++, k++) {\r\n                distance[k] = Array(2);\r\n                distance[k][0] = Math.pow(Math.pow(x[i] - x[j], 2) +\r\n                    Math.pow(y[i] - y[j], 2), 0.5);\r\n                distance[k][1] = Math.abs(t[i] - t[j]);\r\n            }\r\n        distance.sort((a, b) => { return a[0] - b[0]; });\r\n        variogram.range = distance[(n * n - n) / 2 - 1][0];\r\n        // Bin lag distance\r\n        let lags = ((n * n - n) / 2) > 30 ? 30 : (n * n - n) / 2;\r\n        let tolerance = variogram.range / lags;\r\n        let lag = Array(lags).fill(0);\r\n        let semi = Array(lags).fill(0);\r\n        if (lags < 30) {\r\n            for (l = 0; l < lags; l++) {\r\n                lag[l] = distance[l][0];\r\n                semi[l] = distance[l][1];\r\n            }\r\n        }\r\n        else {\r\n            for (i = 0, j = 0, k = 0, l = 0; i < lags && j < ((n * n - n) / 2); i++, k = 0) {\r\n                while (distance[j][0] <= ((i + 1) * tolerance)) {\r\n                    lag[l] += distance[j][0];\r\n                    semi[l] += distance[j][1];\r\n                    j++;\r\n                    k++;\r\n                    if (j >= ((n * n - n) / 2))\r\n                        break;\r\n                }\r\n                if (k > 0) {\r\n                    lag[l] /= k;\r\n                    semi[l] /= k;\r\n                    l++;\r\n                }\r\n            }\r\n            if (l < 2)\r\n                return variogram; // Error: Not enough points\r\n        }\r\n        // Feature transformation\r\n        n = l;\r\n        variogram.range = lag[n - 1] - lag[0];\r\n        let X = Array(2 * n).fill(1);\r\n        let Y = Array(n);\r\n        let A = variogram.A;\r\n        for (i = 0; i < n; i++) {\r\n            switch (model) {\r\n                case \"gaussian\":\r\n                    X[i * 2 + 1] = 1.0 - Math.exp(-(1.0 / A) * Math.pow(lag[i] / variogram.range, 2));\r\n                    break;\r\n                case \"exponential\":\r\n                    X[i * 2 + 1] = 1.0 - Math.exp(-(1.0 / A) * lag[i] / variogram.range);\r\n                    break;\r\n                case \"spherical\":\r\n                    X[i * 2 + 1] = 1.5 * (lag[i] / variogram.range) -\r\n                        0.5 * Math.pow(lag[i] / variogram.range, 3);\r\n                    break;\r\n            }\r\n            ;\r\n            Y[i] = semi[i];\r\n        }\r\n        // Least squares\r\n        let Xt = this._kriging_matrix_transpose(X, n, 2);\r\n        let Z = this._kriging_matrix_multiply(Xt, X, 2, n, 2);\r\n        Z = this._kriging_matrix_add(Z, this._kriging_matrix_diag(1 / alpha, 2), 2, 2);\r\n        let cloneZ = Z.slice(0);\r\n        if (this._kriging_matrix_chol(Z, 2))\r\n            this._kriging_matrix_chol2inv(Z, 2);\r\n        else {\r\n            this._kriging_matrix_solve(cloneZ, 2);\r\n            Z = cloneZ;\r\n        }\r\n        let W = this._kriging_matrix_multiply(this._kriging_matrix_multiply(Z, Xt, 2, 2, n), Y, 2, n, 1);\r\n        // Variogram parameters\r\n        variogram.nugget = W[0];\r\n        variogram.sill = W[1] * variogram.range + variogram.nugget;\r\n        variogram.n = x.length;\r\n        // Gram matrix with prior\r\n        n = x.length;\r\n        let K = Array(n * n);\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < i; j++) {\r\n                K[i * n + j] = variogram.model(Math.pow(Math.pow(x[i] - x[j], 2) +\r\n                    Math.pow(y[i] - y[j], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n                K[j * n + i] = K[i * n + j];\r\n            }\r\n            K[i * n + i] = variogram.model(0, variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n        }\r\n        // Inverse penalized Gram matrix projected to target vector\r\n        let C = this._kriging_matrix_add(K, this._kriging_matrix_diag(sigma2, n), n, n);\r\n        let cloneC = C.slice(0);\r\n        if (this._kriging_matrix_chol(C, n))\r\n            this._kriging_matrix_chol2inv(C, n);\r\n        else {\r\n            this._kriging_matrix_solve(cloneC, n);\r\n            C = cloneC;\r\n        }\r\n        // Copy unprojected inverted matrix as K\r\n        let K2 = C.slice(0);\r\n        let M = this._kriging_matrix_multiply(C, t, n, n, 1);\r\n        variogram.K = K2;\r\n        variogram.M = M;\r\n        return variogram;\r\n    }\r\n    ;\r\n    // Model prediction\r\n    predict(x, y, variogram) {\r\n        var i, k = Array(variogram.n);\r\n        for (i = 0; i < variogram.n; i++)\r\n            k[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2) +\r\n                Math.pow(y - variogram.y[i], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n        return this._kriging_matrix_multiply(k, variogram.M, 1, variogram.n, 1)[0];\r\n    }\r\n    ;\r\n    variance(x, y, variogram) {\r\n        var i, k = Array(variogram.n);\r\n        for (i = 0; i < variogram.n; i++)\r\n            k[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2) +\r\n                Math.pow(y - variogram.y[i], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n        return variogram.model(0, variogram.nugget, variogram.range, variogram.sill, variogram.A) +\r\n            this._kriging_matrix_multiply(this._kriging_matrix_multiply(k, variogram.K, 1, variogram.n, variogram.n), k, 1, variogram.n, 1)[0];\r\n    }\r\n    ;\r\n    // Gridded matrices or contour paths\r\n    grid(polygons, variogram, width) {\r\n        var i, j, k, n = polygons.length;\r\n        if (n == 0)\r\n            return;\r\n        // Boundaries of polygons space\r\n        var xlim = [polygons[0][0][0], polygons[0][0][0]];\r\n        var ylim = [polygons[0][0][1], polygons[0][0][1]];\r\n        for (i = 0; i < n; i++) // Polygons\r\n            for (j = 0; j < polygons[i].length; j++) { // Vertices\r\n                if (polygons[i][j][0] < xlim[0])\r\n                    xlim[0] = polygons[i][j][0];\r\n                if (polygons[i][j][0] > xlim[1])\r\n                    xlim[1] = polygons[i][j][0];\r\n                if (polygons[i][j][1] < ylim[0])\r\n                    ylim[0] = polygons[i][j][1];\r\n                if (polygons[i][j][1] > ylim[1])\r\n                    ylim[1] = polygons[i][j][1];\r\n            }\r\n        // Alloc for O(n^2) space\r\n        var xtarget, ytarget;\r\n        var a = Array(2), b = Array(2);\r\n        var lxlim = Array(2); // Local dimensions\r\n        var lylim = Array(2); // Local dimensions\r\n        var x = Math.ceil((xlim[1] - xlim[0]) / width);\r\n        var y = Math.ceil((ylim[1] - ylim[0]) / width);\r\n        var A = Array(x + 1);\r\n        const _pip = (array, x, y) => {\r\n            let i, j, c = false;\r\n            for (i = 0, j = array.length - 1; i < array.length; j = i++) {\r\n                if (((array[i][1] > y) != (array[j][1] > y)) &&\r\n                    (x < (array[j][0] - array[i][0]) * (y - array[i][1]) / (array[j][1] - array[i][1]) + array[i][0])) {\r\n                    c = !c;\r\n                }\r\n            }\r\n            return c;\r\n        };\r\n        for (i = 0; i <= x; i++)\r\n            A[i] = Array(y + 1);\r\n        for (i = 0; i < n; i++) {\r\n            // Range for polygons[i]\r\n            lxlim[0] = polygons[i][0][0];\r\n            lxlim[1] = lxlim[0];\r\n            lylim[0] = polygons[i][0][1];\r\n            lylim[1] = lylim[0];\r\n            for (j = 1; j < polygons[i].length; j++) { // Vertices\r\n                if (polygons[i][j][0] < lxlim[0])\r\n                    lxlim[0] = polygons[i][j][0];\r\n                if (polygons[i][j][0] > lxlim[1])\r\n                    lxlim[1] = polygons[i][j][0];\r\n                if (polygons[i][j][1] < lylim[0])\r\n                    lylim[0] = polygons[i][j][1];\r\n                if (polygons[i][j][1] > lylim[1])\r\n                    lylim[1] = polygons[i][j][1];\r\n            }\r\n            // Loop through polygon subspace\r\n            a[0] = Math.floor(((lxlim[0] - ((lxlim[0] - xlim[0]) % width)) - xlim[0]) / width);\r\n            a[1] = Math.ceil(((lxlim[1] - ((lxlim[1] - xlim[1]) % width)) - xlim[0]) / width);\r\n            b[0] = Math.floor(((lylim[0] - ((lylim[0] - ylim[0]) % width)) - ylim[0]) / width);\r\n            b[1] = Math.ceil(((lylim[1] - ((lylim[1] - ylim[1]) % width)) - ylim[0]) / width);\r\n            for (j = a[0]; j <= a[1]; j++)\r\n                for (k = b[0]; k <= b[1]; k++) {\r\n                    xtarget = xlim[0] + j * width;\r\n                    ytarget = ylim[0] + k * width;\r\n                    if (_pip(polygons[i], xtarget, ytarget))\r\n                        A[j][k] = this.predict(xtarget, ytarget, variogram);\r\n                }\r\n        }\r\n        return {\r\n            A: A,\r\n            xlim: xlim,\r\n            ylim: ylim,\r\n            zlim: [Math.min(...variogram.t), Math.max(...variogram.t)],\r\n            width: width\r\n        };\r\n    }\r\n    ;\r\n    contour(value, polygons, variogram) {\r\n    }\r\n    ;\r\n    plot(grid, xlim, ylim, colors) {\r\n        // Clear screen\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        // Starting boundaries\r\n        var range = [xlim[1] - xlim[0], ylim[1] - ylim[0], grid.zlim[1] - grid.zlim[0]];\r\n        var i, j, x, y, z;\r\n        var n = grid.A.length;\r\n        var m = grid.A[0].length;\r\n        var wx = Math.ceil(grid.width * this.canvas.width / (xlim[1] - xlim[0]));\r\n        var wy = Math.ceil(grid.width * this.canvas.height / (ylim[1] - ylim[0]));\r\n        for (i = 0; i < n; i++) {\r\n            for (j = 0; j < m; j++) {\r\n                if (grid.A[i][j] == undefined)\r\n                    continue;\r\n                x = this.canvas.width * (i * grid.width + grid.xlim[0] - xlim[0]) / range[0];\r\n                y = this.canvas.height * (1 - (j * grid.width + grid.ylim[0] - ylim[0]) / range[1]);\r\n                z = (grid.A[i][j] - grid.zlim[0]) / range[2];\r\n                if (z < 0.0)\r\n                    z = 0.0;\r\n                if (z > 1.0)\r\n                    z = 1.0;\r\n                ctx.fillStyle = colors[Math.floor((colors.length - 1) * z)];\r\n                ctx.fillRect(Math.round(x - wx / 2), Math.round(y - wy / 2), wx, wy);\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    /**\r\n     * 数据投影\r\n     */\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        const plane1 = this._crs.projection.project(this.bounds.getSouthWest());\r\n        const plane2 = this._crs.projection.project(this.bounds.getNorthEast());\r\n        this._planeBounds = new ScreenBounds(plane1, plane2);\r\n    }\r\n    /**\r\n     * 数据变换\r\n     * @param {ScreenXY} origin - 窗口坐标原点\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    transform(origin, zoom) {\r\n        if (!this._crs && !this._planeBounds)\r\n            return;\r\n        const screen1 = this._crs.planeXYToScreenXY(this._planeBounds.getBottomLeft(), zoom).round(false).subtract(origin);\r\n        const screen2 = this._crs.planeXYToScreenXY(this._planeBounds.getTopRight(), zoom).round(false).subtract(origin);\r\n        this._screenBounds = new ScreenBounds(screen1, screen2);\r\n    }\r\n    /**\r\n     * 生成插值\r\n     * @param {FeatureClass} featureClass - 插值点要素类\r\n     * @param {Field} field - 插值字段\r\n     */\r\n    generate(featureClass, field) {\r\n        if (featureClass.type != GeometryType.Point)\r\n            return;\r\n        const values = featureClass.features.map(feature => feature.properties[field.name]);\r\n        const lngs = featureClass.features.map(feature => feature.geometry.latlng.lng);\r\n        const lats = featureClass.features.map(feature => feature.geometry.latlng.lat);\r\n        const variogram = this.train(values, lngs, lats, this.model, 0, 100);\r\n        const bounds = this.bounds;\r\n        const boundary = [[[bounds.getWest(), bounds.getSouth()], [bounds.getWest(), bounds.getNorth()], [bounds.getEast(), bounds.getNorth()], [bounds.getEast(), bounds.getSouth()]]];\r\n        const grid = this.grid(boundary, variogram, (bounds.getNorth() - bounds.getSouth()) / (this.canvas.height / this.cellSize));\r\n        this.plot(grid, [bounds.getWest(), bounds.getEast()], [bounds.getSouth(), bounds.getNorth()], this.colors);\r\n    }\r\n    /**\r\n     * 绘制栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    draw(ctx) {\r\n        if (!this._screenBounds)\r\n            return;\r\n        // ctx.save();\r\n        let screenXMin = this._screenBounds.min.x;\r\n        let screenYMin = this._screenBounds.min.y;\r\n        let screenXMax = this._screenBounds.max.x;\r\n        let screenYMax = this._screenBounds.max.y;\r\n        //this.resample(this.canvas, this.canvas.width, this.canvas.height, false);\r\n        ctx.drawImage(this.canvas, screenXMin, screenYMin, screenXMax - screenXMin, screenYMax - screenYMin);\r\n        // ctx.restore();\r\n    }\r\n}\r\n","/**\r\n * 动画效果基类\r\n * @remarks\r\n * 动画两种实现方式：\r\n * 1.针对单个图形要素，实现动画，使用时，逻辑较清晰；\r\n * 2.针对整个图层，类似Symbol，使用时，可能存在效率问题；\r\n * 目前暂实现1，针对2，目前保留部分已注释的代码，便于日后参考。\r\n */\r\nexport class Animation {\r\n}\r\n","/**\r\n * 线默认动画效果类\r\n * @remarks\r\n * 类似航线效果\r\n */\r\nexport class LineAnimation extends Animation {\r\n    /**\r\n     * 构造函数\r\n     * @param {Polyline} geometry - 线\r\n     */\r\n    constructor(geometry) {\r\n        super();\r\n        this._percent = 0;\r\n        /**\r\n         * 线宽\r\n         */\r\n        this.lineWidth = 2;\r\n        /**\r\n         * 起始色\r\n         */\r\n        this.startColor = \"#ff0000\";\r\n        /**\r\n         * 终止色\r\n         */\r\n        this.endColor = \"#ffff00\";\r\n        /**\r\n         * 二次贝塞尔曲线控制点与线段夹角\r\n         */\r\n        this.angle = Math.PI / 4;\r\n        this._polyline = geometry;\r\n    }\r\n    /**\r\n     * 数据投影\r\n     * @param {CRS} crs - 坐标系\r\n     */\r\n    project(crs) {\r\n        this._polyline.crs = crs;\r\n    }\r\n    /**\r\n     * 数据变换\r\n     * @param {ScreenXY} origin - 窗口坐标原点\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    transform(origin, zoom) {\r\n        this._polyline.transform(origin, zoom);\r\n        //TODO: polyline, not line; but now just line\r\n        const start = this._polyline._screenXYs[0];\r\n        const end = this._polyline._screenXYs[1];\r\n        this._start = [start.x, start.y];\r\n        this._end = [end.x, end.y];\r\n        const k = (this._end[1] - this._start[1]) / (this._end[0] - this._start[0]);\r\n        const d = Math.sqrt((this._end[1] - this._start[1]) * (this._end[1] - this._start[1]) + (this._end[0] - this._start[0]) * (this._end[0] - this._start[0]));\r\n        const s = d / 2 / Math.cos(this.angle);\r\n        //const a = (Math.atan(k) < 0 ? (Math.PI +  Math.atan(k)) : Math.atan(k)) - this.angle;\r\n        //this._control = this._start[0] >= this._end[0] ? [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)] : [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];\r\n        const a = Math.atan(k) - this.angle;\r\n        if (Math.atan(k) < 0) {\r\n            if (this._end[0] > this._start[0]) {\r\n                this._control = [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)];\r\n            }\r\n            else {\r\n                this._control = [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];\r\n            }\r\n        }\r\n        else {\r\n            if (this._end[0] > this._start[0]) {\r\n                this._control = [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)];\r\n            }\r\n            else {\r\n                this._control = [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];\r\n            }\r\n        }\r\n        this._percent = 0;\r\n    }\r\n    /**\r\n     * 动画效果\r\n     * @remarks\r\n     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数\r\n     * @param {number} elapsed - 已逝去的时间，毫秒\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    animate(elapsed, ctx) {\r\n        ctx.save();\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        // ctx.setTransform(1,0,0,1,0,0);\r\n        const lineGradient = ctx.createLinearGradient(this._start[0], this._start[1], this._end[0], this._end[1]);\r\n        lineGradient.addColorStop(0, this.startColor);\r\n        lineGradient.addColorStop(1, this.endColor);\r\n        ctx.strokeStyle = lineGradient; //设置线条样式\r\n        this._drawCurvePath(ctx, this._start, this._control, this._end, this._percent);\r\n        this._percent += 0.8; //控制动画速度\r\n        if (this._percent >= 100) { //没有画完接着调用,画完的话重置进度\r\n            this._percent = 0;\r\n        }\r\n        ctx.restore();\r\n    }\r\n    _drawCurvePath(ctx, start, point, end, percent) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(start[0], start[1]);\r\n        for (let t = 0; t <= percent / 100; t += 0.005) {\r\n            let x = this._quadraticBezier(start[0], point[0], end[0], t);\r\n            let y = this._quadraticBezier(start[1], point[1], end[1], t);\r\n            ctx.lineTo(x, y);\r\n        }\r\n        ctx.stroke();\r\n    }\r\n    _quadraticBezier(p0, p1, p2, t) {\r\n        let k = 1 - t;\r\n        return k * k * p0 + 2 * (1 - t) * t * p1 + t * t * p2; // 二次贝赛尔曲线方程\r\n    }\r\n}\r\n","import { Animation } from './animation';\r\n/**\r\n * 点默认动画效果类\r\n * @remarks\r\n * 类似flashing效果，从中心点向外光环扩散效果\r\n */\r\nexport class PointAnimation extends Animation {\r\n    //radius: number = this.limit / this.ring;\r\n    /**\r\n     * 构造函数\r\n     * @param {Point} geometry - 点\r\n     */\r\n    constructor(geometry) {\r\n        super();\r\n        /**\r\n         * 边宽\r\n         */\r\n        this.lineWidth = 3;\r\n        /**\r\n         * 颜色\r\n         */\r\n        this.color = \"#ff0000\";\r\n        /**\r\n         * 扩散速度\r\n         */\r\n        this.velocity = 10; //  px/s\r\n        /**\r\n         * 扩散的最大半径\r\n         */\r\n        this.limit = 30;\r\n        /**\r\n         * 扩散的光圈数\r\n         */\r\n        this.ring = 3;\r\n        this._point = geometry;\r\n    }\r\n    /**\r\n     * 数据投影\r\n     * @param {CRS} crs - 坐标系\r\n     */\r\n    project(crs) {\r\n        this._point.crs = crs;\r\n        /*ctx.save();\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        ctx.setTransform(1,0,0,1,0,0);\r\n        ctx.beginPath(); //Start path\r\n        ctx.arc(this._screenX, this._screenY, this.limit / this.ring, 0, Math.PI * 2, true);\r\n        ctx.stroke();\r\n        ctx.restore();*/\r\n    }\r\n    /**\r\n     * 数据变换\r\n     * @param {ScreenXY} origin - 窗口坐标原点\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    transform(origin, zoom) {\r\n        this._point.transform(origin, zoom);\r\n    }\r\n    /**\r\n     * 动画效果\r\n     * @remarks\r\n     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数\r\n     * @param {number} elapsed - 已逝去的时间，毫秒\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    animate(elapsed, ctx) {\r\n        const screenXY = this._point.screenXY;\r\n        ctx.save();\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        // ctx.setTransform(1,0,0,1,0,0);\r\n        /*ctx.arc(this._screenX, this._screenY, this.limit / this.ring, 0, Math.PI * 2, true);\r\n        ctx.fill();*/\r\n        for (let i = 0; i < this.ring; i++) {\r\n            ctx.beginPath(); //Start path\r\n            ctx.arc(screenXY.x, screenXY.y, (elapsed / 1000 * this.velocity + i * this.limit / this.ring) % this.limit, 0, Math.PI * 2, true);\r\n            //ctx.arc(this._screenX, this._screenY, this.limit / this.ring + ((elapsed/1000 + (this.limit - this.limit / this.ring) / this.velocity * (i/(this.ring - 1))) * this.velocity) % this.limit, 0, Math.PI * 2, true);\r\n            ctx.stroke();\r\n        }\r\n        ctx.restore();\r\n    }\r\n}\r\n","/**\r\n * 所有类的基类\r\n */\r\nexport class BaseObject {\r\n}\r\n","import * as Browser from '../util/browser';\r\nimport * as DomEvent from '../util/dom-event';\r\nimport * as DomUtil from '../util/dom-util';\r\nimport * as Util from '../util/util';\r\nimport { EventedObject } from './evented-object';\r\nimport { ScreenXY } from '../common/screen-xy';\r\nimport { OptionsObject } from './options-object';\r\n/*\r\n * @class Draggable\r\n * @aka L.Draggable\r\n * @inherits Evented\r\n *\r\n * A class for making DOM elements draggable (including touch support).\r\n * Used internally for map and marker dragging. Only works for elements\r\n * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n *\r\n * @example\r\n * ```js\r\n * var draggable = new L.Draggable(elementToDrag);\r\n * draggable.enable();\r\n * ```\r\n */\r\nconst START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\r\nconst END = {\r\n    mousedown: 'mouseup',\r\n    touchstart: 'touchend',\r\n    pointerdown: 'touchend',\r\n    MSPointerDown: 'touchend'\r\n};\r\nconst MOVE = {\r\n    mousedown: 'mousemove',\r\n    touchstart: 'touchmove',\r\n    pointerdown: 'touchmove',\r\n    MSPointerDown: 'touchmove'\r\n};\r\n/**\r\n * 可拖拽选项\r\n */\r\nexport class DraggableOptions extends OptionsObject {\r\n    constructor() {\r\n        super(...arguments);\r\n        // @section\r\n        // @aka Draggable options\r\n        // @option clickTolerance: Number = 3\r\n        // The max number of pixels a user can shift the mouse pointer during a click\r\n        // for it to be considered a valid click (as opposed to a mouse drag).\r\n        this.clickTolerance = 3;\r\n        this.preventOutline = false;\r\n    }\r\n}\r\n/**\r\n * 可拖拽类\r\n */\r\nexport class DraggableObject extends EventedObject {\r\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\r\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\r\n    constructor(element, dragStartTarget, options) {\r\n        super();\r\n        this.options = new DraggableOptions();\r\n        this.options.assign(options);\r\n        this._element = element;\r\n        this._dragStartTarget = dragStartTarget || element;\r\n    }\r\n    // @method enable()\r\n    // Enables the dragging ability\r\n    enable() {\r\n        if (this._enabled) {\r\n            return;\r\n        }\r\n        DomEvent.on(this._dragStartTarget, START, this._onDown, this);\r\n        this._enabled = true;\r\n    }\r\n    // @method disable()\r\n    // Disables the dragging ability\r\n    disable() {\r\n        if (!this._enabled) {\r\n            return;\r\n        }\r\n        // If we're currently dragging this draggable,\r\n        // disabling it counts as first ending the drag.\r\n        if (DraggableObject._dragging === this) {\r\n            this.finishDrag();\r\n        }\r\n        DomEvent.off(this._dragStartTarget, START, this._onDown, this);\r\n        this._enabled = false;\r\n        this._moved = false;\r\n    }\r\n    _onDown(e) {\r\n        // Ignore simulated events, since we handle both touch and\r\n        // mouse explicitly; otherwise we risk getting duplicates of\r\n        // touch events, see #4315.\r\n        // Also ignore the event if disabled; this happens in IE11\r\n        // under some circumstances, see #3666.\r\n        if (e._simulated || !this._enabled) {\r\n            return;\r\n        }\r\n        this._moved = false;\r\n        if (DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) {\r\n            return;\r\n        }\r\n        if (DraggableObject._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) {\r\n            return;\r\n        }\r\n        DraggableObject._dragging = this; // Prevent dragging multiple objects at once.\r\n        if (this._moving) {\r\n            return;\r\n        }\r\n        // @event down: Event\r\n        // Fired when a drag is about to start.\r\n        this.fire('down');\r\n        var first = e.touches ? e.touches[0] : e, sizedParent = DomUtil.getSizedParentNode(this._element);\r\n        this._startPoint = new ScreenXY(first.clientX, first.clientY);\r\n        // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\r\n        this._parentScale = DomUtil.getScale(sizedParent);\r\n        DomEvent.on(document, MOVE[e.type], this._onMove, this);\r\n        DomEvent.on(document, END[e.type], this._onUp, this);\r\n    }\r\n    _onMove(e) {\r\n        // Ignore simulated events, since we handle both touch and\r\n        // mouse explicitly; otherwise we risk getting duplicates of\r\n        // touch events, see #4315.\r\n        // Also ignore the event if disabled; this happens in IE11\r\n        // under some circumstances, see #3666.\r\n        if (e._simulated || !this._enabled) {\r\n            return;\r\n        }\r\n        if (e.touches && e.touches.length > 1) {\r\n            this._moved = true;\r\n            return;\r\n        }\r\n        var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e), offset = new ScreenXY(first.clientX, first.clientY).subtract(this._startPoint);\r\n        if (!offset.x && !offset.y) {\r\n            return;\r\n        }\r\n        if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\r\n            return;\r\n        }\r\n        // We assume that the parent container's position, border and scale do not change for the duration of the drag.\r\n        // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\r\n        // and we can use the cached value for the scale.\r\n        offset.x /= this._parentScale.x;\r\n        offset.y /= this._parentScale.y;\r\n        DomEvent.preventDefault(e);\r\n        if (!this._moved) {\r\n            // @event dragstart: Event\r\n            // Fired when a drag starts\r\n            this.fire('dragstart');\r\n            this._moved = true;\r\n            this._startPos = DomUtil.getPosition(this._element).subtract(offset);\r\n            DomUtil.addClass(document.body, 'leaflet-dragging');\r\n            this._lastTarget = e.target || e.srcElement;\r\n            // IE and Edge do not give the <use> element, so fetch it\r\n            // if necessary\r\n            // if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\r\n            // \tthis._lastTarget = this._lastTarget.correspondingUseElement;\r\n            // }\r\n            DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n        }\r\n        this._newPos = this._startPos.add(offset);\r\n        this._moving = true;\r\n        Util.cancelAnimFrame(this._animRequest);\r\n        this._lastEvent = e;\r\n        this._animRequest = Util.requestAnimFrame(this._updatePosition, this, true);\r\n    }\r\n    _updatePosition() {\r\n        var e = { originalEvent: this._lastEvent };\r\n        // @event predrag: Event\r\n        // Fired continuously during dragging *before* each corresponding\r\n        // update of the element's position.\r\n        this.fire('predrag', e);\r\n        DomUtil.setPosition(this._element, this._newPos);\r\n        // @event drag: Event\r\n        // Fired continuously during dragging.\r\n        this.fire('drag', e);\r\n    }\r\n    _onUp(e) {\r\n        // Ignore simulated events, since we handle both touch and\r\n        // mouse explicitly; otherwise we risk getting duplicates of\r\n        // touch events, see #4315.\r\n        // Also ignore the event if disabled; this happens in IE11\r\n        // under some circumstances, see #3666.\r\n        if (e._simulated || !this._enabled) {\r\n            return;\r\n        }\r\n        this.finishDrag();\r\n    }\r\n    finishDrag() {\r\n        DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n        if (this._lastTarget) {\r\n            DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n            this._lastTarget = null;\r\n        }\r\n        for (var i in MOVE) {\r\n            DomEvent.off(document, MOVE[i], this._onMove, this);\r\n            DomEvent.off(document, END[i], this._onUp, this);\r\n        }\r\n        if (this._moved && this._moving) {\r\n            // ensure drag is not fired after dragend\r\n            Util.cancelAnimFrame(this._animRequest);\r\n            // @event dragend: DragEndEvent\r\n            // Fired when the drag ends.\r\n            this.fire('dragend', {\r\n                distance: this._newPos.distanceTo(this._startPos)\r\n            });\r\n        }\r\n        this._moving = false;\r\n        DraggableObject._dragging = null;\r\n    }\r\n}\r\n","import * as Util from '../util/util';\r\nimport { IDObject } from \"./id-object\";\r\n/**\r\n * 可激发及监听事件基类\r\n */\r\nexport class EventedObject extends IDObject {\r\n    constructor() {\r\n        super();\r\n        this._events = {};\r\n        this._eventParents = {};\r\n        this._firingCount = 0;\r\n    }\r\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n       * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n       *\r\n       * @alternative\r\n       * @method on(eventMap: Object): this\r\n       * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n       */\r\n    on(types, fn, context) {\r\n        // types can be a map of types/handlers\r\n        if (typeof types === 'object') {\r\n            for (let type in types) {\r\n                // we don't process space-separated events here for performance;\r\n                // it's a hot path since Layer uses the on(obj) syntax\r\n                this._on(type, types[type], fn);\r\n            }\r\n        }\r\n        else {\r\n            // types can be a string of space-separated words\r\n            types = Util.splitWords(types);\r\n            for (let i = 0, len = types.length; i < len; i++) {\r\n                this._on(types[i], fn, context);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\r\n    off(types, fn, context) {\r\n        if (!types) {\r\n            // clear all listeners if called without arguments\r\n            this._events = {};\r\n        }\r\n        else if (typeof types === 'object') {\r\n            for (let type in types) {\r\n                this._off(type, types[type], fn);\r\n            }\r\n        }\r\n        else {\r\n            types = Util.splitWords(types);\r\n            for (let i = 0, len = types.length; i < len; i++) {\r\n                this._off(types[i], fn, context);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    // attach listener (without syntactic sugar now)\r\n    _on(type, fn, context) {\r\n        this._events = this._events || {};\r\n        /* get/init listeners for type */\r\n        let typeListeners = this._events[type];\r\n        if (!typeListeners) {\r\n            typeListeners = [];\r\n            this._events[type] = typeListeners;\r\n        }\r\n        if (context === this) {\r\n            // Less memory footprint.\r\n            context = undefined;\r\n        }\r\n        let newListener = { fn: fn, ctx: context }, listeners = typeListeners;\r\n        // check if fn already there\r\n        for (let i = 0, len = listeners.length; i < len; i++) {\r\n            if (listeners[i].fn === fn && listeners[i].ctx === context) {\r\n                return;\r\n            }\r\n        }\r\n        listeners.push(newListener);\r\n    }\r\n    _off(type, fn, context) {\r\n        let listeners, i, len;\r\n        if (!this._events) {\r\n            return;\r\n        }\r\n        listeners = this._events[type];\r\n        if (!listeners) {\r\n            return;\r\n        }\r\n        if (!fn) {\r\n            // Set all removed listeners to noop so they are not called if remove happens in fire\r\n            for (i = 0, len = listeners.length; i < len; i++) {\r\n                listeners[i].fn = Util.falseFn;\r\n            }\r\n            // clear all listeners for a type if function isn't specified\r\n            delete this._events[type];\r\n            return;\r\n        }\r\n        if (context === this) {\r\n            context = undefined;\r\n        }\r\n        if (listeners) {\r\n            // find fn and remove it\r\n            for (i = 0, len = listeners.length; i < len; i++) {\r\n                var l = listeners[i];\r\n                if (l.ctx !== context) {\r\n                    continue;\r\n                }\r\n                if (l.fn === fn) {\r\n                    // set the removed listener to noop so that's not called if remove happens in fire\r\n                    l.fn = Util.falseFn;\r\n                    if (this._firingCount) {\r\n                        /* copy array in case events are being fired */\r\n                        this._events[type] = listeners = listeners.slice();\r\n                    }\r\n                    listeners.splice(i, 1);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\r\n    // Fires an event of the specified type. You can optionally provide a data\r\n    // object — the first argument of the listener function will contain its\r\n    // properties. The event can optionally be propagated to event parents.\r\n    fire(type, data, propagate) {\r\n        if (!this.listens(type, propagate)) {\r\n            return this;\r\n        }\r\n        const event = Object.assign({}, data, {\r\n            type: type,\r\n            target: this,\r\n            sourceTarget: data && data.sourceTarget || this\r\n        });\r\n        if (this._events) {\r\n            let listeners = this._events[type];\r\n            if (listeners) {\r\n                this._firingCount = (this._firingCount + 1) || 1;\r\n                for (let i = 0, len = listeners.length; i < len; i++) {\r\n                    let l = listeners[i];\r\n                    l.fn.call(l.ctx || this, event);\r\n                }\r\n                this._firingCount--;\r\n            }\r\n        }\r\n        if (propagate) {\r\n            // propagate the event to parents (set with addEventParent)\r\n            this._propagateEvent(event);\r\n        }\r\n        return this;\r\n    }\r\n    // @method listens(type: String): Boolean\r\n    // Returns `true` if a particular event type has any listeners attached to it.\r\n    listens(type, propagate) {\r\n        var listeners = this._events && this._events[type];\r\n        if (listeners && listeners.length) {\r\n            return true;\r\n        }\r\n        if (propagate) {\r\n            // also check parents for listeners if event propagates\r\n            for (var id in this._eventParents) {\r\n                if (this._eventParents[id].listens(type, propagate)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    // @method once(…): this\r\n    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\r\n    once(types, fn, context) {\r\n        if (typeof types === 'object') {\r\n            for (var type in types) {\r\n                this.once(type, types[type], fn);\r\n            }\r\n            return this;\r\n        }\r\n        const handler = () => {\r\n            this\r\n                .off(types, fn, context)\r\n                .off(types, handler, context);\r\n        };\r\n        // add a listener that's executed once and removed after that\r\n        return this\r\n            .on(types, fn, context)\r\n            .on(types, handler, context);\r\n    }\r\n    // @method addEventParent(obj: Evented): this\r\n    // Adds an event parent - an `Evented` that will receive propagated events\r\n    addEventParent(obj) {\r\n        this._eventParents = this._eventParents || {};\r\n        this._eventParents[obj.id] = obj;\r\n        return this;\r\n    }\r\n    // @method removeEventParent(obj: Evented): this\r\n    // Removes an event parent, so it will stop receiving propagated events\r\n    removeEventParent(obj) {\r\n        if (this._eventParents) {\r\n            delete this._eventParents[obj.id];\r\n        }\r\n        return this;\r\n    }\r\n    _propagateEvent(e) {\r\n        for (var id in this._eventParents) {\r\n            this._eventParents[id].fire(e.type, Object.assign({\r\n                layer: e.target,\r\n                propagatedFrom: e.target\r\n            }, e), true);\r\n        }\r\n    }\r\n    // @method addEventListener(…): this\r\n    // Alias to [`on(…)`](#evented-on)\r\n    addEventListener(types, fn, context) {\r\n        this.on(types, fn, context);\r\n    }\r\n    // @method removeEventListener(…): this\r\n    // Alias to [`off(…)`](#evented-off)\r\n    removeEventListener(types, fn, context) {\r\n        this.off(types, fn, context);\r\n    }\r\n    // @method clearAllEventListeners(…): this\r\n    // Alias to [`off()`](#evented-off)\r\n    clearAllEventListeners(types, fn, context) {\r\n        this.off(types, fn, context);\r\n    }\r\n    // @method addOneTimeEventListener(…): this\r\n    // Alias to [`once(…)`](#evented-once)\r\n    addOneTimeEventListener(types, fn, context) {\r\n        this.once(types, fn, context);\r\n    }\r\n    // @method fireEvent(…): this\r\n    // Alias to [`fire(…)`](#evented-fire)\r\n    fireEvent(type, data, propagate) {\r\n        this.fire(type, data, propagate);\r\n    }\r\n    // @method hasEventListeners(…): Boolean\r\n    // Alias to [`listens(…)`](#evented-listens)\r\n    hasEventListeners(type, propagate) {\r\n        this.listens(type, propagate);\r\n    }\r\n}\r\n","import { IDObject } from \"./id-object\";\r\n/**\r\n * 可处理Map事件基类\r\n */\r\nexport class HandlerObject extends IDObject {\r\n    // @section There is static function which can be called without instantiating L.Handler:\r\n    // @function addTo(map: Map, name: String): this\r\n    // Adds a new Handler to the given map with the given name.\r\n    // static addTo(map: Map, name: string) {\r\n    //   map.addHandler(name, this);\r\n    //   return this;\r\n    // }\r\n    constructor(map) {\r\n        super();\r\n        this._enabled = false;\r\n        this._map = map;\r\n    }\r\n    // @method enable(): this\r\n    // Enables the handler\r\n    enable() {\r\n        if (this._enabled) {\r\n            return this;\r\n        }\r\n        this._enabled = true;\r\n        this.addHooks();\r\n        return this;\r\n    }\r\n    // @method disable(): this\r\n    // Disables the handler\r\n    disable() {\r\n        if (!this._enabled) {\r\n            return this;\r\n        }\r\n        this._enabled = false;\r\n        this.removeHooks();\r\n        return this;\r\n    }\r\n    // @method enabled(): Boolean\r\n    // Returns `true` if the handler is enabled\r\n    enabled() {\r\n        return !!this._enabled;\r\n    }\r\n    // @section Extension methods\r\n    // Classes inheriting from `Handler` must implement the two following methods:\r\n    // @method addHooks()\r\n    // Called when the handler is enabled, should add event hooks.\r\n    // @method removeHooks()\r\n    // Called when the handler is disabled, should remove the event hooks added previously.\r\n    addHooks() {\r\n    }\r\n    removeHooks() {\r\n    }\r\n}\r\n","import { BaseObject } from \"./base-object\";\r\n/**\r\n * 带ID实体基类\r\n */\r\nexport class IDObject extends BaseObject {\r\n    /**\r\n      * 构造函数\r\n      */\r\n    constructor() {\r\n        super();\r\n        this._create();\r\n    }\r\n    /**\r\n    * ID\r\n    */\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    _create() {\r\n        // const timestamp = (new Date().getTime() / 1000 | 0).toString(16);\r\n        // this._id = timestamp + 'xxxxxxxxxxxxxxxx'.replace(/[x]/g, function() {\r\n        //     return (Math.random() * 16 | 0).toString(16);\r\n        // }).toLowerCase();\r\n        IDObject.MAX_ID += 1;\r\n        this._id = IDObject.MAX_ID;\r\n    }\r\n    /**\r\n      * 输出字符串\r\n      */\r\n    toString() {\r\n        return this._id.toString();\r\n    }\r\n}\r\n/**\r\n* 最大ID（类变量）\r\n*/\r\nIDObject.MAX_ID = 0;\r\n","import { BaseObject } from \"./base-object\";\r\n/**\r\n * 实体配置选项基类\r\n */\r\nexport class OptionsObject extends BaseObject {\r\n    /**\r\n      * 构造函数\r\n      */\r\n    constructor() {\r\n        super();\r\n    }\r\n    /**\r\n      * 赋值函数\r\n      */\r\n    assign(options) {\r\n        if (options !== undefined) {\r\n            for (let key in options) {\r\n                if (this.hasOwnProperty(key)) {\r\n                    this[key] = options[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { XY } from './xy';\r\n/**\r\n * 坐标范围\r\n * @remark Represents a rectangular area in plane or pixel coordinates.\r\n */\r\nexport class XYBounds {\r\n    /**\r\n     * 构造函数\r\n     * @param {XY | XY[]} a - 坐标或坐标数组\r\n     * @param {XY} b - 坐标\r\n     */\r\n    constructor(a, b) {\r\n        let points;\r\n        if (a instanceof XY && b instanceof XY) {\r\n            points = [a, b];\r\n        }\r\n        else if (Array.isArray(a)) {\r\n            points = a;\r\n        }\r\n        else if (typeof a === 'undefined' && typeof b === 'undefined') {\r\n            points = [];\r\n        }\r\n        else {\r\n            throw new Error('Bounds constructor has an invalid argument.');\r\n        }\r\n        for (var i = 0, len = points.length; i < len; i++) {\r\n            this.extend(points[i]);\r\n        }\r\n    }\r\n    // @method extend(point: Point): this\r\n    // Extends the bounds to contain the given point.\r\n    /**\r\n   * 扩展坐标范围\r\n   * @param {XY | XYBounds} obj - 坐标或坐标范围\r\n   * @return {LatLngBounds} 返回坐标范围\r\n   */\r\n    extend(obj) {\r\n        // @property min: Point\r\n        // The top left corner of the rectangle.\r\n        // @property max: Point\r\n        // The bottom right corner of the rectangle.\r\n        if (obj instanceof XY) {\r\n            if (!this.min && !this.max) {\r\n                this.min = obj.clone();\r\n                this.max = obj.clone();\r\n            }\r\n            else {\r\n                this.min.x = Math.min(obj.x, this.min.x);\r\n                this.max.x = Math.max(obj.x, this.max.x);\r\n                this.min.y = Math.min(obj.y, this.min.y);\r\n                this.max.y = Math.max(obj.y, this.max.y);\r\n            }\r\n        }\r\n        else if (obj instanceof XYBounds) {\r\n            if (!this.min && !this.max) {\r\n                this.min = obj.min.clone();\r\n                this.max = obj.max.clone();\r\n            }\r\n            else {\r\n                this.min.x = Math.min(obj.min.x, this.min.x);\r\n                this.max.x = Math.max(obj.max.x, this.max.x);\r\n                this.min.y = Math.min(obj.min.y, this.min.y);\r\n                this.max.y = Math.max(obj.max.y, this.max.y);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    // @method getTopLeft(): Point\r\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\r\n    /**\r\n   * 获取左上角\r\n   * @return {XY} 返回左上角XY\r\n   */\r\n    getTopLeft() {\r\n        return this.min; // left, top\r\n    }\r\n    // @method getBottomRight(): Point\r\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\r\n    /**\r\n   * 获取右下角\r\n   * @return {XY} 返回右下角XY\r\n   */\r\n    getBottomRight() {\r\n        return this.max; // right, bottom\r\n    }\r\n    // @method getSize(): Point\r\n    // Returns the size of the given bounds\r\n    /**\r\n     * 获取范围大小XY\r\n     * @return {XY} 返回范围大小XY\r\n     */\r\n    getSize() {\r\n        return this.max.subtract(this.min);\r\n    }\r\n    // @method contains(otherBounds: Bounds): Boolean\r\n    // Returns `true` if the rectangle contains the given one.\r\n    // @alternative\r\n    // @method contains(point: Point): Boolean\r\n    // Returns `true` if the rectangle contains the given point.\r\n    /**\r\n     * 判断是否包含坐标或坐标范围\r\n     * @param {XYBounds | XY} obj - 坐标或坐标范围\r\n     * @return {boolean} 返回是否包含\r\n     */\r\n    contains(obj) {\r\n        let min, max;\r\n        if (obj instanceof XYBounds) {\r\n            min = obj.min;\r\n            max = obj.max;\r\n        }\r\n        else {\r\n            min = max = obj;\r\n        }\r\n        return (min.x >= this.min.x) &&\r\n            (max.x <= this.max.x) &&\r\n            (min.y >= this.min.y) &&\r\n            (max.y <= this.max.y);\r\n    }\r\n    // @method intersects(otherBounds: Bounds): Boolean\r\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\r\n    // intersect if they have at least one point in common.\r\n    /**\r\n     * 判断是否与另一经纬度范围有交叉\r\n     * @param {LatLngBounds} obj - 经纬度范围\r\n     * @return {boolean} 返回是否交叉\r\n     */\r\n    intersects(bounds) {\r\n        let min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = (max2.x >= min.x) && (min2.x <= max.x), yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n        return xIntersects && yIntersects;\r\n    }\r\n    // @method overlaps(otherBounds: Bounds): Boolean\r\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\r\n    // overlap if their intersection is an area.\r\n    /**\r\n     * 判断是否与另一坐标范围有叠盖\r\n     * @param {XYBounds} obj - 经纬度范围\r\n     * @return {boolean} 返回是否叠盖\r\n     */\r\n    overlaps(bounds) {\r\n        let min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = (max2.x > min.x) && (min2.x < max.x), yOverlaps = (max2.y > min.y) && (min2.y < max.y);\r\n        return xOverlaps && yOverlaps;\r\n    }\r\n    /**\r\n     * 判断坐标范围是否有效\r\n     * @return {boolean} 返回是否有效\r\n     */\r\n    isValid() {\r\n        return !!(this.min && this.max);\r\n    }\r\n}\r\n","import { LatLng } from './latlng';\r\n/**\r\n * 经纬度坐标范围\r\n * @remark Represents a rectangular geographical area on a map.\r\n */\r\nexport class LatLngBounds {\r\n    /**\r\n     * 构造函数\r\n     * @param {LatLng | LatLng[]} a - 经纬度或经纬度数组\r\n     * @param {LatLng} b - 经纬度\r\n     */\r\n    constructor(a, b) {\r\n        let latlngs;\r\n        if (a instanceof LatLng && b instanceof LatLng) {\r\n            latlngs = [a, b];\r\n        }\r\n        else if (Array.isArray(a)) {\r\n            latlngs = a;\r\n        }\r\n        else if (typeof a === 'undefined' && typeof b === 'undefined') {\r\n            latlngs = [];\r\n        }\r\n        else {\r\n            throw new Error('LatLngBounds constructor has an invalid argument.');\r\n        }\r\n        for (var i = 0, len = latlngs.length; i < len; i++) {\r\n            this.extend(latlngs[i]);\r\n        }\r\n    }\r\n    // @method extend(latlng: LatLng): this\r\n    // Extend the bounds to contain the given point\r\n    // @alternative\r\n    // @method extend(otherBounds: LatLngBounds): this\r\n    // Extend the bounds to contain the given bounds\r\n    /**\r\n     * 扩展经纬度范围\r\n     * @param {LatLng | LatLngBounds} obj - 经纬度或经纬度范围\r\n     * @return {LatLngBounds} 返回经纬度范围\r\n     */\r\n    extend(obj) {\r\n        let sw = this._southWest, ne = this._northEast, sw2, ne2;\r\n        if (obj instanceof LatLng) {\r\n            sw2 = obj;\r\n            ne2 = obj;\r\n        }\r\n        else {\r\n            sw2 = obj._southWest;\r\n            ne2 = obj._northEast;\r\n            if (!sw2 || !ne2) {\r\n                return this;\r\n            }\r\n        }\r\n        if (!sw && !ne) {\r\n            this._southWest = new LatLng(sw2.lat, sw2.lng);\r\n            this._northEast = new LatLng(ne2.lat, ne2.lng);\r\n        }\r\n        else {\r\n            sw.lat = Math.min(sw2.lat, sw.lat);\r\n            sw.lng = Math.min(sw2.lng, sw.lng);\r\n            ne.lat = Math.max(ne2.lat, ne.lat);\r\n            ne.lng = Math.max(ne2.lng, ne.lng);\r\n        }\r\n        return this;\r\n    }\r\n    // @method pad(bufferRatio: Number): LatLngBounds\r\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\r\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\r\n    // Negative values will retract the bounds.\r\n    /**\r\n   * 缓冲经纬度范围\r\n   * @param {number} bufferRatio - 缓冲比例\r\n   * @return {LatLngBounds} 返回经纬度范围\r\n   */\r\n    pad(bufferRatio) {\r\n        let sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n        return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n    }\r\n    // @method getCenter(): LatLng\r\n    // Returns the center point of the bounds.\r\n    /**\r\n     * 中心点经纬度\r\n     * @remark Returns the center point of the bounds.\r\n     * @return {LatLng} 返回经纬度\r\n     */\r\n    getCenter() {\r\n        return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\r\n    }\r\n    // @method getSouthWest(): LatLng\r\n    // Returns the south-west point of the bounds.\r\n    /**\r\n     * 西南角经纬度\r\n     * @remark Returns the south-west point of the bounds.\r\n     * @return {LatLng} 返回经纬度\r\n     */\r\n    getSouthWest() {\r\n        return this._southWest;\r\n    }\r\n    // @method getNorthEast(): LatLng\r\n    // Returns the north-east point of the bounds.\r\n    /**\r\n     * 东北角经纬度\r\n     * @remark Returns the north-east point of the bounds.\r\n     * @return {LatLng} 返回经纬度\r\n     */\r\n    getNorthEast() {\r\n        return this._northEast;\r\n    }\r\n    // @method getNorthWest(): LatLng\r\n    // Returns the north-west point of the bounds.\r\n    /**\r\n     * 西北角经纬度\r\n     * @remark Returns the north-west point of the bounds.\r\n     * @return {LatLng} 返回经纬度\r\n     */\r\n    getNorthWest() {\r\n        return new LatLng(this.getNorth(), this.getWest());\r\n    }\r\n    // @method getSouthEast(): LatLng\r\n    // Returns the south-east point of the bounds.\r\n    /**\r\n     * 东南角经纬度\r\n     * @remark Returns the south-east point of the bounds.\r\n     * @return {LatLng} 返回经纬度\r\n     */\r\n    getSouthEast() {\r\n        return new LatLng(this.getSouth(), this.getEast());\r\n    }\r\n    // @method getWest(): Number\r\n    // Returns the west longitude of the bounds\r\n    /**\r\n     * 西边经度\r\n     * @remark Returns the west longitude of the bounds\r\n     * @return {number} 返回经度\r\n     */\r\n    getWest() {\r\n        return this._southWest.lng;\r\n    }\r\n    // @method getSouth(): Number\r\n    // Returns the south latitude of the bounds\r\n    /**\r\n     * 南边纬度\r\n     * @remark Returns the south latitude of the bounds\r\n     * @return {number} 返回纬度\r\n     */\r\n    getSouth() {\r\n        return this._southWest.lat;\r\n    }\r\n    // @method getEast(): Number\r\n    // Returns the east longitude of the bounds\r\n    /**\r\n     * 东边经度\r\n     * @remark Returns the east longitude of the bounds\r\n     * @return {number} 返回经度\r\n     */\r\n    getEast() {\r\n        return this._northEast.lng;\r\n    }\r\n    // @method getNorth(): Number\r\n    // Returns the north latitude of the bounds\r\n    /**\r\n     * 北边纬度\r\n     * @remark Returns the north latitude of the bounds\r\n     * @return {number} 返回纬度\r\n     */\r\n    getNorth() {\r\n        return this._northEast.lat;\r\n    }\r\n    // @method contains(otherBounds: LatLngBounds): Boolean\r\n    // Returns `true` if the rectangle contains the given one.\r\n    // @alternative\r\n    // @method contains (latlng: LatLng): Boolean\r\n    // Returns `true` if the rectangle contains the given point.\r\n    /**\r\n     * 判断是否包含经纬度或经纬度范围\r\n     * @param {LatLng | LatLngBounds} obj - 经纬度或经纬度范围\r\n     * @return {boolean} 返回是否包含\r\n     */\r\n    contains(obj) {\r\n        let sw = this._southWest, ne = this._northEast, sw2, ne2;\r\n        if (obj instanceof LatLngBounds) {\r\n            sw2 = obj.getSouthWest();\r\n            ne2 = obj.getNorthEast();\r\n        }\r\n        else {\r\n            sw2 = ne2 = obj;\r\n        }\r\n        return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n            (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n    }\r\n    // @method intersects(otherBounds: LatLngBounds): Boolean\r\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\r\n    /**\r\n   * 判断是否与另一经纬度范围有交叉\r\n   * @param {LatLngBounds} obj - 经纬度范围\r\n   * @return {boolean} 返回是否交叉\r\n   */\r\n    intersects(bounds) {\r\n        let sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat), lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n        return latIntersects && lngIntersects;\r\n    }\r\n    // @method overlaps(otherBounds: LatLngBounds): Boolean\r\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\r\n    /**\r\n   * 判断是否与另一经纬度范围有叠盖\r\n   * @param {LatLngBounds} obj - 经纬度范围\r\n   * @return {boolean} 返回是否叠盖\r\n   */\r\n    overlaps(bounds) {\r\n        const sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat), lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);\r\n        return latOverlaps && lngOverlaps;\r\n    }\r\n    // @method toBBoxString(): String\r\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\r\n    /**\r\n   * 输出字符串\r\n   * @return {string} 返回字符串\r\n   */\r\n    toString() {\r\n        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n    }\r\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\r\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\r\n    /**\r\n   * 判断经纬度范围是否相等（在一定容差内）\r\n   * @param {LatLngBounds} bounds - 经纬度范围\r\n   * @param {number} maxMargin - 容差\r\n   * @return {boolean} 返回是否相等\r\n   */\r\n    equals(bounds, maxMargin = 1.0E-9) {\r\n        if (!bounds) {\r\n            return false;\r\n        }\r\n        return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&\r\n            this._northEast.equals(bounds.getNorthEast(), maxMargin);\r\n    }\r\n    // @method isValid(): Boolean\r\n    // Returns `true` if the bounds are properly initialized.\r\n    /**\r\n     * 判断经纬度范围是否有效\r\n     * @return {boolean} 返回是否有效\r\n     */\r\n    isValid() {\r\n        return !!(this._southWest && this._northEast);\r\n    }\r\n}\r\n","import * as Util from '../util/util';\r\nimport { Earth } from '../crs/crs-earth';\r\nimport { LatLngBounds } from './latlng-bounds';\r\n/**\r\n * 经纬度坐标\r\n */\r\nexport class LatLng {\r\n    /**\r\n      * 构造函数\r\n      * @param {number} lat - 纬度\r\n      * @param {number} lng - 经度\r\n      * @param {number} alt - 海拔\r\n      */\r\n    constructor(lat = 0, lng = 0, alt = 0) {\r\n        // @property lat: Number\r\n        // Latitude in degrees\r\n        this.lat = lat;\r\n        // @property lng: Number\r\n        // Longitude in degrees\r\n        this.lng = lng;\r\n        // @property alt: Number\r\n        // Altitude in meters (optional)\r\n        this.alt = alt;\r\n    }\r\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\r\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\r\n    /**\r\n   * 判断坐标是否相等（在一定容差内）\r\n   * @param {LatLng} obj - 经纬度\r\n   * @param {number} maxMargin - 容差\r\n   * @return {boolean} 返回是否相等\r\n   */\r\n    equals(obj, maxMargin = 1.0E-9) {\r\n        if (!obj) {\r\n            return false;\r\n        }\r\n        const margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\r\n        return margin <= maxMargin;\r\n    }\r\n    // @method toString(): String\r\n    // Returns a string representation of the point (for debugging purposes).\r\n    /**\r\n     * 输出字符串\r\n     * @param {number} precision - 保留精度\r\n     * @return {string} 返回字符串\r\n     */\r\n    toString(precision = 6) {\r\n        return 'LatLng(' +\r\n            Util.formatNum(this.lat, precision) + ', ' +\r\n            Util.formatNum(this.lng, precision) + ')';\r\n    }\r\n    /**\r\n     * 输出GeoJSON格式\r\n     * @param {number} precision - 保留精度\r\n     * @return {Object} 返回GeoJSON格式\r\n     */\r\n    toGeoJSON(precision = 6) {\r\n        return [Util.formatNum(this.lng, precision), Util.formatNum(this.lat, precision)];\r\n    }\r\n    // @method distanceTo(otherLatLng: LatLng): Number\r\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\r\n    /**\r\n   * 计算与另一点间球面距离\r\n   * @param {LatLng} other - 另一点经纬度\r\n   * @return {number} 返回距离\r\n   */\r\n    distanceTo(other) {\r\n        return new Earth().distance(this, other);\r\n    }\r\n    // @method wrap(): LatLng\r\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\r\n    /**\r\n   * 根据取值范围返回经纬度\r\n   * @return {LatLng} 返回取值范围内的经纬度\r\n   */\r\n    wrap() {\r\n        return new Earth().wrapLatLng(this);\r\n    }\r\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\r\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\r\n    /**\r\n   * 根据实地距离返回经纬度范围\r\n   * @param {number} sizeInMeters - 实地距离（米）\r\n   * @return {LatLng} 返回经纬度范围\r\n   */\r\n    toLatLngBounds(sizeInMeters) {\r\n        var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\r\n        return new LatLngBounds(new LatLng(this.lat - latAccuracy, this.lng - lngAccuracy), new LatLng(this.lat + latAccuracy, this.lng + lngAccuracy));\r\n    }\r\n    /**\r\n     * 克隆经纬度\r\n     * @return {LatLng} 返回经纬度\r\n     */\r\n    clone() {\r\n        return new LatLng(this.lat, this.lng, this.alt);\r\n    }\r\n}\r\n","import { XYBounds } from './bounds';\r\nimport { PlaneXY } from './plane-xy';\r\n/**\r\n * 平面坐标范围\r\n * @remark Represents a rectangular area in plane coordinates.\r\n */\r\nexport class PlaneBounds extends XYBounds {\r\n    /**\r\n     * 构造函数\r\n     * @param {PlaneXY | PlaneXY[]} a - 平面坐标或平面坐标数组\r\n     * @param {PlaneXY} b - 平面坐标\r\n     */\r\n    constructor(a, b) {\r\n        super(a, b);\r\n    }\r\n    // @method getCenter(round?: Boolean): Point\r\n    // Returns the center point of the bounds.\r\n    /**\r\n     * 获取中心点\r\n     * @param {boolean} round - 是否取整\r\n     * @return {PlaneXY} 返回中心点\r\n     */\r\n    getCenter(round = false) {\r\n        const x = round ? Math.round((this.min.x + this.max.x) / 2) : (this.min.x + this.max.x) / 2;\r\n        const y = round ? Math.round((this.min.y + this.max.y) / 2) : (this.min.y + this.max.y) / 2;\r\n        return new PlaneXY(x, y);\r\n    }\r\n    // @method getBottomLeft(): Point\r\n    // Returns the bottom-left point of the bounds.\r\n    /**\r\n   * 获取左下角\r\n   * @return {PlaneXY} 返回左下角\r\n   */\r\n    getBottomLeft() {\r\n        return new PlaneXY(this.min.x, this.max.y);\r\n    }\r\n    // @method getTopRight(): Point\r\n    // Returns the top-right point of the bounds.\r\n    /**\r\n     * 获取右上角\r\n     * @return {PlaneXY} 返回右上角\r\n     */\r\n    getTopRight() {\r\n        return new PlaneXY(this.max.x, this.min.y);\r\n    }\r\n}\r\n","import { formatNum } from '../util/util';\r\nimport { XY } from './xy';\r\n/**\r\n * 平面坐标\r\n */\r\nexport class PlaneXY extends XY {\r\n    /**\r\n      * 构造函数\r\n      * @param {number} x - X\r\n      * @param {number} y - Y\r\n      */\r\n    constructor(x = 0, y = 0) {\r\n        super(x, y);\r\n    }\r\n    // @method clone(): Point\r\n    // Returns a copy of the current point.\r\n    /**\r\n     * 克隆坐标\r\n     * @return {PlaneXY} 返回坐标\r\n     */\r\n    clone() {\r\n        return new PlaneXY(this.x, this.y);\r\n    }\r\n    // @method distanceTo(otherPoint: Point): Number\r\n    // Returns the cartesian distance between the current and the given points.\r\n    /**\r\n   * 计算与另一点间欧式距离\r\n   * @param {PlaneXY} planeXY - 另一点坐标\r\n   * @return {number} 返回距离\r\n   */\r\n    distanceTo(planeXY) {\r\n        return super.distanceTo(planeXY);\r\n    }\r\n    // @method equals(otherPoint: Point): Boolean\r\n    // Returns `true` if the given point has the same coordinates.\r\n    /**\r\n   * 判断坐标是否相等\r\n   * @param {PlaneXY} obj - 坐标\r\n   * @return {boolean} 返回是否相等\r\n   */\r\n    equals(planeXY) {\r\n        return super.equals(planeXY);\r\n    }\r\n    // @method contains(otherPoint: Point): Boolean\r\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n    /**\r\n   * 判断是否包含坐标\r\n   * @param {PlaneXY} obj - 坐标\r\n   * Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n   * @return {boolean} 返回是否包含\r\n   */\r\n    contains(planeXY) {\r\n        return super.contains(planeXY);\r\n    }\r\n    // @method toString(): String\r\n    // Returns a string representation of the point for debugging purposes.\r\n    /**\r\n   * 输出字符串\r\n   * @param {number} precision - 保留精度\r\n   * @return {string} 返回字符串\r\n   */\r\n    toString(precision = 3) {\r\n        return 'PlaneXY(' +\r\n            formatNum(this.x, precision) + ', ' +\r\n            formatNum(this.y, precision) + ')';\r\n    }\r\n}\r\n","import { XYBounds } from './bounds';\r\nimport { ScreenXY } from './screen-xy';\r\n/**\r\n * 屏幕坐标范围\r\n * @remark Represents a rectangular area in pixel coordinates.\r\n */\r\nexport class ScreenBounds extends XYBounds {\r\n    /**\r\n     * 构造函数\r\n     * @param {ScreenXY | ScreenXY[]} a - 屏幕坐标或屏幕坐标数组\r\n     * @param {ScreenXY} b - 屏幕坐标\r\n     */\r\n    constructor(a, b) {\r\n        super(a, b);\r\n    }\r\n    // @method getCenter(round?: Boolean): Point\r\n    // Returns the center point of the bounds.\r\n    /**\r\n   * 获取中心点\r\n   * @param {boolean} round - 是否取整\r\n   * @return {ScreenXY} 返回中心点\r\n   */\r\n    getCenter(round = false) {\r\n        const x = round ? Math.round((this.min.x + this.max.x) / 2) : (this.min.x + this.max.x) / 2;\r\n        const y = round ? Math.round((this.min.y + this.max.y) / 2) : (this.min.y + this.max.y) / 2;\r\n        return new ScreenXY(x, y);\r\n    }\r\n    // @method getBottomLeft(): Point\r\n    // Returns the bottom-left point of the bounds.\r\n    /**\r\n   * 获取左下角\r\n   * @return {ScreenXY} 返回左下角\r\n   */\r\n    getBottomLeft() {\r\n        return new ScreenXY(this.min.x, this.max.y);\r\n    }\r\n    // @method getTopRight(): Point\r\n    // Returns the top-right point of the bounds.\r\n    /**\r\n     * 获取右上角\r\n     * @return {ScreenXY} 返回右上角\r\n     */\r\n    getTopRight() {\r\n        return new ScreenXY(this.max.x, this.min.y);\r\n    }\r\n    /**\r\n     * 缓冲范围\r\n     * @param {number} pixel - 缓冲像素\r\n     */\r\n    pad(pixel) {\r\n        this.min.x -= pixel;\r\n        this.min.y -= pixel;\r\n        this.max.x += pixel;\r\n        this.max.y += pixel;\r\n    }\r\n}\r\n","import { formatNum } from '../util/util';\r\nimport { XY } from './xy';\r\n/**\r\n * 屏幕坐标\r\n */\r\nexport class ScreenXY extends XY {\r\n    /**\r\n      * 构造函数\r\n      * @param {number} x - X\r\n      * @param {number} y - Y\r\n      */\r\n    constructor(x = 0, y = 0) {\r\n        super(x, y);\r\n    }\r\n    // @method clone(): Point\r\n    // Returns a copy of the current point.\r\n    /**\r\n     * 克隆坐标\r\n     * @return {ScreenXY} 返回坐标\r\n     */\r\n    clone() {\r\n        return new ScreenXY(this.x, this.y);\r\n    }\r\n    // @method distanceTo(otherPoint: Point): Number\r\n    // Returns the cartesian distance between the current and the given points.\r\n    /**\r\n   * 计算与另一点间欧式距离\r\n   * @param {ScreenXY} screenXY - 另一点坐标\r\n   * @return {number} 返回距离\r\n   */\r\n    distanceTo(screenXY) {\r\n        return super.distanceTo(screenXY);\r\n    }\r\n    // @method equals(otherPoint: Point): Boolean\r\n    // Returns `true` if the given point has the same coordinates.\r\n    /**\r\n   * 判断坐标是否相等\r\n   * @param {ScreenXY} obj - 坐标\r\n   * @return {boolean} 返回是否相等\r\n   */\r\n    equals(screenXY) {\r\n        return super.equals(screenXY);\r\n    }\r\n    // @method contains(otherPoint: Point): Boolean\r\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n    /**\r\n   * 判断是否包含坐标\r\n   * @param {ScreenXY} obj - 坐标\r\n   * Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n   * @return {boolean} 返回是否包含\r\n   */\r\n    contains(screenXY) {\r\n        return super.contains(screenXY);\r\n    }\r\n    // @method toString(): String\r\n    // Returns a string representation of the point for debugging purposes.\r\n    /**\r\n   * 输出字符串\r\n   * @param {number} precision - 保留精度\r\n   * @return {string} 返回字符串\r\n   */\r\n    toString(precision = 3) {\r\n        return 'ScreenXY(' +\r\n            formatNum(this.x, precision) + ', ' +\r\n            formatNum(this.y, precision) + ')';\r\n    }\r\n}\r\n","import { formatNum } from '../util/util';\r\n/**\r\n * 坐标\r\n */\r\nexport class XY {\r\n    /**\r\n      * 构造函数\r\n      * @param {number} x - X\r\n      * @param {number} y - Y\r\n      */\r\n    constructor(x = 0, y = 0) {\r\n        // @property x: Number; The `x` coordinate of the point\r\n        this.x = x;\r\n        // @property y: Number; The `y` coordinate of the point\r\n        this.y = y;\r\n    }\r\n    // @method add(otherPoint: Point): Point\r\n    // Returns the result of addition of the current and the given points.\r\n    /**\r\n   * 坐标相加\r\n   * @param {XY} otherXY - 另一坐标\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    add(otherXY, clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x += otherXY.x;\r\n        source.y += otherXY.y;\r\n        return source;\r\n    }\r\n    // @method subtract(otherPoint: Point): Point\r\n    // Returns the result of subtraction of the given point from the current.\r\n    /**\r\n   * 坐标相减\r\n   * @param {XY} otherXY - 另一坐标\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    subtract(otherXY, clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x -= otherXY.x;\r\n        source.y -= otherXY.y;\r\n        return source;\r\n    }\r\n    // @method divideBy(num: Number): Point\r\n    // Returns the result of division of the current point by the given number.\r\n    /**\r\n   * 坐标除以常数\r\n   * @param {number} num - 常数\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    divideBy(num, clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x /= num;\r\n        source.y /= num;\r\n        return source;\r\n    }\r\n    // @method multiplyBy(num: Number): Point\r\n    // Returns the result of multiplication of the current point by the given number.\r\n    /**\r\n   * 坐标乘以常数\r\n   * @param {number} num - 常数\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    multiplyBy(num, clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x *= num;\r\n        source.y *= num;\r\n        return source;\r\n    }\r\n    // @method scaleBy(scale: Point): Point\r\n    // Multiply each coordinate of the current point by each coordinate of\r\n    // `scale`. In linear algebra terms, multiply the point by the\r\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\r\n    // defined by `scale`.\r\n    /**\r\n   * 坐标相乘\r\n   * @param {XY} otherXY - 另一坐标\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    scaleBy(otherXY, clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x *= otherXY.x;\r\n        source.y *= otherXY.y;\r\n        return source;\r\n    }\r\n    // @method unscaleBy(scale: Point): Point\r\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\r\n    // each coordinate of `scale`.\r\n    /**\r\n   * 坐标相除\r\n   * @param {XY} otherXY - 另一坐标\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    unscaleBy(otherXY, clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x /= otherXY.x;\r\n        source.y /= otherXY.y;\r\n        return source;\r\n    }\r\n    // @method round(): Point\r\n    // Returns a copy of the current point with rounded coordinates.\r\n    /**\r\n   * 坐标取整（四舍五入）\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    round(clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x = Math.round(this.x);\r\n        source.y = Math.round(this.y);\r\n        return source;\r\n    }\r\n    // @method floor(): Point\r\n    // Returns a copy of the current point with floored coordinates (rounded down).\r\n    /**\r\n   * 坐标向下取整\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    floor(clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x = Math.floor(this.x);\r\n        source.y = Math.floor(this.y);\r\n        return source;\r\n    }\r\n    // @method ceil(): Point\r\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\r\n    /**\r\n   * 坐标向上取整\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    ceil(clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x = Math.ceil(this.x);\r\n        source.y = Math.ceil(this.y);\r\n        return source;\r\n    }\r\n    // @method trunc(): Point\r\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\r\n    /**\r\n   * 坐标直接取整（将数字的小数部分去掉）\r\n   * @param {boolean} clone - 是否返回新坐标\r\n   * @return {XY} 返回坐标\r\n   */\r\n    trunc(clone = true) {\r\n        let source = this;\r\n        // non-destructive, returns a new point\r\n        if (clone) {\r\n            source = this.clone();\r\n        }\r\n        source.x = Math.trunc(this.x);\r\n        source.y = Math.trunc(this.y);\r\n        return source;\r\n    }\r\n    // @method distanceTo(otherPoint: Point): Number\r\n    // Returns the cartesian distance between the current and the given points.\r\n    /**\r\n   * 计算与另一点间欧式距离\r\n   * @param {XY} point - 另一点坐标\r\n   * @return {number} 返回距离\r\n   */\r\n    distanceTo(point) {\r\n        let x = point.x - this.x, y = point.y - this.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n    // @method equals(otherPoint: Point): Boolean\r\n    // Returns `true` if the given point has the same coordinates.\r\n    /**\r\n   * 判断坐标是否相等\r\n   * @param {XY} obj - 坐标\r\n   * @return {boolean} 返回是否相等\r\n   */\r\n    equals(point) {\r\n        if (!point)\r\n            return false;\r\n        return point.x === this.x &&\r\n            point.y === this.y;\r\n    }\r\n    // @method contains(otherPoint: Point): Boolean\r\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n    /**\r\n   * 判断是否包含坐标\r\n   * @remark Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n   * @param {XY} obj - 坐标\r\n   * @return {boolean} 返回是否包含\r\n   */\r\n    contains(point) {\r\n        return Math.abs(point.x) <= Math.abs(this.x) &&\r\n            Math.abs(point.y) <= Math.abs(this.y);\r\n    }\r\n    // @method toString(): String\r\n    // Returns a string representation of the point for debugging purposes.\r\n    /**\r\n   * 输出字符串\r\n   * @param {number} precision - 保留精度\r\n   * @return {string} 返回字符串\r\n   */\r\n    toString(precision = 3) {\r\n        return 'XY(' +\r\n            formatNum(this.x, precision) + ', ' +\r\n            formatNum(this.y, precision) + ')';\r\n    }\r\n}\r\n","import { Earth } from './crs-earth';\r\nimport { SphericalMercator } from './projection/projection-spherical-mercator';\r\nimport { Transformation } from './transformation/transformation';\r\n/*\r\n * @namespace CRS\r\n * @crs L.CRS.EPSG3857\r\n *\r\n * The most common CRS for online maps, used by almost all free and commercial\r\n * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n * Map's `crs` option.\r\n */\r\nexport class EPSG3857 extends Earth {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = 'EPSG:3857';\r\n        this.projection = new SphericalMercator();\r\n        this.transformation = new Transformation((0.5 / (Math.PI * SphericalMercator.R)), 0.5, (-0.5 / (Math.PI * SphericalMercator.R)), 0.5);\r\n    }\r\n}\r\n","import { Earth } from './crs-earth';\r\nimport { LonLat } from './projection/projection-lonlat';\r\nimport { Transformation } from './transformation/transformation';\r\n/*\r\n * @namespace CRS\r\n * @crs L.CRS.EPSG4326\r\n *\r\n * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n *\r\n * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n */\r\nexport class EPSG4326 extends Earth {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.code = 'EPSG:4326';\r\n        this.projection = new LonLat();\r\n        this.transformation = new Transformation(1 / 180, 1, -1 / 180, 0.5);\r\n    }\r\n}\r\n","import { CRS } from './crs';\r\n/*\r\n * @namespace CRS\r\n * @crs L.CRS.Earth\r\n *\r\n * Serves as the base for CRS that are global such that they cover the earth.\r\n * Can only be used as the base for other CRS and cannot be used directly,\r\n * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\r\n * meters.\r\n */\r\nexport class Earth extends CRS {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.wrapLng = [-180, 180];\r\n    }\r\n    // distance between two geographical points using spherical law of cosines approximation\r\n    distance(latlng1, latlng2) {\r\n        var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n        return Earth.R * c;\r\n    }\r\n}\r\n// Mean Earth Radius, as recommended for use by\r\n// the International Union of Geodesy and Geophysics,\r\n// see http://rosettacode.org/wiki/Haversine_formula\r\nEarth.R = 6371000;\r\n","import { LatLng } from '../common/latlng';\r\nimport { LatLngBounds } from '../common/latlng-bounds';\r\nimport * as Util from '../util/util';\r\nimport { ScreenBounds } from '../common/screen-bounds';\r\n/*\r\n * @namespace CRS\r\n * @crs L.CRS.Base\r\n * Object that defines coordinate reference systems for projecting\r\n * geographical points into pixel (screen) coordinates and back (and to\r\n * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).\r\n *\r\n * Leaflet defines the most usual CRSs by default. If you want to use a\r\n * CRS not defined by default, take a look at the\r\n * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n *\r\n * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n * and can't be instantiated. Also, new classes can't inherit from them,\r\n * and methods can't be added to them with the `include` function.\r\n */\r\nexport class CRS {\r\n    constructor() {\r\n        // @property infinite: Boolean\r\n        // If true, the coordinate space will be unbounded (infinite in both axes)\r\n        this.infinite = false;\r\n    }\r\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\r\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\r\n    latLngToScreenXY(latlng, zoom) {\r\n        const planeXY = this.projection.project(latlng), scale = this.scale(zoom);\r\n        return this.transformation.transform(planeXY, scale);\r\n    }\r\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\r\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\r\n    // zoom into geographical coordinates.\r\n    screenXYToLatLng(screenXY, zoom) {\r\n        const scale = this.scale(zoom), planeXY = this.transformation.untransform(screenXY, scale);\r\n        return this.projection.unproject(planeXY);\r\n    }\r\n    planeXYToScreenXY(planeXY, zoom) {\r\n        const scale = this.scale(zoom);\r\n        return this.transformation.transform(planeXY, scale);\r\n    }\r\n    screenXYToPlaneXY(screenXY, zoom) {\r\n        const scale = this.scale(zoom);\r\n        return this.transformation.untransform(screenXY, scale);\r\n    }\r\n    // @method project(latlng: LatLng): Point\r\n    // Projects geographical coordinates into coordinates in units accepted for\r\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\r\n    project(latlng) {\r\n        return this.projection.project(latlng);\r\n    }\r\n    // @method unproject(point: Point): LatLng\r\n    // Given a projected coordinate returns the corresponding LatLng.\r\n    // The inverse of `project`.\r\n    unproject(planeXY) {\r\n        return this.projection.unproject(planeXY);\r\n    }\r\n    // @method scale(zoom: Number): Number\r\n    // Returns the scale used when transforming projected coordinates into\r\n    // pixel coordinates for a particular zoom. For example, it returns\r\n    // `256 * 2^zoom` for Mercator-based CRS.\r\n    scale(zoom) {\r\n        return 256 * Math.pow(2, zoom);\r\n    }\r\n    // @method zoom(scale: Number): Number\r\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\r\n    // factor of `scale`.\r\n    zoom(scale) {\r\n        return Math.log(scale / 256) / Math.LN2;\r\n    }\r\n    // @method getProjectedBounds(zoom: Number): Bounds\r\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\r\n    getScreenBounds(zoom) {\r\n        // if (this.infinite) { return null; }\r\n        var b = this.projection.bounds, s = this.scale(zoom), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);\r\n        return new ScreenBounds(min, max);\r\n    }\r\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n    // Returns the distance between two geographical coordinates.\r\n    // @method wrapLatLng(latlng: LatLng): LatLng\r\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\r\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\r\n    wrapLatLng(latlng) {\r\n        var lng = this.wrapLng ? Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;\r\n        return new LatLng(lat, lng, alt);\r\n    }\r\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\r\n    // that its center is within the CRS's bounds.\r\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\r\n    wrapLatLngBounds(bounds) {\r\n        var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;\r\n        if (latShift === 0 && lngShift === 0) {\r\n            return bounds;\r\n        }\r\n        var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\r\n        return new LatLngBounds(newSw, newNe);\r\n    }\r\n}\r\n;\r\n","import { Projection } from './projection';\r\nimport { PlaneBounds } from '../../common/plane-bounds';\r\nimport { PlaneXY } from '../../common/plane-xy';\r\nimport { LatLng } from '../../common/latlng';\r\n/*\r\n * @namespace Projection\r\n * @section\r\n * Leaflet comes with a set of already defined Projections out of the box:\r\n *\r\n * @projection L.Projection.LonLat\r\n *\r\n * Equirectangular, or Plate Carree projection — the most simple projection,\r\n * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n * `EPSG:4326` and `Simple` CRS.\r\n */\r\nexport class LonLat extends Projection {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.bounds = new PlaneBounds(new PlaneXY(-180, -90), new PlaneXY(180, 90));\r\n    }\r\n    project(latlng) {\r\n        return new PlaneXY(latlng.lng, latlng.lat);\r\n    }\r\n    unproject(xy) {\r\n        return new LatLng(xy.y, xy.x);\r\n    }\r\n}\r\n","import { LatLng } from '../../common/latlng';\r\nimport { PlaneBounds } from '../../common/plane-bounds';\r\nimport { PlaneXY } from '../../common/plane-xy';\r\nimport { Projection } from './projection';\r\n/*\r\n * @namespace Projection\r\n * @projection L.Projection.Mercator\r\n *\r\n * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n */\r\nexport class Mercator extends Projection {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.bounds = new PlaneBounds(new PlaneXY(-20037508.34279, -15496570.73972), new PlaneXY(20037508.34279, 18764656.23138));\r\n    }\r\n    project(latlng) {\r\n        var d = Math.PI / 180, r = Mercator.R, y = latlng.lat * d, tmp = Mercator.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);\r\n        var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\r\n        y = -r * Math.log(Math.max(ts, 1E-10));\r\n        return new PlaneXY(latlng.lng * d * r, y);\r\n    }\r\n    unproject(xy) {\r\n        var d = 180 / Math.PI, r = Mercator.R, tmp = Mercator.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-xy.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);\r\n        for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\r\n            con = e * Math.sin(phi);\r\n            con = Math.pow((1 - con) / (1 + con), e / 2);\r\n            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\r\n            phi += dphi;\r\n        }\r\n        return new LatLng(phi * d, xy.x * d / r);\r\n    }\r\n}\r\nMercator.R = 6378137;\r\nMercator.R_MINOR = 6356752.314245179;\r\n;\r\n","import { PlaneBounds } from '../../common/plane-bounds';\r\nimport { PlaneXY } from '../../common/plane-xy';\r\nimport { LatLng } from '../../common/latlng';\r\nimport { Projection } from './projection';\r\n/*\r\n * @namespace Projection\r\n * @projection L.Projection.SphericalMercator\r\n *\r\n * Spherical Mercator projection — the most common projection for online maps,\r\n * used by almost all free and commercial tile providers. Assumes that Earth is\r\n * a sphere. Used by the `EPSG:3857` CRS.\r\n */\r\nexport class SphericalMercator extends Projection {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.bounds = new PlaneBounds(new PlaneXY(-SphericalMercator.R * Math.PI, -SphericalMercator.R * Math.PI), new PlaneXY(SphericalMercator.R * Math.PI, SphericalMercator.R * Math.PI));\r\n    }\r\n    project(latlng) {\r\n        let d = Math.PI / 180, max = SphericalMercator.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);\r\n        return new PlaneXY(SphericalMercator.R * latlng.lng * d, SphericalMercator.R * Math.log((1 + sin) / (1 - sin)) / 2);\r\n    }\r\n    unproject(xy) {\r\n        var d = 180 / Math.PI;\r\n        return new LatLng((2 * Math.atan(Math.exp(xy.y / SphericalMercator.R)) - (Math.PI / 2)) * d, xy.x * d / SphericalMercator.R);\r\n    }\r\n}\r\nSphericalMercator.R = 6378137;\r\nSphericalMercator.MAX_LATITUDE = 85.0511287798;\r\n","export class Projection {\r\n}\r\n","import { PlaneXY } from '../../common/plane-xy';\r\nimport { ScreenXY } from '../../common/screen-xy';\r\n/*\r\n * @class Transformation\r\n * @aka L.Transformation\r\n *\r\n * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n * the reverse. Used by Leaflet in its projections code.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var transformation = L.transformation(2, 5, -1, 10),\r\n * \tp = L.point(1, 2),\r\n * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n * ```\r\n */\r\n// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\r\n// Creates a `Transformation` object with the given coefficients.\r\nexport class Transformation {\r\n    constructor(a, b, c, d) {\r\n        this._a = a;\r\n        this._b = b;\r\n        this._c = c;\r\n        this._d = d;\r\n    }\r\n    // @method transform(point: Point, scale?: Number): Point\r\n    // Returns a transformed point, optionally multiplied by the given scale.\r\n    // Only accepts actual `L.Point` instances, not arrays.\r\n    transform(planeXY, scale = 1) {\r\n        return new ScreenXY(scale * (this._a * planeXY.x + this._b), scale * (this._c * planeXY.y + this._d));\r\n    }\r\n    // @method untransform(point: Point, scale?: Number): Point\r\n    // Returns the reverse transformation of the given point, optionally divided\r\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\r\n    untransform(screenXY, scale = 1) {\r\n        return new PlaneXY((screenXY.x / scale - this._b) / this._a, (screenXY.y / scale - this._d) / this._c);\r\n    }\r\n}\r\n","/**\r\n * 要素类（要素集合）\r\n * @remarks\r\n * TODO: a lot of things to be done\r\n * 可设置CRS代表数据源坐标系，FeatureLayer对应Map显示坐标系，可内置数据转换\r\n */\r\nexport class FeatureClass {\r\n    /**\r\n     * 构造函数\r\n     * @param {GeometryType} type - 空间数据类型：点/线/面\r\n     */\r\n    constructor(type) {\r\n        /**\r\n         * 属性字段集合\r\n         */\r\n        this._fields = [];\r\n        /**\r\n         * 矢量要素集合\r\n         */\r\n        this._features = {}; //Map<string, Graphic>\r\n        this._type = type;\r\n    }\r\n    /**\r\n     * 遍历集合的初始要素\r\n     */\r\n    get first() {\r\n        return this._first;\r\n    }\r\n    /**\r\n     * 遍历集合的结尾要素\r\n     */\r\n    get last() {\r\n        return this._last;\r\n    }\r\n    /**\r\n     * 空间数据类型：点/线/面\r\n     */\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    /**\r\n     * 要素集合\r\n     */\r\n    get features() {\r\n        return Object.values(this._features);\r\n    }\r\n    /**\r\n     * 属性字段集合\r\n     */\r\n    get fields() {\r\n        return this._fields;\r\n    }\r\n    /**\r\n     * 根据ID获取矢量要素\r\n     * @param {string} id - 空间矢量要素ID\r\n     */\r\n    getFeature(id) {\r\n        return this._features[id];\r\n    }\r\n    /**\r\n     * 添加要素\r\n     * @param {Feature} feature - 空间矢量要素\r\n     */\r\n    addFeature(feature, last = true) {\r\n        this._features[feature.id] = feature;\r\n        if (!this._first) {\r\n            this._first = feature;\r\n            this._last = feature;\r\n        }\r\n        else {\r\n            if (!last) {\r\n                this._first.prev = feature;\r\n                feature.next = this._first;\r\n                this._first = feature;\r\n            }\r\n            else {\r\n                this._last.next = feature;\r\n                feature.prev = this._last;\r\n                this._last = feature;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 删除要素\r\n     * @param {Feature} feature - 空间矢量要素\r\n     */\r\n    removeFeature(feature) {\r\n        if (this._first == feature) {\r\n            this._first = feature.next;\r\n        }\r\n        if (this._last == feature) {\r\n            this._last = feature.prev;\r\n        }\r\n        if (feature.prev) {\r\n            feature.prev.next = feature.next;\r\n        }\r\n        if (feature.next) {\r\n            feature.next.prev = feature.prev;\r\n        }\r\n        feature.prev = null;\r\n        feature.next = null;\r\n        delete this._features[feature.id];\r\n    }\r\n    /**\r\n     * 清空要素集合\r\n     */\r\n    clearFeatures() {\r\n        this._features = {};\r\n    }\r\n    /**\r\n     * 添加字段\r\n     * @param {Field} field - 字段\r\n     */\r\n    addField(field) {\r\n        this._fields.push(field);\r\n    }\r\n    /**\r\n     * 删除字段\r\n     * @param {Field} field - 字段\r\n     */\r\n    removeField(field) {\r\n        const index = this._fields.findIndex(item => item === field);\r\n        index != -1 && this._fields.splice(index, 1);\r\n    }\r\n    /**\r\n     * 清空字段集合\r\n     */\r\n    clearFields() {\r\n        this._fields = [];\r\n    }\r\n    /**\r\n     * 加载矢量数据\r\n     * @param {Adapter} adapter - 数据适配器\r\n     */\r\n    async load(adapter) {\r\n        if (this._type == adapter.type) {\r\n            const features = await adapter.fetch();\r\n            features.forEach(feature => {\r\n                this.addFeature(feature);\r\n            });\r\n        }\r\n    }\r\n}\r\n","import { EventedObject } from \"../base/evented-object\";\r\nimport { Text } from \"../text/text\";\r\nexport class Feature extends EventedObject {\r\n    /**\r\n      * 构造函数\r\n      * @param {Geometry} geometry - 空间图形\r\n      * @param {Object} properties - 属性信息\r\n      */\r\n    constructor(geometry, properties) {\r\n        super();\r\n        /**\r\n         * 属性信息\r\n         */\r\n        this._properties = {};\r\n        /**\r\n         * 是否可见\r\n         */\r\n        this.visible = true;\r\n        /**\r\n         * 前一要素\r\n         * @remarks\r\n         * 用于FeatureClass要素链表\r\n         */\r\n        this.prev = null;\r\n        /**\r\n         * 后一要素\r\n         * @remarks\r\n         * 用于FeatureClass要素链表\r\n         */\r\n        this.next = null;\r\n        this._geometry = geometry;\r\n        this._properties = properties;\r\n    }\r\n    /**\r\n     * 空间图形\r\n     */\r\n    get geometry() {\r\n        return this._geometry;\r\n    }\r\n    /**\r\n     * 属性信息\r\n     */\r\n    get properties() {\r\n        return this._properties;\r\n    }\r\n    /**\r\n      * 绘制点\r\n      * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n      * @param {Symbol} symbol - 渲染符号\r\n      */\r\n    draw(ctx, symbol) {\r\n        this._geometry.draw(ctx, symbol);\r\n    }\r\n    /**\r\n      * 标注要素\r\n      * @remarks 调用空间坐标信息进行标注绘制\r\n      * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n      * @param {Field} field - 标注字段\r\n      * @param {Text} text - 标注符号\r\n      */\r\n    label(ctx, field, text = new Text()) {\r\n        if (this.visible)\r\n            this._geometry.label(ctx, this._properties[field.name], this.text || text);\r\n    }\r\n}\r\n","/**\r\n * 字段类型\r\n */\r\nexport var FieldType;\r\n(function (FieldType) {\r\n    /**\r\n     * 字符串\r\n     */\r\n    FieldType[FieldType[\"String\"] = 1] = \"String\";\r\n    /**\r\n     * 数值型\r\n     */\r\n    FieldType[FieldType[\"Number\"] = 2] = \"Number\";\r\n})(FieldType || (FieldType = {}));\r\n/**\r\n * 字段\r\n * @remarks\r\n * TODO: a lot of things to be done\r\n */\r\nexport class Field {\r\n    /**\r\n     * 构造函数\r\n     * @param {string} name - 字段名称\r\n     * @param {FieldType} type - 字段类型\r\n     */\r\n    constructor(name, type) {\r\n        this.name = name;\r\n        this.type = type;\r\n    }\r\n}\r\n","import { Text } from '../text/text';\r\n/**\r\n * 坐标类型\r\n * @enum {number}\r\n */\r\nexport var CoordinateType;\r\n(function (CoordinateType) {\r\n    //经纬度坐标\r\n    CoordinateType[CoordinateType[\"Latlng\"] = 1] = \"Latlng\";\r\n    //地理平面坐标\r\n    CoordinateType[CoordinateType[\"Plane\"] = 2] = \"Plane\";\r\n    //屏幕平面坐标\r\n    CoordinateType[CoordinateType[\"Screen\"] = 3] = \"Screen\";\r\n})(CoordinateType || (CoordinateType = {}));\r\n/**\r\n * 图形类型\r\n * @enum {number}\r\n */\r\nexport var GeometryType;\r\n(function (GeometryType) {\r\n    //点\r\n    GeometryType[GeometryType[\"Point\"] = 1] = \"Point\";\r\n    //线\r\n    GeometryType[GeometryType[\"Polyline\"] = 2] = \"Polyline\";\r\n    //面\r\n    GeometryType[GeometryType[\"Polygon\"] = 3] = \"Polygon\";\r\n    // MultiplePoint = 4,\r\n    // MultiplePolyline = 5,\r\n    // MultiplePolygon = 6\r\n})(GeometryType || (GeometryType = {}));\r\n/**\r\n * 图形基类\r\n */\r\nexport class Geometry {\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    /**\r\n     * 包络矩形\r\n     * @remarks\r\n     * 注意bound的坐标类型：一般为地理平面坐标，即投影后坐标\r\n     */\r\n    get latlngBounds() {\r\n        return this._latlngBounds;\r\n    }\r\n    get planeBounds() {\r\n        return this._planeBounds;\r\n    }\r\n    get screenBounds() {\r\n        return this._screenBounds;\r\n    }\r\n    set crs(value) {\r\n        this._crs = value;\r\n        this.project();\r\n    }\r\n    /**\r\n     * 图形包络矩形与可见视图范围是否包含或相交\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @return {boolean} 是否在可视范围内\r\n     */\r\n    // intersect(projection: Projection = new WebMercator(), extent: Bound = projection.bound): boolean {\r\n    //     if (!this._projected) this.project(projection);\r\n    //     return extent.intersect(this._bound);\r\n    // }\r\n    /**\r\n     * 获取图形中心点虚函数\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 中心点坐标\r\n     */\r\n    getCenter(type = CoordinateType.Latlng) {\r\n        if (type === CoordinateType.Plane) {\r\n            return this._planeBounds.getCenter();\r\n        }\r\n        else if (type === CoordinateType.Screen) {\r\n            return this._screenBounds.getCenter();\r\n        }\r\n        else {\r\n            return this._latlngBounds.getCenter();\r\n        }\r\n    }\r\n    // getCenter(type: CoordinateType = CoordinateType.Latlng, projection: Projection = new WebMercator()) {};\r\n    /**\r\n     * 获取图形包络矩形\r\n     * 针对新建图形，还未进行投影的情况\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number[]} 包络矩形\r\n     */\r\n    // getBound(projection: Projection = new WebMercator()) {\r\n    //     if (!this._projected) this.project(projection);\r\n    //     return this._bound;\r\n    // };\r\n    /**\r\n     * 获取两个图形间距离\r\n     * @remarks\r\n     * 当前为两图形中心点间的直线距离\r\n     * 多用于聚合判断\r\n     * @param {Geometry} geometry - 另一图形\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number} 距离\r\n     */\r\n    distance(geometry, type = CoordinateType.Screen) {\r\n        if (type == CoordinateType.Screen || type == CoordinateType.Plane) {\r\n            const center = this.getCenter(type);\r\n            const center2 = geometry.getCenter(type);\r\n            return Math.sqrt((center2.x - center.x) * (center2.x - center.x) + (center2.y - center.y) * (center2.y - center.y));\r\n        }\r\n        else {\r\n            // const center: L = this.getCenter(type) as XY;\r\n            // const center2: XY = geometry.getCenter(type) as XY;\r\n            // return Math.sqrt((center2.x-center.x) * (center2.x-center.x) + (center2.y-center.y) * (center2.y-center.y));\r\n        }\r\n    }\r\n    /**\r\n       * 标注绘制\r\n       * @remarks\r\n       * 标注文本支持多行，/r/n换行\r\n       * @param {string} text - 标注文本\r\n       * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n       * @param {Projection} projection - 坐标投影转换\r\n       * @param {SimpleTextSymbol} symbol - 标注符号\r\n       */\r\n    label(ctx, value, symbol = new Text()) {\r\n        if (value == null || value == undefined || value === \"\")\r\n            return;\r\n        // ctx.save();\r\n        ctx.strokeStyle = symbol.strokeStyle;\r\n        ctx.fillStyle = symbol.fillStyle;\r\n        ctx.lineWidth = symbol.lineWidth;\r\n        ctx.lineJoin = \"round\";\r\n        ctx.font = symbol.fontSize + \"px/1 \" + symbol.fontFamily + \" \" + symbol.fontWeight;\r\n        const center = this.getCenter(CoordinateType.Screen);\r\n        const array = value.toString().split(\"/r/n\");\r\n        let widths = array.map(str => ctx.measureText(str).width + symbol.padding * 2);\r\n        let width = Math.max(...widths);\r\n        let height = symbol.fontSize * array.length + symbol.padding * 2 + symbol.padding * (array.length - 1);\r\n        const screenX = center.x;\r\n        const screenY = center.y;\r\n        let totalX, totalY;\r\n        switch (symbol.placement) {\r\n            case \"TOP\":\r\n                totalX = -width / 2;\r\n                totalY = -symbol.pointSymbolHeight / 2 - height;\r\n                break;\r\n            case \"BOTTOM\":\r\n                totalX = -width / 2;\r\n                totalY = symbol.pointSymbolHeight / 2;\r\n                break;\r\n            case \"RIGHT\":\r\n                totalX = symbol.pointSymbolWidth / 2;\r\n                totalY = -height / 2;\r\n                break;\r\n            case \"LEFT\":\r\n                totalX = -symbol.pointSymbolWidth / 2 - width;\r\n                totalY = -height / 2;\r\n                break;\r\n        }\r\n        ctx.strokeRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.fillRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.textBaseline = \"top\";\r\n        ctx.fillStyle = symbol.fontColor;\r\n        array.forEach((str, index) => {\r\n            ctx.fillText(str, screenX + totalX + symbol.padding + (width - widths[index]) / 2, screenY + totalY + symbol.padding + index * (symbol.fontSize + symbol.padding));\r\n        });\r\n        // ctx.restore();\r\n    }\r\n}\r\n","import { CoordinateType, Geometry, GeometryType } from './geometry';\r\nimport { SimplePointSymbol } from '../symbol/symbol';\r\nimport { ScreenBounds } from '../common/screen-bounds';\r\nimport { LatLngBounds } from '../common/latlng-bounds';\r\nimport { PlaneBounds } from '../common/plane-bounds';\r\n/*\r\n * @class Point\r\n * @aka L.Point\r\n *\r\n * Represents a point with `x` and `y` coordinates in pixels.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var point = L.point(200, 300);\r\n * ```\r\n *\r\n * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n *\r\n * ```js\r\n * map.panBy([200, 300]);\r\n * map.panBy(L.point(200, 300));\r\n * ```\r\n *\r\n * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n * which means new classes can't inherit from it, and new methods\r\n * can't be added to it with the `include` function.\r\n */\r\nexport class MultiplePoint extends Geometry {\r\n    // _order: any;\r\n    constructor(latlngs) {\r\n        super();\r\n        this._type = GeometryType.Point;\r\n        this._setLatLngs(latlngs);\r\n    }\r\n    // @method getLatLngs(): LatLng[]\r\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\r\n    getLatLngs() {\r\n        return this._latlngs;\r\n    }\r\n    _setLatLngs(latlngs) {\r\n        this._latlngBounds = new LatLngBounds();\r\n        this._latlngs = [];\r\n        for (let i = 0, len = latlngs.length; i < len; i++) {\r\n            this._latlngBounds.extend(latlngs[i]);\r\n            this._latlngs.push(latlngs[i]);\r\n        }\r\n    }\r\n    // @method setLatLngs(latlngs: LatLng[]): this\r\n    // Replaces all the points in the polyline with the given array of geographical points.\r\n    setLatLngs(latlngs) {\r\n        this._setLatLngs(latlngs);\r\n        // return this.redraw();\r\n    }\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        this._planeBounds = new PlaneBounds();\r\n        this._planeXYs = [];\r\n        for (let i = 0, len = this._latlngs.length; i < len; i++) {\r\n            const planeXY = this._crs.projection.project(this._latlngs[i]);\r\n            this._planeBounds.extend(planeXY);\r\n            this._planeXYs.push(planeXY);\r\n        }\r\n    }\r\n    transform(origin, zoom, symbol) {\r\n        if (!this._crs && !this._planeXYs)\r\n            return;\r\n        this._screenXYs = this._planeXYs.map(planeXY => {\r\n            return this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n        });\r\n        this._screenBounds = new ScreenBounds();\r\n        this._screenBoundsArray = [];\r\n        this._screenXYs.forEach(screenXY => {\r\n            this._screenBounds.extend(symbol.getScreenBounds(screenXY));\r\n            this._screenBoundsArray.push(symbol.getScreenBounds(screenXY));\r\n        });\r\n    }\r\n    getCenter(type = CoordinateType.Latlng) {\r\n        if (type === CoordinateType.Plane) {\r\n            return this._planeXYs[0];\r\n        }\r\n        else if (type === CoordinateType.Screen) {\r\n            return this._screenXYs[0];\r\n        }\r\n        else {\r\n            return this._latlngs[0];\r\n        }\r\n    }\r\n    toGeoJSON(precision = 6) {\r\n        const coords = [];\r\n        for (let i = 0, len = this._latlngs.length; i < len; i++) {\r\n            coords.push(this._latlngs[i].toGeoJSON(precision));\r\n        }\r\n        return {\r\n            type: \"MultiPoint\",\r\n            coordinates: coords\r\n        };\r\n    }\r\n    /**\r\n     * 绘制点\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, symbol) {\r\n        if (!this._crs)\r\n            return;\r\n        // this._screenXY = this._crs.planeXYToScreenXY(this._planeXY, zoom).round(false).subtract(origin);\r\n        symbol = symbol || new SimplePointSymbol();\r\n        // this._screenBounds = symbol.getScreenBounds(this._screenXY);\r\n        this._screenXYs.forEach(screenXY => {\r\n            symbol.draw(ctx, screenXY);\r\n        });\r\n    }\r\n    contains(screenXY) {\r\n        return Array.isArray(this._screenBoundsArray) && this._screenBoundsArray.some(screenBounds => {\r\n            this._screenBounds.contains(screenXY);\r\n        });\r\n    }\r\n}\r\n","import { LatLngBounds } from \"../common/latlng-bounds\";\r\nimport { PlaneBounds } from \"../common/plane-bounds\";\r\nimport { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { SimpleFillSymbol } from \"../symbol/symbol\";\r\nimport { Geometry, GeometryType } from \"./geometry\";\r\n/**\r\n * 面\r\n * @remarks\r\n * 数据结构：[ring[point[x,y]]]：such as [[[1,1],[2,2],[1,2]], [[1.5,1.5],[1.9,1.9],[1.5,1.9]]]\r\n */\r\nexport class MultiplePolygon extends Geometry {\r\n    constructor(latlngs) {\r\n        super();\r\n        this._type = GeometryType.Polygon;\r\n        this._setLatLngs(latlngs);\r\n    }\r\n    getLatLngs() {\r\n        return this._latlngs;\r\n    }\r\n    _setLatLngs(latlngs) {\r\n        this._latlngBounds = new LatLngBounds();\r\n        this._latlngs = [];\r\n        latlngs.forEach(polygon => {\r\n            const latLngPolygon = [];\r\n            polygon.forEach(ring => {\r\n                const latLngRing = [];\r\n                ring.forEach(latlng => {\r\n                    this._latlngBounds.extend(latlng);\r\n                    latLngRing.push(latlng);\r\n                });\r\n                latLngPolygon.push(latLngRing);\r\n            });\r\n            this._latlngs.push(latLngPolygon);\r\n        });\r\n    }\r\n    // @method setLatLngs(latlngs: LatLng[]): this\r\n    // Replaces all the points in the polyline with the given array of geographical points.\r\n    setLatLngs(latlngs) {\r\n        this._setLatLngs(latlngs);\r\n        // return this.redraw();\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        this._planeBounds = new PlaneBounds();\r\n        this._planeXYs = [];\r\n        this._latlngs.forEach(polygon => {\r\n            const planePolygon = [];\r\n            polygon.forEach(ring => {\r\n                const planeRing = [];\r\n                ring.forEach(latlng => {\r\n                    const planeXY = this._crs.projection.project(latlng);\r\n                    this._planeBounds.extend(planeXY);\r\n                    planeRing.push(planeXY);\r\n                });\r\n                planePolygon.push(planeRing);\r\n            });\r\n            this._planeXYs.push(planePolygon);\r\n        });\r\n    }\r\n    transform(origin, zoom, symbol) {\r\n        if (!this._crs && !this._planeXYs)\r\n            return;\r\n        this._screenXYs = this._planeXYs.map(polygon => {\r\n            return polygon.map(ring => {\r\n                return ring.map(planeXY => {\r\n                    return this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n                });\r\n            });\r\n        });\r\n        this._screenBounds = new ScreenBounds();\r\n        this._screenXYs.forEach(polygon => {\r\n            this._screenBounds.extend(symbol.getScreenBounds(polygon));\r\n        });\r\n    }\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON(precision = 6) {\r\n        const coords = [];\r\n        this._latlngs.forEach(polygon => {\r\n            const outPolygon = [];\r\n            polygon.forEach(ring => {\r\n                const outRing = [];\r\n                ring.forEach(latlng => {\r\n                    this._latlngBounds.extend(latlng);\r\n                    outRing.push(latlng.toGeoJSON(precision));\r\n                });\r\n                outPolygon.push(outRing);\r\n            });\r\n            coords.push(outPolygon);\r\n        });\r\n        return {\r\n            type: \"MultiPolygon\",\r\n            coordinates: coords\r\n        };\r\n    }\r\n    /**\r\n     * 绘制面\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, symbol) {\r\n        if (!this._crs)\r\n            return;\r\n        // this._screenXYs = this._planeXYs.map(planeXY => {\r\n        // \treturn this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n        // })\r\n        symbol = symbol || new SimpleFillSymbol();\r\n        // this._screenBounds = symbol.getScreenBounds(this._screenXYs);\r\n        this._screenXYs.forEach(polygon => {\r\n            symbol.draw(ctx, polygon);\r\n        });\r\n    }\r\n    contains(screenXY) {\r\n        let inside = false, ring, p1, p2, i, j, k, len, len2;\r\n        if (!this._screenBounds || !this._screenBounds.contains(screenXY)) {\r\n            return false;\r\n        }\r\n        // ray casting algorithm for detecting if point is in polygon\r\n        return this._screenXYs.some(polygon => {\r\n            for (i = 0, len = polygon.length; i < len; i++) {\r\n                ring = polygon[i];\r\n                for (j = 0, len2 = ring.length, k = len2 - 1; j < len2; k = j++) {\r\n                    p1 = ring[j];\r\n                    p2 = ring[k];\r\n                    if (((p1.y > screenXY.y) !== (p2.y > screenXY.y)) && (screenXY.x < (p2.x - p1.x) * (screenXY.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n                        inside = !inside;\r\n                    }\r\n                }\r\n            }\r\n            return inside;\r\n        });\r\n    }\r\n}\r\n","import { LatLngBounds } from '../common/latlng-bounds';\r\nimport { PlaneBounds } from '../common/plane-bounds';\r\nimport { Geometry, GeometryType } from './geometry';\r\nimport { SimpleLineSymbol } from '../symbol/symbol';\r\nimport * as LineUtil from '../util/line-util';\r\nimport { ScreenBounds } from '../common/screen-bounds';\r\n/*\r\n * @class Polyline\r\n * @aka L.Polyline\r\n * @inherits Path\r\n *\r\n * A class for drawing polyline overlays on a map. Extends `Path`.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * // create a red polyline from an array of LatLng points\r\n * var latlngs = [\r\n * \t[45.51, -122.68],\r\n * \t[37.77, -122.43],\r\n * \t[34.04, -118.2]\r\n * ];\r\n *\r\n * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\r\n *\r\n * // zoom the map to the polyline\r\n * map.fitBounds(polyline.getBounds());\r\n * ```\r\n *\r\n * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\r\n *\r\n * ```js\r\n * // create a red polyline from an array of arrays of LatLng points\r\n * var latlngs = [\r\n * \t[[45.51, -122.68],\r\n * \t [37.77, -122.43],\r\n * \t [34.04, -118.2]],\r\n * \t[[40.78, -73.91],\r\n * \t [41.83, -87.62],\r\n * \t [32.76, -96.72]]\r\n * ];\r\n * ```\r\n */\r\nexport class MultiplePolyline extends Geometry {\r\n    constructor(latlngs) {\r\n        super();\r\n        this._type = GeometryType.Polyline;\r\n        this._setLatLngs(latlngs);\r\n    }\r\n    // @method getLatLngs(): LatLng[]\r\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\r\n    getLatLngs() {\r\n        return this._latlngs;\r\n    }\r\n    _setLatLngs(latlngs) {\r\n        this._latlngBounds = new LatLngBounds();\r\n        this._latlngs = [];\r\n        latlngs.forEach(polyline => {\r\n            const latLngPolyline = [];\r\n            polyline.forEach(latlng => {\r\n                this._latlngBounds.extend(latlng);\r\n                latLngPolyline.push(latlng);\r\n            });\r\n            this._latlngs.push(latLngPolyline);\r\n        });\r\n    }\r\n    // @method setLatLngs(latlngs: LatLng[]): this\r\n    // Replaces all the points in the polyline with the given array of geographical points.\r\n    setLatLngs(latlngs) {\r\n        this._setLatLngs(latlngs);\r\n        // return this.redraw();\r\n    }\r\n    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\r\n    // Adds a given point to the polyline. By default, adds to the first ring of\r\n    // the polyline in case of a multi-polyline, but can be overridden by passing\r\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\r\n    // addLatLng(latlng: LatLng, latlngs?: LatLng[]) {\r\n    // \tlatlngs = latlngs || this._defaultShape();\r\n    // addLatLng(latlng: LatLng) {\r\n    // \t// const latlngs = this._defaultShape();\r\n    // \tthis._latlngs.push(latlng);\r\n    // \tthis._latlngBounds.extend(latlng);\r\n    // \t// return this.redraw();\r\n    // }\r\n    // @method getCenter(): LatLng\r\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.\r\n    // getCenter() {\r\n    // \treturn this._latlngBounds.getCenter();\r\n    // }\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        this._planeBounds = new PlaneBounds();\r\n        this._planeXYs = [];\r\n        this._latlngs.forEach(polyline => {\r\n            const planePolyline = [];\r\n            polyline.forEach(latlng => {\r\n                const planeXY = this._crs.projection.project(latlng);\r\n                this._planeBounds.extend(planeXY);\r\n                planePolyline.push(planeXY);\r\n            });\r\n            this._planeXYs.push(planePolyline);\r\n        });\r\n    }\r\n    transform(origin, zoom, symbol) {\r\n        if (!this._crs && !this._planeXYs)\r\n            return;\r\n        this._screenXYs = this._planeXYs.map(polyline => {\r\n            return polyline.map(planeXY => {\r\n                return this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n            });\r\n        });\r\n        this._screenBounds = new ScreenBounds();\r\n        this._screenXYs.forEach(polyline => {\r\n            this._screenBounds.extend(symbol.getScreenBounds(polyline));\r\n        });\r\n    }\r\n    draw(ctx, symbol) {\r\n        if (!this._crs)\r\n            return;\r\n        // this._screenXYs = this._planeXYs.map(planeXY => {\r\n        // \treturn this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n        // })\r\n        symbol = symbol || new SimpleLineSymbol();\r\n        // this._screenBounds = symbol.getScreenBounds(this._screenXYs);\r\n        this._screenXYs.forEach(polyline => {\r\n            symbol.draw(ctx, polyline);\r\n        });\r\n    }\r\n    toGeoJSON(precision = 6) {\r\n        const coords = [];\r\n        this._latlngs.forEach(polyline => {\r\n            const outPolyline = [];\r\n            polyline.forEach(latlng => {\r\n                this._latlngBounds.extend(latlng);\r\n                outPolyline.push(latlng.toGeoJSON(precision));\r\n            });\r\n            coords.push(outPolyline);\r\n        });\r\n        return {\r\n            type: \"MultiLineString\",\r\n            coordinates: coords\r\n        };\r\n    }\r\n    contains(screenXY) {\r\n        let i, len, w = 5;\r\n        if (!this._screenBounds || !this._screenBounds.contains(screenXY)) {\r\n            return false;\r\n        }\r\n        // hit detection for polylines\r\n        return this._screenXYs.some(polyline => {\r\n            for (i = 0, len = polyline.length; i < len - 1; i++) {\r\n                if (LineUtil.pointToSegmentDistance(screenXY, polyline[i], polyline[i + 1]) <= w) {\r\n                    return true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","import { CoordinateType, Geometry, GeometryType } from './geometry';\r\nimport { SimplePointSymbol } from '../symbol/symbol';\r\nimport { ScreenBounds } from '../common/screen-bounds';\r\n/*\r\n * @class Point\r\n * @aka L.Point\r\n *\r\n * Represents a point with `x` and `y` coordinates in pixels.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var point = L.point(200, 300);\r\n * ```\r\n *\r\n * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n *\r\n * ```js\r\n * map.panBy([200, 300]);\r\n * map.panBy(L.point(200, 300));\r\n * ```\r\n *\r\n * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n * which means new classes can't inherit from it, and new methods\r\n * can't be added to it with the `include` function.\r\n */\r\nexport class Point extends Geometry {\r\n    // _order: any;\r\n    constructor(latlng) {\r\n        super();\r\n        this._type = GeometryType.Point;\r\n        this._latlng = latlng;\r\n    }\r\n    get latlng() {\r\n        return this._latlng;\r\n    }\r\n    get screenXY() {\r\n        return this._screenXY;\r\n    }\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        this._planeXY = this._crs.projection.project(this._latlng);\r\n        this._planeBounds = new ScreenBounds();\r\n        this._planeBounds.extend(this._planeXY);\r\n    }\r\n    transform(origin, zoom, symbol) {\r\n        if (!this._crs && !this._planeXY)\r\n            return;\r\n        this._screenXY = this._crs.planeXYToScreenXY(this._planeXY, zoom).round(false).subtract(origin);\r\n        symbol = symbol || new SimplePointSymbol();\r\n        this._screenBounds = symbol.getScreenBounds(this._screenXY);\r\n    }\r\n    getCenter(type = CoordinateType.Latlng) {\r\n        if (type === CoordinateType.Plane) {\r\n            return this._planeXY;\r\n        }\r\n        else if (type === CoordinateType.Screen) {\r\n            return this._screenXY;\r\n        }\r\n        else {\r\n            return this._latlng;\r\n        }\r\n    }\r\n    toGeoJSON(precision = 6) {\r\n        return {\r\n            type: \"Point\",\r\n            coordinates: this._latlng.toGeoJSON(precision)\r\n        };\r\n    }\r\n    /**\r\n     * 绘制点\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, symbol) {\r\n        if (!this._crs)\r\n            return;\r\n        // this._screenXY = this._crs.planeXYToScreenXY(this._planeXY, zoom).round(false).subtract(origin);\r\n        symbol = symbol || new SimplePointSymbol();\r\n        // this._screenBounds = symbol.getScreenBounds(this._screenXY);\r\n        symbol.draw(ctx, this._screenXY);\r\n    }\r\n    contains(screenXY) {\r\n        return this._screenBounds && this._screenBounds.contains(screenXY);\r\n    }\r\n}\r\n","import { LatLngBounds } from \"../common/latlng-bounds\";\r\nimport { PlaneBounds } from \"../common/plane-bounds\";\r\nimport { SimpleFillSymbol } from \"../symbol/symbol\";\r\nimport { Geometry, GeometryType } from \"./geometry\";\r\n/**\r\n * 面\r\n * @remarks\r\n * 数据结构：[ring[point[x,y]]]：such as [[[1,1],[2,2],[1,2]], [[1.5,1.5],[1.9,1.9],[1.5,1.9]]]\r\n */\r\nexport class Polygon extends Geometry {\r\n    constructor(latlngs) {\r\n        super();\r\n        this._type = GeometryType.Polygon;\r\n        this._setLatLngs(latlngs);\r\n    }\r\n    getLatLngs() {\r\n        return this._latlngs;\r\n    }\r\n    _setLatLngs(latlngs) {\r\n        this._latlngBounds = new LatLngBounds();\r\n        this._latlngs = [];\r\n        latlngs.forEach(ring => {\r\n            const latLngRing = [];\r\n            ring.forEach(latlng => {\r\n                this._latlngBounds.extend(latlng);\r\n                latLngRing.push(latlng);\r\n            });\r\n            this._latlngs.push(latLngRing);\r\n        });\r\n    }\r\n    // @method setLatLngs(latlngs: LatLng[]): this\r\n    // Replaces all the points in the polyline with the given array of geographical points.\r\n    setLatLngs(latlngs) {\r\n        this._setLatLngs(latlngs);\r\n        // return this.redraw();\r\n    }\r\n    /**\r\n     * 投影变换\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        this._planeBounds = new PlaneBounds();\r\n        this._planeXYs = [];\r\n        this._latlngs.forEach(ring => {\r\n            const planeRing = [];\r\n            ring.forEach(latlng => {\r\n                const planeXY = this._crs.projection.project(latlng);\r\n                this._planeBounds.extend(planeXY);\r\n                planeRing.push(planeXY);\r\n            });\r\n            this._planeXYs.push(planeRing);\r\n        });\r\n    }\r\n    transform(origin, zoom, symbol) {\r\n        if (!this._crs && !this._planeXYs)\r\n            return;\r\n        this._screenXYs = this._planeXYs.map(ring => {\r\n            return ring.map(planeXY => {\r\n                return this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n            });\r\n        });\r\n        this._screenBounds = symbol.getScreenBounds(this._screenXYs);\r\n    }\r\n    /**\r\n     * 输出GeoJSON格式字符串\r\n     */\r\n    toGeoJSON(precision = 6) {\r\n        const coords = [];\r\n        this._latlngs.forEach(ring => {\r\n            const outRing = [];\r\n            ring.forEach(latlng => {\r\n                this._latlngBounds.extend(latlng);\r\n                outRing.push(latlng.toGeoJSON(precision));\r\n            });\r\n            coords.push(outRing);\r\n        });\r\n        return {\r\n            type: \"Polygon\",\r\n            coordinates: coords\r\n        };\r\n    }\r\n    /**\r\n     * 绘制面\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {Symbol} symbol - 渲染符号\r\n     */\r\n    draw(ctx, symbol) {\r\n        if (!this._crs)\r\n            return;\r\n        // this._screenXYs = this._planeXYs.map(planeXY => {\r\n        // \treturn this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n        // })\r\n        symbol = symbol || new SimpleFillSymbol();\r\n        // this._screenBounds = symbol.getScreenBounds(this._screenXYs);\r\n        symbol.draw(ctx, this._screenXYs);\r\n    }\r\n    contains(screenXY) {\r\n        let inside = false, ring, p1, p2, i, j, k, len, len2;\r\n        if (!this._screenBounds || !this._screenBounds.contains(screenXY)) {\r\n            return false;\r\n        }\r\n        // ray casting algorithm for detecting if point is in polygon\r\n        for (i = 0, len = this._screenXYs.length; i < len; i++) {\r\n            ring = this._screenXYs[i];\r\n            for (j = 0, len2 = ring.length, k = len2 - 1; j < len2; k = j++) {\r\n                p1 = ring[j];\r\n                p2 = ring[k];\r\n                if (((p1.y > screenXY.y) !== (p2.y > screenXY.y)) && (screenXY.x < (p2.x - p1.x) * (screenXY.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n                    inside = !inside;\r\n                }\r\n            }\r\n        }\r\n        return inside;\r\n    }\r\n}\r\n","import { LatLngBounds } from '../common/latlng-bounds';\r\nimport { PlaneBounds } from '../common/plane-bounds';\r\nimport { Geometry, GeometryType } from './geometry';\r\nimport { SimpleLineSymbol } from '../symbol/symbol';\r\nimport * as LineUtil from '../util/line-util';\r\n/*\r\n * @class Polyline\r\n * @aka L.Polyline\r\n * @inherits Path\r\n *\r\n * A class for drawing polyline overlays on a map. Extends `Path`.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * // create a red polyline from an array of LatLng points\r\n * var latlngs = [\r\n * \t[45.51, -122.68],\r\n * \t[37.77, -122.43],\r\n * \t[34.04, -118.2]\r\n * ];\r\n *\r\n * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\r\n *\r\n * // zoom the map to the polyline\r\n * map.fitBounds(polyline.getBounds());\r\n * ```\r\n *\r\n * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\r\n *\r\n * ```js\r\n * // create a red polyline from an array of arrays of LatLng points\r\n * var latlngs = [\r\n * \t[[45.51, -122.68],\r\n * \t [37.77, -122.43],\r\n * \t [34.04, -118.2]],\r\n * \t[[40.78, -73.91],\r\n * \t [41.83, -87.62],\r\n * \t [32.76, -96.72]]\r\n * ];\r\n * ```\r\n */\r\nexport class Polyline extends Geometry {\r\n    constructor(latlngs) {\r\n        super();\r\n        this._type = GeometryType.Polyline;\r\n        this._setLatLngs(latlngs);\r\n    }\r\n    // @method getLatLngs(): LatLng[]\r\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\r\n    getLatLngs() {\r\n        return this._latlngs;\r\n    }\r\n    _setLatLngs(latlngs) {\r\n        this._latlngBounds = new LatLngBounds();\r\n        this._latlngs = [];\r\n        for (let i = 0, len = latlngs.length; i < len; i++) {\r\n            this._latlngBounds.extend(latlngs[i]);\r\n            this._latlngs.push(latlngs[i]);\r\n        }\r\n    }\r\n    // @method setLatLngs(latlngs: LatLng[]): this\r\n    // Replaces all the points in the polyline with the given array of geographical points.\r\n    setLatLngs(latlngs) {\r\n        this._setLatLngs(latlngs);\r\n        // return this.redraw();\r\n    }\r\n    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\r\n    // Adds a given point to the polyline. By default, adds to the first ring of\r\n    // the polyline in case of a multi-polyline, but can be overridden by passing\r\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\r\n    // addLatLng(latlng: LatLng, latlngs?: LatLng[]) {\r\n    // \tlatlngs = latlngs || this._defaultShape();\r\n    // addLatLng(latlng: LatLng) {\r\n    // \t// const latlngs = this._defaultShape();\r\n    // \tthis._latlngs.push(latlng);\r\n    // \tthis._latlngBounds.extend(latlng);\r\n    // \t// return this.redraw();\r\n    // }\r\n    // @method getCenter(): LatLng\r\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.\r\n    // getCenter() {\r\n    // \treturn this._latlngBounds.getCenter();\r\n    // }\r\n    project() {\r\n        if (!this._crs)\r\n            return;\r\n        this._planeBounds = new PlaneBounds();\r\n        this._planeXYs = [];\r\n        for (let i = 0, len = this._latlngs.length; i < len; i++) {\r\n            const planeXY = this._crs.projection.project(this._latlngs[i]);\r\n            this._planeBounds.extend(planeXY);\r\n            this._planeXYs.push(planeXY);\r\n        }\r\n    }\r\n    transform(origin, zoom, symbol) {\r\n        if (!this._crs && !this._planeXYs)\r\n            return;\r\n        this._screenXYs = this._planeXYs.map(planeXY => {\r\n            return this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n        });\r\n        symbol = symbol || new SimpleLineSymbol();\r\n        this._screenBounds = symbol.getScreenBounds(this._screenXYs);\r\n    }\r\n    draw(ctx, symbol) {\r\n        if (!this._crs)\r\n            return;\r\n        // this._screenXYs = this._planeXYs.map(planeXY => {\r\n        // \treturn this._crs.planeXYToScreenXY(planeXY, zoom).round(false).subtract(origin);\r\n        // })\r\n        symbol = symbol || new SimpleLineSymbol();\r\n        // this._screenBounds = symbol.getScreenBounds(this._screenXYs);\r\n        symbol.draw(ctx, this._screenXYs);\r\n    }\r\n    toGeoJSON(precision = 6) {\r\n        const coords = [];\r\n        for (let i = 0, len = this._latlngs.length; i < len; i++) {\r\n            coords.push(this._latlngs[i].toGeoJSON(precision));\r\n        }\r\n        return {\r\n            type: \"LineString\",\r\n            coordinates: coords\r\n        };\r\n    }\r\n    contains(screenXY) {\r\n        let i, len, w = 5;\r\n        if (!this._screenBounds || !this._screenBounds.contains(screenXY)) {\r\n            return false;\r\n        }\r\n        // hit detection for polylines\r\n        for (i = 0, len = this._screenXYs.length; i < len - 1; i++) {\r\n            if (LineUtil.pointToSegmentDistance(screenXY, this._screenXYs[i], this._screenXYs[i + 1]) <= w) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","import { EventedObject } from \"../base/evented-object\";\r\nexport class Graphic extends EventedObject {\r\n    constructor(geometry, symbol) {\r\n        super();\r\n        this.prev = null;\r\n        this.next = null;\r\n        this._geometry = geometry;\r\n        this._symbol = symbol;\r\n    }\r\n    get geometry() {\r\n        return this._geometry;\r\n    }\r\n    get symbol() {\r\n        return this._symbol;\r\n    }\r\n    transform(origin, zoom) {\r\n        this._geometry.transform(origin, zoom, this._symbol);\r\n    }\r\n    /**\r\n       * 绘制点\r\n       * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n       * @param {Projection} projection - 坐标投影转换\r\n       * @param {Bound} extent - 当前可视范围\r\n       * @param {Symbol} symbol - 渲染符号\r\n       */\r\n    draw(ctx) {\r\n        this._geometry.draw(ctx, this._symbol);\r\n    }\r\n}\r\n","import * as Browser from '../util/browser';\r\nimport * as Util from '../util/util';\r\nimport * as DomUtil from '../util/dom-util';\r\nimport { EventedObject } from '../base/evented-object';\r\nimport { ScreenXY } from '../common/screen-xy';\r\nimport { ScreenBounds } from '../common/screen-bounds';\r\nimport { LatLngBounds } from '../common/latlng-bounds';\r\nimport { OptionsObject } from '../base/options-object';\r\n/*\r\n * @class GridLayer\r\n * @inherits Layer\r\n * @aka L.GridLayer\r\n *\r\n * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\r\n * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\r\n *\r\n *\r\n * @section Synchronous usage\r\n * @example\r\n *\r\n * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\r\n *\r\n * ```js\r\n * var CanvasLayer = L.GridLayer.extend({\r\n *     createTile: function(coords){\r\n *         // create a <canvas> element for drawing\r\n *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n *\r\n *         // setup tile width and height according to the options\r\n *         var size = this.getTileSize();\r\n *         tile.width = size.x;\r\n *         tile.height = size.y;\r\n *\r\n *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\r\n *         var ctx = tile.getContext('2d');\r\n *\r\n *         // return the tile so it can be rendered on screen\r\n *         return tile;\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * @section Asynchronous usage\r\n * @example\r\n *\r\n * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\r\n *\r\n * ```js\r\n * var CanvasLayer = L.GridLayer.extend({\r\n *     createTile: function(coords, done){\r\n *         var error;\r\n *\r\n *         // create a <canvas> element for drawing\r\n *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n *\r\n *         // setup tile width and height according to the options\r\n *         var size = this.getTileSize();\r\n *         tile.width = size.x;\r\n *         tile.height = size.y;\r\n *\r\n *         // draw something asynchronously and pass the tile to the done() callback\r\n *         setTimeout(function() {\r\n *             done(error, tile);\r\n *         }, 1000);\r\n *\r\n *         return tile;\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * @section\r\n */\r\nexport class GridOptions extends OptionsObject {\r\n    constructor() {\r\n        super(...arguments);\r\n        // @option tileSize: Number|Point = 256\r\n        // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\r\n        this.tileSize = 256;\r\n        // @option opacity: Number = 1.0\r\n        // Opacity of the tiles. Can be used in the `createTile()` function.\r\n        this.opacity = 1;\r\n        // @option updateWhenIdle: Boolean = (depends)\r\n        // Load new tiles only when panning ends.\r\n        // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\r\n        // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\r\n        // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\r\n        this.updateWhenIdle = Browser.mobile;\r\n        // @option updateWhenZooming: Boolean = true\r\n        // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\r\n        this.updateWhenZooming = true;\r\n        // @option updateInterval: Number = 200\r\n        // Tiles will not update more than once every `updateInterval` milliseconds when panning.\r\n        this.updateInterval = 200;\r\n        // @option zIndex: Number = 1\r\n        // The explicit zIndex of the tile layer.\r\n        this.zIndex = 1;\r\n        // @option bounds: LatLngBounds = undefined\r\n        // If set, tiles will only be loaded inside the set `LatLngBounds`.\r\n        this.bounds = null;\r\n        // @option minZoom: Number = 0\r\n        // The minimum zoom level down to which this layer will be displayed (inclusive).\r\n        this.minZoom = 0;\r\n        // @option maxZoom: Number = undefined\r\n        // The maximum zoom level up to which this layer will be displayed (inclusive).\r\n        this.maxZoom = 18;\r\n        // @option maxNativeZoom: Number = undefined\r\n        // Maximum zoom number the tile source has available. If it is specified,\r\n        // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\r\n        // from `maxNativeZoom` level and auto-scaled.\r\n        this.maxNativeZoom = undefined;\r\n        // @option minNativeZoom: Number = undefined\r\n        // Minimum zoom number the tile source has available. If it is specified,\r\n        // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\r\n        // from `minNativeZoom` level and auto-scaled.\r\n        this.minNativeZoom = undefined;\r\n        // @option noWrap: Boolean = false\r\n        // Whether the layer is wrapped around the antimeridian. If `true`, the\r\n        // GridLayer will only be displayed once at low zoom levels. Has no\r\n        // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\r\n        // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\r\n        // tiles outside the CRS limits.\r\n        this.noWrap = false;\r\n        // @option pane: String = 'tilePane'\r\n        // `Map pane` where the grid layer will be added.\r\n        this.pane = 'tilePane';\r\n        // @option className: String = ''\r\n        // A custom class name to assign to the tile layer. Empty by default.\r\n        this.className = '';\r\n        // @option keepBuffer: Number = 2\r\n        // When panning the map, keep this many rows and columns of tiles before unloading them.\r\n        this.keepBuffer = 2;\r\n        // @option zoomOffset: Number = 0\r\n        // The zoom number used in tile URLs will be offset with this value.\r\n        this.zoomOffset = 0;\r\n    }\r\n}\r\nexport class Grid extends EventedObject {\r\n    constructor(options) {\r\n        super();\r\n        this.options = new GridOptions();\r\n        this._tiles = {};\r\n        this._levels = {};\r\n        this.options.assign(options);\r\n    }\r\n    addTo(map) {\r\n        this._map = map;\r\n        if (this._container) {\r\n            return;\r\n        }\r\n        this._container = DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));\r\n        if (this.options.opacity < 1) {\r\n            this._updateOpacity();\r\n        }\r\n        this._map.getPane(this.options.pane).appendChild(this._container);\r\n        this._levels = {};\r\n        this._tiles = {};\r\n        if (this._map.loaded)\r\n            this._resetView(); // implicit _update() call\r\n        this._map.on('viewprereset', this._invalidateAll, this);\r\n        this._map.on('viewreset', this._resetView, this);\r\n        this._map.on('zoom', this._resetView, this);\r\n        this._map.on('zoomanim', this._animateZoom, this);\r\n        this._map.on('moveend', this._onMoveEnd, this);\r\n    }\r\n    removeFrom(map) {\r\n        this._map.off('viewprereset', this._invalidateAll, this);\r\n        this._map.off('viewreset', this._resetView, this);\r\n        this._map.off('zoom', this._resetView, this);\r\n        this._map.off('zoomanim', this._animateZoom, this);\r\n        this._map.off('moveend', this._onMoveEnd, this);\r\n        this._removeAllTiles();\r\n        DomUtil.remove(this._container);\r\n        // this._map._removeZoomLimit(this);\r\n        this._container = null;\r\n        this._tileZoom = undefined;\r\n    }\r\n    // onAdd: function () {\r\n    // \tthis._initContainer();\r\n    // \tthis._levels = {};\r\n    // \tthis._tiles = {};\r\n    // \tthis._resetView(); // implicit _update() call\r\n    // },\r\n    // beforeAdd: function (map) {\r\n    // \tmap._addZoomLimit(this);\r\n    // },\r\n    // onRemove: function (map) {\r\n    // \tthis._removeAllTiles();\r\n    // \tDomUtil.remove(this._container);\r\n    // \tmap._removeZoomLimit(this);\r\n    // \tthis._container = null;\r\n    // \tthis._tileZoom = undefined;\r\n    // },\r\n    // @method getContainer: HTMLElement\r\n    // Returns the HTML element that contains the tiles for this layer.\r\n    getContainer() {\r\n        return this._container;\r\n    }\r\n    // @method setOpacity(opacity: Number): this\r\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\r\n    setOpacity(opacity) {\r\n        this.options.opacity = opacity;\r\n        this._updateOpacity();\r\n    }\r\n    // @method isLoading: Boolean\r\n    // Returns `true` if any tile in the grid layer has not finished loading.\r\n    isLoading() {\r\n        return this._loading;\r\n    }\r\n    // @method redraw: this\r\n    // Causes the layer to clear all the tiles and request them again.\r\n    redraw() {\r\n        if (this._map) {\r\n            this._removeAllTiles();\r\n            this._update();\r\n        }\r\n    }\r\n    // @section Extension methods\r\n    // Layers extending `GridLayer` shall reimplement the following method.\r\n    // @method createTile(coords: Object, done?: Function): HTMLElement\r\n    // Called only internally, must be overridden by classes extending `GridLayer`.\r\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\r\n    // is specified, it must be called when the tile has finished loading and drawing.\r\n    createTile(coords, done) {\r\n        return document.createElement('div');\r\n    }\r\n    // @section\r\n    // @method getTileSize: Point\r\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\r\n    getTileSize() {\r\n        return new ScreenXY(this.options.tileSize, this.options.tileSize);\r\n    }\r\n    _updateOpacity() {\r\n        if (!this._map) {\r\n            return;\r\n        }\r\n        // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\r\n        if (Browser.ielt9) {\r\n            return;\r\n        }\r\n        DomUtil.setOpacity(this._container, this.options.opacity);\r\n        let now = +new Date(), nextFrame = false, willPrune = false;\r\n        for (let key in this._tiles) {\r\n            let tile = this._tiles[key];\r\n            if (!tile.current || !tile.loaded) {\r\n                continue;\r\n            }\r\n            let fade = Math.min(1, (now - tile.loaded) / 200);\r\n            DomUtil.setOpacity(tile.el, fade);\r\n            if (fade < 1) {\r\n                nextFrame = true;\r\n            }\r\n            else {\r\n                if (tile.active) {\r\n                    willPrune = true;\r\n                }\r\n                else {\r\n                    this._onOpaqueTile(tile);\r\n                }\r\n                tile.active = true;\r\n            }\r\n        }\r\n        if (willPrune && !this._noPrune) {\r\n            this._pruneTiles();\r\n        }\r\n        if (nextFrame) {\r\n            Util.cancelAnimFrame(this._fadeFrame);\r\n            this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);\r\n        }\r\n    }\r\n    _onOpaqueTile(tile) {\r\n    }\r\n    _updateLevels() {\r\n        var zoom = this._tileZoom, maxZoom = this.options.maxZoom;\r\n        if (zoom === undefined) {\r\n            return undefined;\r\n        }\r\n        for (let z in this._levels) {\r\n            // z = Number(z);\r\n            if (this._levels[z].el.children.length || Number(z) == zoom) {\r\n                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - Number(z));\r\n                this._onUpdateLevel(z);\r\n            }\r\n            else {\r\n                DomUtil.remove(this._levels[z].el);\r\n                this._removeTilesAtZoom(z);\r\n                this._onRemoveLevel(z);\r\n                delete this._levels[z];\r\n            }\r\n        }\r\n        var level = this._levels[zoom], map = this._map;\r\n        if (!level) {\r\n            level = this._levels[zoom] = {};\r\n            level.el = DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\r\n            level.el.style.zIndex = maxZoom;\r\n            level.origin = map.latLngToWorldPixel(map.worldPixelToLatLng(map.getPixelOrigin()), zoom).round();\r\n            level.zoom = zoom;\r\n            this._setZoomTransform(level, map.getCenter(), map.getZoom());\r\n            // force the browser to consider the newly added element for transition\r\n            // Util.falseFn(level.el.offsetWidth);\r\n            this._onCreateLevel(level);\r\n        }\r\n        this._level = level;\r\n        return level;\r\n    }\r\n    _onUpdateLevel(level) {\r\n    }\r\n    _onRemoveLevel(level) {\r\n    }\r\n    _onCreateLevel(level) {\r\n    }\r\n    _pruneTiles() {\r\n        if (!this._map)\r\n            return;\r\n        let zoom = this._map.getZoom();\r\n        if (zoom > this.options.maxZoom ||\r\n            zoom < this.options.minZoom) {\r\n            this._removeAllTiles();\r\n            return;\r\n        }\r\n        for (let key in this._tiles) {\r\n            let tile = this._tiles[key];\r\n            tile.retain = tile.current;\r\n        }\r\n        for (let key in this._tiles) {\r\n            let tile = this._tiles[key];\r\n            if (tile.current && !tile.active) {\r\n                let coords = tile.coords;\r\n                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\r\n                    this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\r\n                }\r\n            }\r\n        }\r\n        for (let key in this._tiles) {\r\n            if (!this._tiles[key].retain) {\r\n                this._removeTile(key);\r\n            }\r\n        }\r\n    }\r\n    _removeTilesAtZoom(zoom) {\r\n        for (var key in this._tiles) {\r\n            if (this._tiles[key].coords.z !== zoom) {\r\n                continue;\r\n            }\r\n            this._removeTile(key);\r\n        }\r\n    }\r\n    _removeAllTiles() {\r\n        for (var key in this._tiles) {\r\n            this._removeTile(key);\r\n        }\r\n    }\r\n    _invalidateAll() {\r\n        for (var z in this._levels) {\r\n            DomUtil.remove(this._levels[z].el);\r\n            this._onRemoveLevel(Number(z));\r\n            delete this._levels[z];\r\n        }\r\n        this._removeAllTiles();\r\n        this._tileZoom = undefined;\r\n    }\r\n    _retainParent(x, y, z, minZoom) {\r\n        let x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1;\r\n        var key = this._tileCoordsToKey({ x: x2, y: y2, z: z2 }), tile = this._tiles[key];\r\n        if (tile && tile.active) {\r\n            tile.retain = true;\r\n            return true;\r\n        }\r\n        else if (tile && tile.loaded) {\r\n            tile.retain = true;\r\n        }\r\n        if (z2 > minZoom) {\r\n            return this._retainParent(x2, y2, z2, minZoom);\r\n        }\r\n        return false;\r\n    }\r\n    _retainChildren(x, y, z, maxZoom) {\r\n        for (let i = 2 * x; i < 2 * x + 2; i++) {\r\n            for (let j = 2 * y; j < 2 * y + 2; j++) {\r\n                let key = this._tileCoordsToKey({ x: i, y: j, z: z + 1 }), tile = this._tiles[key];\r\n                if (tile && tile.active) {\r\n                    tile.retain = true;\r\n                    continue;\r\n                }\r\n                else if (tile && tile.loaded) {\r\n                    tile.retain = true;\r\n                }\r\n                if (z + 1 < maxZoom) {\r\n                    this._retainChildren(i, j, z + 1, maxZoom);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _resetView(e) {\r\n        const animating = e && (e.pinch || e.flyTo);\r\n        this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\r\n    }\r\n    _animateZoom(e) {\r\n        this._setView(e.center, e.zoom, true, e.noUpdate);\r\n    }\r\n    _clampZoom(zoom) {\r\n        const options = this.options;\r\n        if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\r\n            return options.minNativeZoom;\r\n        }\r\n        if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\r\n            return options.maxNativeZoom;\r\n        }\r\n        return zoom;\r\n    }\r\n    _abortLoading() {\r\n    }\r\n    _setView(center, zoom, noPrune, noUpdate) {\r\n        var tileZoom = Math.round(zoom);\r\n        if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||\r\n            (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {\r\n            tileZoom = undefined;\r\n        }\r\n        else {\r\n            tileZoom = this._clampZoom(tileZoom);\r\n        }\r\n        var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);\r\n        if (!noUpdate || tileZoomChanged) {\r\n            this._tileZoom = tileZoom;\r\n            if (this._abortLoading) {\r\n                this._abortLoading();\r\n            }\r\n            this._updateLevels();\r\n            this._resetGrid();\r\n            if (tileZoom !== undefined) {\r\n                this._update(center);\r\n            }\r\n            if (!noPrune) {\r\n                this._pruneTiles();\r\n            }\r\n            // Flag to prevent _updateOpacity from pruning tiles during\r\n            // a zoom anim or a pinch gesture\r\n            this._noPrune = !!noPrune;\r\n        }\r\n        this._setZoomTransforms(center, zoom);\r\n    }\r\n    _setZoomTransforms(center, zoom) {\r\n        for (let i in this._levels) {\r\n            this._setZoomTransform(this._levels[i], center, zoom);\r\n        }\r\n    }\r\n    _setZoomTransform(level, center, zoom) {\r\n        let scale = this._map.getZoomScale(zoom, level.zoom), translate = level.origin.multiplyBy(scale)\r\n            .subtract(this._map._getNewPixelOrigin(center, zoom)).round();\r\n        if (Browser.any3d) {\r\n            DomUtil.setTransform(level.el, translate, scale);\r\n        }\r\n        else {\r\n            DomUtil.setPosition(level.el, translate);\r\n        }\r\n    }\r\n    _resetGrid() {\r\n        let crs = this._map.getCRS(), tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;\r\n        const bounds = this._map.getPixelWorldBounds(this._tileZoom);\r\n        if (bounds) {\r\n            this._globalTileRange = this._pxBoundsToTileRange(bounds);\r\n        }\r\n    }\r\n    _onMoveEnd() {\r\n        if (!this._map || this._map._animatingZoom) {\r\n            return;\r\n        }\r\n        this._update();\r\n    }\r\n    _getTiledPixelBounds(center) {\r\n        let map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.latLngToWorldPixel(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale * 2);\r\n        return new ScreenBounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\r\n    }\r\n    // Private method to load tiles in the grid's active zoom level according to map bounds\r\n    _update(center) {\r\n        var map = this._map;\r\n        if (!map) {\r\n            return;\r\n        }\r\n        var zoom = this._clampZoom(map.getZoom());\r\n        if (center === undefined) {\r\n            center = map.getCenter();\r\n        }\r\n        if (this._tileZoom === undefined) {\r\n            return;\r\n        } // if out of minzoom/maxzoom\r\n        var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new ScreenBounds(tileRange.getBottomLeft().subtract(new ScreenXY(margin, -margin)), tileRange.getTopRight().add(new ScreenXY(margin, -margin)));\r\n        // Sanity check: panic if the tile range contains Infinity somewhere.\r\n        if (!(isFinite(tileRange.min.x) &&\r\n            isFinite(tileRange.min.y) &&\r\n            isFinite(tileRange.max.x) &&\r\n            isFinite(tileRange.max.y))) {\r\n            throw new Error('Attempted to load an infinite number of tiles');\r\n        }\r\n        for (var key in this._tiles) {\r\n            var c = this._tiles[key].coords;\r\n            if (c.z !== this._tileZoom || !noPruneRange.contains(new ScreenXY(c.x, c.y))) {\r\n                this._tiles[key].current = false;\r\n            }\r\n        }\r\n        // _update just loads more tiles. If the tile zoom level differs too much\r\n        // from the map's, let _setView reset levels and prune old tiles.\r\n        if (Math.abs(zoom - this._tileZoom) > 1) {\r\n            this._setView(center, zoom);\r\n            return;\r\n        }\r\n        // create a queue of coordinates to load tiles from\r\n        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\r\n            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\r\n                const coords = { x: i, y: j, z: this._tileZoom };\r\n                if (!this._isValidTile(coords)) {\r\n                    continue;\r\n                }\r\n                var tile = this._tiles[this._tileCoordsToKey(coords)];\r\n                if (tile) {\r\n                    tile.current = true;\r\n                }\r\n                else {\r\n                    queue.push(coords);\r\n                }\r\n            }\r\n        }\r\n        // sort tile queue to load tiles in order of their distance to center\r\n        queue.sort(function (a, b) {\r\n            return ((a.x - tileCenter.x) * (a.x - tileCenter.x) + (a.y - tileCenter.y) * (a.y - tileCenter.y))\r\n                - ((b.x - tileCenter.x) * (b.x - tileCenter.x) + (b.y - tileCenter.y) * (b.y - tileCenter.y));\r\n        });\r\n        if (queue.length !== 0) {\r\n            // if it's the first batch of tiles to load\r\n            if (!this._loading) {\r\n                this._loading = true;\r\n                // @event loading: Event\r\n                // Fired when the grid layer starts loading tiles.\r\n                this.fire('loading');\r\n            }\r\n            // create DOM fragment to append tiles in one batch\r\n            var fragment = document.createDocumentFragment();\r\n            for (i = 0; i < queue.length; i++) {\r\n                this._addTile(queue[i], fragment);\r\n            }\r\n            this._level.el.appendChild(fragment);\r\n        }\r\n    }\r\n    _isValidTile(coords) {\r\n        const crs = this._map.getCRS();\r\n        if (!crs.infinite) {\r\n            // don't load tile if it's out of bounds and not wrapped\r\n            const bounds = this._globalTileRange;\r\n            if ((coords.x < bounds.min.x || coords.x > bounds.max.x) ||\r\n                (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (!this.options.bounds) {\r\n            return true;\r\n        }\r\n        // don't load tile if it doesn't intersect the bounds in options\r\n        // bounds: LatLngBounds\r\n        const tileBounds = this._tileCoordsToBounds(coords);\r\n        return this.options.bounds.overlaps(tileBounds);\r\n    }\r\n    _keyToBounds(key) {\r\n        return this._tileCoordsToBounds(this._keyToTileCoords(key));\r\n    }\r\n    _tileCoordsToNwSe(coords) {\r\n        const map = this._map, tileSize = this.getTileSize(), nwPoint = new ScreenXY(coords.x, coords.y).scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.worldPixelToLatLng(nwPoint, coords.z), se = map.worldPixelToLatLng(sePoint, coords.z);\r\n        return [nw, se];\r\n    }\r\n    // converts tile coordinates to its geographical bounds\r\n    _tileCoordsToBounds(coords) {\r\n        let bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);\r\n        if (!this.options.noWrap) {\r\n            bounds = this._map.wrapLatLngBounds(bounds);\r\n        }\r\n        return bounds;\r\n    }\r\n    // converts tile coordinates to key for the tile cache\r\n    _tileCoordsToKey(coords) {\r\n        return coords.x + ':' + coords.y + ':' + coords.z;\r\n    }\r\n    // converts tile cache key to coordinates\r\n    _keyToTileCoords(key) {\r\n        let k = key.split(':');\r\n        return { x: +k[0], y: +k[1], z: +k[2] };\r\n    }\r\n    _removeTile(key) {\r\n        var tile = this._tiles[key];\r\n        if (!tile) {\r\n            return;\r\n        }\r\n        DomUtil.remove(tile.el);\r\n        delete this._tiles[key];\r\n        // @event tileunload: TileEvent\r\n        // Fired when a tile is removed (e.g. when a tile goes off the screen).\r\n        this.fire('tileunload', {\r\n            tile: tile.el,\r\n            coords: this._keyToTileCoords(key)\r\n        });\r\n    }\r\n    _initTile(tile) {\r\n        DomUtil.addClass(tile, 'leaflet-tile');\r\n        const tileSize = this.getTileSize();\r\n        tile.style.width = tileSize.x + 'px';\r\n        tile.style.height = tileSize.y + 'px';\r\n        tile.onselectstart = Util.falseFn;\r\n        tile.onmousemove = Util.falseFn;\r\n    }\r\n    _addTile(coords, container) {\r\n        let tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);\r\n        let tile = this.createTile(coords, () => {\r\n            this._tileReady(coords, null, tile);\r\n        });\r\n        this._initTile(tile);\r\n        // if createTile is defined with a second argument (\"done\" callback),\r\n        // we know that tile is async and will be ready later; otherwise\r\n        if (this.createTile.length < 2) {\r\n            // mark tile as ready, but delay one frame for opacity animation to happen\r\n            Util.requestAnimFrame(() => {\r\n                this._tileReady(coords, null, tile);\r\n            });\r\n        }\r\n        DomUtil.setPosition(tile, tilePos);\r\n        // save tile in cache\r\n        this._tiles[key] = {\r\n            el: tile,\r\n            coords: coords,\r\n            current: true\r\n        };\r\n        container.appendChild(tile);\r\n        // @event tileloadstart: TileEvent\r\n        // Fired when a tile is requested and starts loading.\r\n        this.fire('tileloadstart', {\r\n            tile: tile,\r\n            coords: coords\r\n        });\r\n    }\r\n    _tileReady(coords, err, tile) {\r\n        if (err) {\r\n            // @event tileerror: TileErrorEvent\r\n            // Fired when there is an error loading a tile.\r\n            this.fire('tileerror', {\r\n                error: err,\r\n                tile: tile,\r\n                coords: coords\r\n            });\r\n        }\r\n        let key = this._tileCoordsToKey(coords);\r\n        tile = this._tiles[key];\r\n        if (!tile) {\r\n            return;\r\n        }\r\n        tile.loaded = +new Date();\r\n        if (this._map._fadeAnimated) {\r\n            DomUtil.setOpacity(tile.el, 0);\r\n            Util.cancelAnimFrame(this._fadeFrame);\r\n            this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);\r\n        }\r\n        else {\r\n            tile.active = true;\r\n            this._pruneTiles();\r\n        }\r\n        if (!err) {\r\n            DomUtil.addClass(tile.el, 'leaflet-tile-loaded');\r\n            // @event tileload: TileEvent\r\n            // Fired when a tile loads.\r\n            this.fire('tileload', {\r\n                tile: tile.el,\r\n                coords: coords\r\n            });\r\n        }\r\n        if (this._noTilesToLoad()) {\r\n            this._loading = false;\r\n            // @event load: Event\r\n            // Fired when the grid layer loaded all visible tiles.\r\n            this.fire('load');\r\n            if (Browser.ielt9 || !this._map._fadeAnimated) {\r\n                Util.requestAnimFrame(this._pruneTiles, this);\r\n            }\r\n            else {\r\n                // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\r\n                // to trigger a pruning.\r\n                setTimeout(() => {\r\n                    this._pruneTiles();\r\n                }, 250);\r\n            }\r\n        }\r\n    }\r\n    _getTilePos(coords) {\r\n        return new ScreenXY(coords.x, coords.y).scaleBy(this.getTileSize()).subtract(this._level.origin);\r\n    }\r\n    _pxBoundsToTileRange(bounds) {\r\n        var tileSize = this.getTileSize();\r\n        return new ScreenBounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract(new ScreenXY(1, 1)));\r\n    }\r\n    _noTilesToLoad() {\r\n        for (var key in this._tiles) {\r\n            if (!this._tiles[key].loaded) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import * as Browser from '../util/browser';\r\nimport * as Util from '../util/util';\r\nimport * as DomEvent from '../util/dom-event';\r\nimport * as DomUtil from '../util/dom-util';\r\nimport { Grid, GridOptions } from './grid';\r\n/*\r\n * @class TileLayer\r\n * @inherits GridLayer\r\n * @aka L.TileLayer\r\n * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\r\n * ```\r\n *\r\n * @section URL template\r\n * @example\r\n *\r\n * A string of the following form:\r\n *\r\n * ```\r\n * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n * ```\r\n *\r\n * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n *\r\n * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n *\r\n * ```\r\n * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n * ```\r\n */\r\nexport class TileOptions extends GridOptions {\r\n    constructor() {\r\n        super(...arguments);\r\n        // @option subdomains: String|String[] = 'abc'\r\n        // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\r\n        this.subdomains = ['a', 'b', 'c'];\r\n        // @option errorTileUrl: String = ''\r\n        // URL to the tile image to show in place of the tile that failed to load.\r\n        this.errorTileUrl = '';\r\n        // @option zoomOffset: Number = 0\r\n        // The zoom number used in tile URLs will be offset with this value.\r\n        this.zoomOffset = 0;\r\n        // @option tms: Boolean = false\r\n        // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\r\n        this.tms = false;\r\n        // @option zoomReverse: Boolean = false\r\n        // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\r\n        this.zoomReverse = false;\r\n        // @option detectRetina: Boolean = false\r\n        // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\r\n        this.detectRetina = false;\r\n        // @option crossOrigin: Boolean|String = false\r\n        // Whether the crossOrigin attribute will be added to the tiles.\r\n        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\r\n        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n        this.crossOrigin = false;\r\n    }\r\n}\r\nexport class Tile extends Grid {\r\n    constructor(url, options) {\r\n        super();\r\n        this.options = new TileOptions();\r\n        this._url = url;\r\n        this.options.assign(options);\r\n    }\r\n    // @method setUrl(url: String, noRedraw?: Boolean): this\r\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\r\n    // If the URL does not change, the layer will not be redrawn unless\r\n    // the noRedraw parameter is set to false.\r\n    setUrl(url, noRedraw) {\r\n        if (this._url === url && noRedraw === undefined) {\r\n            noRedraw = true;\r\n        }\r\n        this._url = url;\r\n        if (!noRedraw) {\r\n            this.redraw();\r\n        }\r\n        return this;\r\n    }\r\n    // @method createTile(coords: Object, done?: Function): HTMLElement\r\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\r\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\r\n    // callback is called when the tile has been loaded.\r\n    createTile(coords, done) {\r\n        var tile = document.createElement('img');\r\n        DomEvent.on(tile, 'load', () => {\r\n            this._tileOnLoad(done, tile);\r\n        });\r\n        DomEvent.on(tile, 'error', () => {\r\n            this._tileOnError(done, tile);\r\n        });\r\n        if (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n            tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n        }\r\n        /*\r\n         Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n         http://www.w3.org/TR/WCAG20-TECHS/H67\r\n        */\r\n        tile.alt = '';\r\n        /*\r\n         Set role=\"presentation\" to force screen readers to ignore this\r\n         https://www.w3.org/TR/wai-aria/roles#textalternativecomputation\r\n        */\r\n        tile.setAttribute('role', 'presentation');\r\n        tile.src = this.getTileUrl(coords);\r\n        return tile;\r\n    }\r\n    // @section Extension methods\r\n    // @uninheritable\r\n    // Layers extending `TileLayer` might reimplement the following method.\r\n    // @method getTileUrl(coords: Object): String\r\n    // Called only internally, returns the URL for a tile given its coordinates.\r\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\r\n    getTileUrl(coords) {\r\n        const data = {\r\n            r: Browser.retina ? '@2x' : '',\r\n            s: this._getSubdomain(coords),\r\n            x: coords.x,\r\n            y: coords.y,\r\n            z: this._getZoomForUrl()\r\n        };\r\n        if (this._map && !this._map.getCRS().infinite) {\r\n            const invertedY = this._globalTileRange.max.y - coords.y;\r\n            if (this.options.tms) {\r\n                data['y'] = invertedY;\r\n            }\r\n            data['-y'] = invertedY;\r\n        }\r\n        return Util.template(this._url, data);\r\n    }\r\n    _tileOnLoad(done, tile) {\r\n        // For https://github.com/Leaflet/Leaflet/issues/3332\r\n        if (Browser.ielt9) {\r\n            setTimeout(() => {\r\n                done(null, tile);\r\n            }, 0);\r\n        }\r\n        else {\r\n            done(null, tile);\r\n        }\r\n    }\r\n    _tileOnError(done, tile, e) {\r\n        var errorUrl = this.options.errorTileUrl;\r\n        if (errorUrl && tile.getAttribute('src') !== errorUrl) {\r\n            tile.src = errorUrl;\r\n        }\r\n        done(e, tile);\r\n    }\r\n    _onTileRemove(e) {\r\n        e.tile.onload = null;\r\n    }\r\n    _getZoomForUrl() {\r\n        var zoom = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;\r\n        if (zoomReverse) {\r\n            zoom = maxZoom - zoom;\r\n        }\r\n        return zoom + zoomOffset;\r\n    }\r\n    _getSubdomain(tilePoint) {\r\n        var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n        return this.options.subdomains[index];\r\n    }\r\n    // stops loading all tiles in the background layer\r\n    _abortLoading() {\r\n        var i, tile;\r\n        for (i in this._tiles) {\r\n            if (this._tiles[i].coords.z !== this._tileZoom) {\r\n                tile = this._tiles[i].el;\r\n                tile.onload = Util.falseFn;\r\n                tile.onerror = Util.falseFn;\r\n                if (!tile.complete) {\r\n                    tile.src = Util.emptyImageUrl;\r\n                    DomUtil.remove(tile);\r\n                    delete this._tiles[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _removeTile(key) {\r\n        var tile = this._tiles[key];\r\n        if (!tile) {\r\n            return;\r\n        }\r\n        // Cancels any pending http requests associated with the tile\r\n        // unless we're on Android's stock browser,\r\n        // see https://github.com/Leaflet/Leaflet/issues/137\r\n        if (!Browser.androidStock) {\r\n            tile.el.setAttribute('src', Util.emptyImageUrl);\r\n        }\r\n        return super._removeTile(key);\r\n    }\r\n    _tileReady(coords, err, tile) {\r\n        if (!this._map || (tile && tile.getAttribute('src') === Util.emptyImageUrl)) {\r\n            return;\r\n        }\r\n        return super._tileReady(coords, err, tile);\r\n    }\r\n}\r\n","export * from './util/util';\r\nexport * from './util/browser';\r\nexport * from './util/dom-util';\r\nexport * from './util/dom-event';\r\nexport * from './base/base-object';\r\nexport * from './base/id-object';\r\nexport * from './base/options-object';\r\nexport * from './base/evented-object';\r\nexport * from './base/handler-object';\r\nexport * from './base/draggable-object';\r\nexport * from './common/latlng';\r\nexport * from './common/latlng-bounds';\r\nexport * from './common/bounds';\r\nexport * from './common/xy';\r\nexport * from './common/plane-xy';\r\nexport * from './common/screen-xy';\r\nexport * from './common/plane-bounds';\r\nexport * from './common/screen-bounds';\r\nexport * from './crs/crs';\r\nexport * from './crs/crs-earth';\r\nexport * from './crs/crs-4326';\r\nexport * from './crs/crs-3857';\r\nexport * from './crs/projection/projection';\r\nexport * from './crs/projection/projection-lonlat';\r\nexport * from './crs/projection/projection-mercator';\r\nexport * from './crs/projection/projection-spherical-mercator';\r\nexport * from './crs/transformation/transformation';\r\nexport * from './geometry/geometry';\r\nexport * from './geometry/point';\r\nexport * from './geometry/polyline';\r\nexport * from './geometry/polygon';\r\nexport * from './geometry/multiple-point';\r\nexport * from './geometry/multiple-polyline';\r\nexport * from './geometry/multiple-polygon';\r\nexport * from './graphic/graphic';\r\nexport * from './layer/layer';\r\nexport * from './layer/graphic-layer';\r\nexport * from './layer/feature-layer';\r\nexport * from './layer/raster-layer';\r\nexport * from './symbol/symbol';\r\nexport * from './symbol/cluster-symbol';\r\nexport * from './symbol/letter-symbol';\r\nexport * from './symbol/shape-symbol';\r\nexport * from './symbol/alternate-line-symbol';\r\nexport * from './symbol/arrow-symbol';\r\nexport * from './symbol/animate-symbol';\r\nexport * from './symbol/pattern-fill-symbol';\r\nexport * from './feature/field';\r\nexport * from './feature/feature';\r\nexport * from './feature/feature-class';\r\nexport * from './adapter/adapter';\r\nexport * from './adapter/geojson-adapter';\r\nexport * from './renderer/renderer';\r\nexport * from './renderer/simple-renderer';\r\nexport * from './renderer/dot-renderer';\r\nexport * from './renderer/category-renderer';\r\nexport * from './renderer/class-renderer';\r\nexport * from './renderer/cluster-renderer';\r\nexport * from './text/text';\r\nexport * from './label/collision';\r\nexport * from './label/label';\r\nexport * from './grid/grid';\r\nexport * from './grid/tile';\r\nexport * from './raster/raster';\r\nexport * from './analysis/interpolation/kriging';\r\nexport * from './analysis/interpolation/idw';\r\nexport * from './analysis/heat/heat';\r\nexport * from './animation/animation';\r\nexport * from './animation/point-animation';\r\nexport * from './animation/line-animation';\r\nexport * from './map/canvas/canvas';\r\nexport * from './map/canvas/viewer';\r\nexport * from './map/canvas/animater';\r\nexport * from './map/map';\r\nexport * from './map/position-animation';\r\nexport * from './map/handler/map-drag';\r\nexport * from './map/handler/map-scrollwheelzoom';\r\nexport * from './map/handler/map-doubleclickzoom';\r\n","import { CoordinateType } from \"../geometry/geometry\";\r\n/**\r\n * 冲突检测基类\r\n */\r\nexport class Collision {\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(ctx, features, field, text) { return []; }\r\n}\r\n/**\r\n * 无检测机制\r\n */\r\nexport class NullCollision {\r\n    /**\r\n     * 冲突检测\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {Text} text - 标注文本符号\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(ctx, features, field, text) {\r\n        //没有任何检测逻辑，直接原样返回\r\n        return features;\r\n    }\r\n}\r\n/**\r\n * 简单碰撞冲突\r\n * @remarks\r\n * 类似聚合，距离判断，速度快\r\n */\r\nexport class SimpleCollision {\r\n    constructor() {\r\n        /**\r\n         * 检测距离\r\n         * @remarks\r\n         * 单位 pixel\r\n         */\r\n        this.distance = 50;\r\n    }\r\n    /**\r\n     * 冲突检测\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {Text} text - 标注文本符号\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(ctx, features, field, text) {\r\n        //根据距离聚合\r\n        return features.reduce((acc, cur) => {\r\n            const item = acc.find((item) => {\r\n                const distance = cur.geometry.distance(item.geometry, CoordinateType.Screen);\r\n                return distance <= this.distance;\r\n            });\r\n            if (!item)\r\n                acc.push(cur);\r\n            return acc;\r\n        }, []); // [feature]\r\n    }\r\n}\r\n// /**\r\n//  * 叠盖碰撞冲突\r\n//  * @remarks\r\n//  * 试算标注宽高，并和已通过检测的标注，进行边界的交叉判断，速度慢\r\n//  */\r\n// export class CoverCollision {\r\n//     /**\r\n//      * 已通过检测的标注的边界集合\r\n//      */\r\n//     private _bounds: Bound[] = [];\r\n//     /**\r\n//      * 判断边界碰撞时的buffer\r\n//      * @remarks\r\n//      * buffer越小，标注越密，单位：pixel\r\n//      */\r\n//     public buffer: number = 10;\r\n//     /**\r\n//      * 冲突检测\r\n//      * @param {Feature[]} features - 准备绘制标注的要素集合\r\n//      * @param {Field} field - 标注字段\r\n//      * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n//      * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n//      * @param {Projection} projection - 坐标投影转换\r\n//      * @return {Feature[]} 返回可绘制标注的要素集合\r\n//      */\r\n//     test(ctx: CanvasRenderingContext2D, features: Feature[], field: Field, symbol: SimpleTextSymbol, projection: Projection = new WebMercator()): Feature[] {\r\n//         if (!field || !symbol) return [];\r\n//         this._bounds = [];\r\n//         const measure = (feature, symbol) => {\r\n//             const bound = feature.geometry.measure(feature.properties[field.name], ctx, projection, symbol);\r\n//             bound.buffer(this.buffer);\r\n//             if (bound) {\r\n//                 const item = this._bounds.find( item => item.intersect(bound) );\r\n//                 if (!item) {\r\n//                     return bound;\r\n//                 }\r\n//             }\r\n//             return null;\r\n//         };\r\n//         const replace = (feature, symbol, count) => {\r\n//             const symbol2 = new SimpleTextSymbol();\r\n//             symbol2.copy(symbol);\r\n//             symbol2.replacement();\r\n//             const bound = measure(feature, symbol2);\r\n//             if (bound) {\r\n//                 return [bound, symbol2];\r\n//             } else {\r\n//                 if (count == 0) {\r\n//                     return [null, null];\r\n//                 } else {\r\n//                     count -= 1;\r\n//                     return replace(feature, symbol2, count);\r\n//                 }\r\n//             }\r\n//         };\r\n//         //根据标注宽高的量算，得到标注的size，并和已通过检测的标注，进行边界的交叉判断，来决定是否可绘制该要素的标注\r\n//         return features.reduce( (acc, cur) => {\r\n//             cur.text = null;\r\n//             let bound = measure(cur, symbol);\r\n//             if (bound) {\r\n//                 acc.push(cur);\r\n//                 this._bounds.push(bound);\r\n//             } else {\r\n//                 if (symbol.auto) {\r\n//                     const [bound, symbol2] = replace(cur, symbol, 3);    //一共4个方向，再测试剩余3个方向\r\n//                     if (bound) {\r\n//                         cur.text = symbol2;\r\n//                         acc.push(cur);\r\n//                         this._bounds.push(bound);\r\n//                     }\r\n//                 }\r\n//             }\r\n//             return acc;\r\n//         }, []); // [feature]\r\n//     }\r\n// }\r\n","import { Text } from \"../text/text\";\r\nimport { SimpleCollision } from \"./collision\";\r\n/**\r\n * 图层标注设置\r\n */\r\nexport class Label {\r\n    constructor() {\r\n        /**\r\n         * 标注符号\r\n         * @remarks\r\n         * 参考Renderer和Feature中的相关重要说明\r\n         */\r\n        this.text = new Text();\r\n        /**\r\n         * 标注冲突解决方式\r\n         */\r\n        this.collision = new SimpleCollision();\r\n    }\r\n    /**\r\n     * 绘制图层标注\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     */\r\n    draw(ctx, features) {\r\n        //通过冲突检测，得到要绘制的要素集合\r\n        const remain = this.collision.test(ctx, features, this.field, this.text);\r\n        //遍历绘制要素标注\r\n        remain.forEach((feature) => {\r\n            feature.label(ctx, this.field, this.text);\r\n        });\r\n    }\r\n}\r\n","import { SimpleRenderer } from \"../renderer/simple-renderer\";\r\nimport { Layer } from \"./layer\";\r\nexport class FeatureLayer extends Layer {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 图层渲染方式\r\n         */\r\n        this._renderer = new SimpleRenderer();\r\n        /**\r\n         * 是否显示标注\r\n         */\r\n        this.labeled = false;\r\n    }\r\n    /**\r\n     * 获取矢量要素类（数据源）\r\n     */\r\n    get featureClass() {\r\n        return this._featureClass;\r\n    }\r\n    /**\r\n     * 设置矢量要素类（数据源）\r\n     */\r\n    set featureClass(value) {\r\n        this._featureClass = value;\r\n    }\r\n    /**\r\n     * 获取图层标注\r\n     */\r\n    get label() {\r\n        return this._label;\r\n    }\r\n    /**\r\n     * 设置图层标注\r\n     */\r\n    set label(value) {\r\n        this._label = value;\r\n    }\r\n    /**\r\n     * 获取图层渲染方式\r\n     */\r\n    get renderer() {\r\n        return this._renderer;\r\n    }\r\n    /**\r\n     * 设置图层渲染方式\r\n     */\r\n    set renderer(value) {\r\n        this._renderer = value;\r\n    }\r\n    /**\r\n     * 设置图层显示坐标系\r\n     */\r\n    set crs(value) {\r\n        this._crs = value;\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            feature.geometry.crs = value;\r\n            feature = feature.next;\r\n        }\r\n    }\r\n    transform(origin, zoom) {\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            feature.geometry.transform(origin, zoom, this._renderer.getSymbol(feature));\r\n            feature = feature.next;\r\n        }\r\n    }\r\n    /**\r\n     * 绘制图层\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, zoom, redrawBounds) {\r\n        if (!this.visible || this.minZoom >= zoom || this.maxZoom <= zoom)\r\n            return;\r\n        // before draw\r\n        this._renderer.init(redrawBounds);\r\n        let feature = this._featureClass.first;\r\n        // let count = 0;\r\n        const features = [];\r\n        while (feature) {\r\n            if (!redrawBounds || (feature.geometry && feature.geometry.screenBounds && feature.geometry.screenBounds.intersects(redrawBounds))) {\r\n                const symbol = this._renderer.getSymbol(feature);\r\n                if (symbol) {\r\n                    feature.draw(ctx, symbol);\r\n                    features.push(feature);\r\n                }\r\n                // count += 1;\r\n            }\r\n            feature = feature.next;\r\n        }\r\n        // console.log(count);\r\n        if (this.labeled) {\r\n            this.label.draw(ctx, features);\r\n        }\r\n    }\r\n    query(screenXY, zoom, bounds) {\r\n        if (!this.visible || this.minZoom >= zoom || this.maxZoom <= zoom)\r\n            return [];\r\n        let feature = this._featureClass.first;\r\n        const features = [];\r\n        while (feature) {\r\n            if (feature.geometry && feature.geometry.screenBounds && feature.geometry.screenBounds.intersects(bounds)) {\r\n                if (feature.geometry.contains(screenXY)) {\r\n                    features.push(feature);\r\n                }\r\n            }\r\n            feature = feature.next;\r\n        }\r\n        return features;\r\n    }\r\n    on(types, fn, context) {\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            feature.on(types, fn, context);\r\n            feature = feature.next;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n","import { Layer } from \"./layer\";\r\nexport class GraphicLayer extends Layer {\r\n    constructor() {\r\n        super();\r\n        this._graphics = {}; //Map<string, Graphic>\r\n    }\r\n    set crs(value) {\r\n        this._crs = value;\r\n        let graphic = this._first;\r\n        while (graphic) {\r\n            graphic.geometry.crs = value;\r\n            graphic = graphic.next;\r\n        }\r\n    }\r\n    addGraphic(graphic, last = true) {\r\n        this._graphics[graphic.id] = graphic;\r\n        graphic.geometry.crs = this._crs;\r\n        if (!this._first) {\r\n            this._first = graphic;\r\n            this._last = graphic;\r\n        }\r\n        else {\r\n            if (!last) {\r\n                this._first.prev = graphic;\r\n                graphic.next = this._first;\r\n                this._first = graphic;\r\n            }\r\n            else {\r\n                this._last.next = graphic;\r\n                graphic.prev = this._last;\r\n                this._last = graphic;\r\n            }\r\n        }\r\n    }\r\n    removeGraphic(graphic) {\r\n        if (this._first == graphic) {\r\n            this._first = graphic.next;\r\n        }\r\n        if (this._last == graphic) {\r\n            this._last = graphic.prev;\r\n        }\r\n        if (graphic.prev) {\r\n            graphic.prev.next = graphic.next;\r\n        }\r\n        if (graphic.next) {\r\n            graphic.next.prev = graphic.prev;\r\n        }\r\n        graphic.prev = null;\r\n        graphic.next = null;\r\n        delete this._graphics[graphic.id];\r\n    }\r\n    clearGraphics() {\r\n        this._first = null;\r\n        this._last = null;\r\n        this._graphics = {};\r\n    }\r\n    transform(origin, zoom) {\r\n        let graphic = this._first;\r\n        while (graphic) {\r\n            graphic.transform(origin, zoom);\r\n            graphic = graphic.next;\r\n        }\r\n    }\r\n    draw(ctx, zoom, redrawBounds) {\r\n        if (!this.visible || this.minZoom >= zoom || this.maxZoom <= zoom)\r\n            return;\r\n        let graphic = this._first;\r\n        // let count = 0;\r\n        while (graphic) {\r\n            if (!redrawBounds || (graphic.geometry && graphic.geometry.screenBounds && graphic.geometry.screenBounds.intersects(redrawBounds))) {\r\n                graphic.draw(ctx);\r\n                // count += 1;\r\n            }\r\n            graphic = graphic.next;\r\n        }\r\n        // console.log(\"count:\", count);\r\n    }\r\n    query(screenXY, zoom, bounds) {\r\n        if (!this.visible || this.minZoom >= zoom || this.maxZoom <= zoom)\r\n            return [];\r\n        let graphic = this._first;\r\n        const graphics = [];\r\n        while (graphic) {\r\n            if (graphic.geometry && graphic.geometry.screenBounds && graphic.geometry.screenBounds.intersects(bounds)) {\r\n                if (graphic.geometry.contains(screenXY)) {\r\n                    graphics.push(graphic);\r\n                }\r\n            }\r\n            graphic = graphic.next;\r\n        }\r\n        return graphics;\r\n    }\r\n    on(types, fn, context) {\r\n        let graphic = this._first;\r\n        while (graphic) {\r\n            graphic.on(types, fn, context);\r\n            graphic = graphic.next;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n","import { EventedObject } from \"../base/evented-object\";\r\n/**\r\n * 图层基类\r\n */\r\nexport class Layer extends EventedObject {\r\n    /**\r\n     * 创建图层\r\n     */\r\n    constructor() {\r\n        super();\r\n        /**\r\n         * 图层可见设置\r\n         */\r\n        this._visible = true;\r\n        /**\r\n         * 图层可见缩放级别\r\n         */\r\n        this._zoom = [1, 20];\r\n        /**\r\n         * 图层可交互设置\r\n         */\r\n        this._interactive = true;\r\n        /**\r\n         * 图层顺序（z-index）\r\n         * @remarks\r\n         * TODO: marker的异步加载，会影响绘制顺序\r\n         */\r\n        this._index = 0; //z-index\r\n    }\r\n    /**\r\n     * 图层是否可见\r\n     */\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    /**\r\n     * 图层可见设置\r\n     */\r\n    set visible(value) {\r\n        this._visible = value;\r\n    }\r\n    /**\r\n       * 图层可见缩放级别设置\r\n       */\r\n    get minZoom() {\r\n        return this._zoom[0];\r\n    }\r\n    get maxZoom() {\r\n        return this._zoom[1];\r\n    }\r\n    set minZoom(value) {\r\n        this._zoom[0] = value;\r\n    }\r\n    set maxZoom(value) {\r\n        this._zoom[1] = value;\r\n    }\r\n    set zoom(value) {\r\n        this._zoom = value;\r\n    }\r\n    /**\r\n     * 图层是否可交互\r\n     */\r\n    get interactive() {\r\n        return this._interactive;\r\n    }\r\n    /**\r\n     * 图层可交互设置\r\n     */\r\n    set interactive(value) {\r\n        this._interactive = value;\r\n    }\r\n    /**\r\n     * 图层顺序\r\n     */\r\n    get index() {\r\n        return this._index;\r\n    }\r\n    /**\r\n     * 图层顺序设置\r\n     */\r\n    set index(value) {\r\n        this._index = value;\r\n    }\r\n}\r\n","import { Layer } from \"./layer\";\r\n/**\r\n * 栅格图层\r\n */\r\nexport class RasterLayer extends Layer {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 图层可交互设置\r\n         */\r\n        this._interactive = false;\r\n    }\r\n    get raster() {\r\n        return this._raster;\r\n    }\r\n    set raster(value) {\r\n        this._raster = value;\r\n    }\r\n    set crs(value) {\r\n        this._crs = value;\r\n        if (this._raster) {\r\n            this._raster.crs = value;\r\n        }\r\n    }\r\n    transform(origin, zoom) {\r\n        if (this._raster) {\r\n            this._raster.transform(origin, zoom);\r\n        }\r\n    }\r\n    /**\r\n     * 绘制图层\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {Bound} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    draw(ctx, zoom, redrawBounds) {\r\n        if (!this.visible || this.minZoom >= zoom || this.maxZoom <= zoom)\r\n            return;\r\n        if (!this.raster.screenBounds || this.raster.screenBounds.intersects(redrawBounds)) {\r\n            this.raster && this.raster.draw(ctx);\r\n        }\r\n    }\r\n}\r\n","import { Canvas, CanvasOptions } from \"./canvas\";\r\nexport class AnimaterOptions extends CanvasOptions {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.pane = 'animatePane';\r\n    }\r\n}\r\nexport class Animater extends Canvas {\r\n    constructor(map, options) {\r\n        super(map, options);\r\n        this.options = new AnimaterOptions();\r\n        this._animations = [];\r\n    }\r\n    _onZoomEnd() {\r\n        super._onZoomEnd();\r\n        this._animations.forEach(animation => {\r\n            animation.transform(this._origin, this._zoom);\r\n        });\r\n    }\r\n    addAnimation(animation) {\r\n        animation.transform(this._origin, this._zoom);\r\n        this._animations.push(animation);\r\n    }\r\n    // removeAnimation(animation: Animation) {\r\n    //   const index = this._animations.findIndex(item => item.id == animation.id);\r\n    //   this._animations.splice(index, 1);\r\n    //   this._updateGeometry();\r\n    // }\r\n    // clearGraphicLayers() {\r\n    //   this._graphicLayers = [];\r\n    //   this._updateGeometry();\r\n    // }\r\n    _draw() {\r\n        if (this._ctx) {\r\n            let bounds = this._redrawBounds;\r\n            this._ctx.save();\r\n            if (bounds) {\r\n                var size = bounds.getSize();\r\n                this._ctx.beginPath();\r\n                this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\r\n                this._ctx.clip();\r\n            }\r\n            this._drawing = true;\r\n            // console.time(\"draw\");\r\n            this._frame && window.cancelAnimationFrame(this._frame);\r\n            this._start = undefined;\r\n            //this上下文绑定\r\n            this._animate = this._animate.bind(this);\r\n            //动画循环\r\n            this._frame = window.requestAnimationFrame(this._animate);\r\n            // console.timeEnd(\"draw\");\r\n            this._drawing = false;\r\n            this._ctx.restore(); // Restore state before clipping.\r\n        }\r\n    }\r\n    /**\r\n       * 动画循环\r\n       * @param {number} timestamp - 时间戳\r\n       */\r\n    _animate(timestamp) {\r\n        if (this._start === undefined) {\r\n            this._start = timestamp;\r\n        }\r\n        //计算逝去时间，毫秒\r\n        const elapsed = timestamp - this._start;\r\n        this._ctx.save();\r\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\r\n        this._ctx.restore();\r\n        //遍历所以动画效果，执行动画\r\n        this._animations.forEach(animation => {\r\n            animation.animate(elapsed, this._ctx);\r\n        });\r\n        //循环，下一帧\r\n        this._frame = window.requestAnimationFrame(this._animate);\r\n    }\r\n}\r\n","import * as DomUtil from '../../util/dom-util';\r\nimport * as DomEvent from '../../util/dom-event';\r\nimport * as Browser from '../../util/browser';\r\nimport * as Util from '../../util/util';\r\nimport { EventedObject } from '../../base/evented-object';\r\nimport { ScreenBounds } from '../../common/screen-bounds';\r\nimport { OptionsObject } from '../../base/options-object';\r\n/*\r\n * @class Canvas\r\n * @inherits Renderer\r\n * @aka L.Canvas\r\n *\r\n * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\r\n * Inherits `Renderer`.\r\n *\r\n * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not\r\n * available in all web browsers, notably IE8, and overlapping geometries might\r\n * not display properly in some edge cases.\r\n *\r\n * @example\r\n *\r\n * Use Canvas by default for all paths in the map:\r\n *\r\n * ```js\r\n * var map = L.map('map', {\r\n * \trenderer: L.canvas()\r\n * });\r\n * ```\r\n *\r\n * Use a Canvas renderer with extra padding for specific vector geometries:\r\n *\r\n * ```js\r\n * var map = L.map('map');\r\n * var myRenderer = L.canvas({ padding: 0.5 });\r\n * var line = L.polyline( coordinates, { renderer: myRenderer } );\r\n * var circle = L.circle( center, { renderer: myRenderer } );\r\n * ```\r\n */\r\nexport class CanvasOptions extends OptionsObject {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.pane = 'overlayPane';\r\n        // @option padding: Number = 0.1\r\n        // How much to extend the clip area around the map view (relative to its size)\r\n        // e.g. 0.1 would be 10% of map view in each direction\r\n        this.padding = 0.1;\r\n        // @option tolerance: Number = 0\r\n        // How much to extend click tolerance round a path/object on the map\r\n        this.tolerance = 0;\r\n    }\r\n}\r\nexport class Canvas extends EventedObject {\r\n    constructor(map, options) {\r\n        super();\r\n        this.options = new CanvasOptions();\r\n        this._map = map;\r\n        this.options.assign(options);\r\n    }\r\n    init() {\r\n        const container = this._container = document.createElement('canvas');\r\n        this._ctx = container.getContext('2d');\r\n        if (this._container) {\r\n            this._map.getPane(this.options.pane).appendChild(this._container);\r\n            // this._update();\r\n            // this.on('update', this._updateGeometry, this);\r\n            DomUtil.addClass(this._container, 'leaflet-zoom-animated');\r\n        }\r\n        this._map.on('viewreset', this._reset, this);\r\n        this._map.on('zoom', this._onZoom, this);\r\n        this._map.on('zoomanim', this._onAnimZoom, this);\r\n        this._map.on('moveend', this._updateCanvas, this);\r\n        this._map.on('zoomend', this._onZoomEnd, this);\r\n    }\r\n    destroy() {\r\n        this._map.off('viewreset', this._reset, this);\r\n        this._map.off('zoom', this._onZoom, this);\r\n        this._map.off('zoomanim', this._onAnimZoom, this);\r\n        this._map.off('moveend', this._updateCanvas, this);\r\n        this._map.off('zoomend', this._onZoomEnd, this);\r\n        if (this._redrawRequest) {\r\n            Util.cancelAnimFrame(this._redrawRequest);\r\n        }\r\n        delete this._ctx;\r\n        if (this._container) {\r\n            // this.off('update', this._updateGeometry, this);\r\n            DomUtil.remove(this._container);\r\n            DomEvent.off(this._container);\r\n            delete this._container;\r\n        }\r\n    }\r\n    _onZoomEnd() {\r\n        this._zoom = this._map.getZoom();\r\n        this._origin = this._map.getPixelOrigin();\r\n    }\r\n    _onAnimZoom(ev) {\r\n        this._updateTransform(ev.center, ev.zoom);\r\n    }\r\n    _onZoom() {\r\n        this._updateTransform(this._map.getCenter(), this._map.getZoom());\r\n    }\r\n    _updateTransform(center, zoom) {\r\n        if (!this._container)\r\n            return;\r\n        let scale = this._map.getZoomScale(zoom, this._zoom), position = DomUtil.getPosition(this._container), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.latLngToWorldPixel(this._center || this._map.getCenter(), zoom), destCenterPoint = this._map.latLngToWorldPixel(center, zoom), centerOffset = destCenterPoint.subtract(currentCenterPoint), topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\r\n        if (Browser.any3d) {\r\n            DomUtil.setTransform(this._container, topLeftOffset, scale);\r\n        }\r\n        else {\r\n            DomUtil.setPosition(this._container, topLeftOffset);\r\n        }\r\n    }\r\n    // update geometry\r\n    _updateGeometry() {\r\n        this._redrawBounds = null;\r\n        this._redraw();\r\n    }\r\n    // update center/zoom/bounds/position\r\n    _updateCanvas() {\r\n        if (this._map._animatingZoom && this._bounds) {\r\n            return;\r\n        }\r\n        // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\r\n        // Subclasses are responsible of firing the 'update' event.\r\n        const p = this.options.padding, size = this._map.getSize(), min = this._map.containerPixelToCanvasPixel(size.multiplyBy(-p)).round();\r\n        this._bounds = new ScreenBounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\r\n        this._center = this._map.getCenter();\r\n        this._zoom = this._map.getZoom();\r\n        this._origin = this._map.getPixelOrigin();\r\n        const b = this._bounds, container = this._container, bsize = b.getSize(), m = Browser.retina ? 2 : 1;\r\n        if (container) {\r\n            DomUtil.setPosition(container, b.min);\r\n            // set canvas size (also clearing it); use double size on retina\r\n            container.width = m * bsize.x;\r\n            container.height = m * bsize.y;\r\n            container.style.width = bsize.x + 'px';\r\n            container.style.height = bsize.y + 'px';\r\n        }\r\n        if (this._ctx) {\r\n            if (Browser.retina) {\r\n                this._ctx.scale(2, 2);\r\n            }\r\n            // translate so we use the same path coordinates after canvas element moves\r\n            this._ctx.translate(-b.min.x, -b.min.y);\r\n        }\r\n        // Tell paths to redraw themselves\r\n        this._updateGeometry();\r\n        this.fire('update');\r\n    }\r\n    _reset() {\r\n        // this._update();\r\n        this._updateTransform(this._center, this._zoom);\r\n        this._updateGeometry();\r\n    }\r\n    _requestRedraw(geometry) {\r\n        if (!this._map) {\r\n            return;\r\n        }\r\n        this._extendRedrawBounds(geometry);\r\n        this._redrawRequest = this._redrawRequest || Util.requestAnimFrame(this._redraw, this);\r\n    }\r\n    _extendRedrawBounds(geometry) {\r\n        if (geometry.screenBounds) {\r\n            // var padding = (layer.options.weight || 0) + 1;\r\n            this._redrawBounds = this._redrawBounds || new ScreenBounds();\r\n            // this._redrawBounds.extend(layer.screenBounds.min.subtract(new ScreenXY(padding, padding)));\r\n            // this._redrawBounds.extend(layer.screenBounds.max.add(new ScreenXY(padding, padding)));\r\n            this._redrawBounds.extend(geometry.screenBounds.min);\r\n            this._redrawBounds.extend(geometry.screenBounds.max);\r\n        }\r\n    }\r\n    _redraw() {\r\n        this._redrawRequest = null;\r\n        if (this._redrawBounds) {\r\n            this._redrawBounds.min.floor(false);\r\n            this._redrawBounds.max.ceil(false);\r\n        }\r\n        this._clear(); // clear layers in redraw bounds\r\n        this._draw(); // draw layers\r\n        this._redrawBounds = null;\r\n    }\r\n    _clear() {\r\n        if (this._ctx) {\r\n            const bounds = this._redrawBounds;\r\n            if (bounds) {\r\n                const size = bounds.getSize();\r\n                this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\r\n            }\r\n            else {\r\n                if (this._container) {\r\n                    this._ctx.save();\r\n                    this._ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n                    this._ctx.clearRect(0, 0, this._container.width, this._container.height);\r\n                    this._ctx.restore();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _draw() {\r\n        if (this._ctx) {\r\n            let bounds = this._redrawBounds;\r\n            this._ctx.save();\r\n            if (bounds) {\r\n                var size = bounds.getSize();\r\n                this._ctx.beginPath();\r\n                this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\r\n                this._ctx.clip();\r\n            }\r\n            this._drawing = true;\r\n            // console.time(\"draw\");\r\n            // console.timeEnd(\"draw\");\r\n            this._drawing = false;\r\n            this._ctx.restore(); // Restore state before clipping.\r\n        }\r\n    }\r\n}\r\n","import * as DomUtil from '../../util/dom-util';\r\nimport * as DomEvent from '../../util/dom-event';\r\nimport { GraphicLayer } from '../../layer/graphic-layer';\r\nimport { Canvas, CanvasOptions } from \"./canvas\";\r\nexport class ViewerOptions extends CanvasOptions {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.pane = 'overlayPane';\r\n    }\r\n}\r\nexport class Viewer extends Canvas {\r\n    constructor(map, options) {\r\n        super(map, options);\r\n        this.options = new ViewerOptions();\r\n        this._graphicLayer = new GraphicLayer();\r\n        this._graphicLayer.crs = map.getCRS();\r\n        this._graphicLayers = [];\r\n        this._featureLayers = [];\r\n        this._rasterLayers = [];\r\n        // this.options.assign(options);\r\n    }\r\n    init() {\r\n        super.init();\r\n        if (this._container) {\r\n            DomEvent.on(this._container, 'mousemove', this._onMouseMove, this);\r\n            DomEvent.on(this._container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\r\n            DomEvent.on(this._container, 'mouseout', this._handleMouseOut, this);\r\n        }\r\n    }\r\n    destroy() {\r\n        if (this._container) {\r\n            DomEvent.off(this._container);\r\n        }\r\n        super.destroy();\r\n    }\r\n    _onZoomEnd() {\r\n        super._onZoomEnd();\r\n        this._graphicLayer.transform(this._origin, this._zoom);\r\n        this._graphicLayers.forEach(layer => {\r\n            layer.transform(this._origin, this._zoom);\r\n        });\r\n        this._featureLayers.forEach(layer => {\r\n            layer.transform(this._origin, this._zoom);\r\n        });\r\n        this._rasterLayers.forEach(layer => {\r\n            layer.transform(this._origin, this._zoom);\r\n        });\r\n    }\r\n    addGraphic(graphic) {\r\n        this._graphicLayer.addGraphic(graphic);\r\n        if (this._origin) {\r\n            graphic.transform(this._origin, this._zoom);\r\n            this._requestRedraw(graphic.geometry);\r\n        }\r\n    }\r\n    removeGraphic(graphic) {\r\n        this._graphicLayer.removeGraphic(graphic);\r\n        this._requestRedraw(graphic.geometry);\r\n    }\r\n    clearGraphics() {\r\n        this._graphicLayer.clearGraphics();\r\n        this._updateGeometry();\r\n    }\r\n    addGraphicLayer(graphicLayer) {\r\n        this._graphicLayers.push(graphicLayer);\r\n        if (this._origin) {\r\n            graphicLayer.transform(this._origin, this._zoom);\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    removeGraphicLayer(graphicLayer) {\r\n        const index = this._graphicLayers.findIndex(layer => layer.id == graphicLayer.id);\r\n        if (index != -1) {\r\n            this._graphicLayers.splice(index, 1);\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    clearGraphicLayers() {\r\n        if (this._graphicLayers.length > 0) {\r\n            this._graphicLayers = [];\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    addFeatureLayer(featureLayer) {\r\n        this._featureLayers.push(featureLayer);\r\n        if (this._origin) {\r\n            featureLayer.transform(this._origin, this._zoom);\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    removeFeatureLayer(featureLayer) {\r\n        const index = this._featureLayers.findIndex(layer => layer.id == featureLayer.id);\r\n        if (index != -1) {\r\n            this._featureLayers.splice(index, 1);\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    clearFeatureLayers() {\r\n        if (this._featureLayers.length > 0) {\r\n            this._featureLayers = [];\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    addRasterLayer(rasterLayer) {\r\n        this._rasterLayers.push(rasterLayer);\r\n        if (this._origin) {\r\n            rasterLayer.transform(this._origin, this._zoom);\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    removeRasterLayer(rasterLayer) {\r\n        const index = this._rasterLayers.findIndex(layer => layer.id == rasterLayer.id);\r\n        if (index != -1) {\r\n            this._rasterLayers.splice(index, 1);\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    clearRasterLayers() {\r\n        if (this._rasterLayers.length > 0) {\r\n            this._rasterLayers = [];\r\n            this._updateGeometry();\r\n        }\r\n    }\r\n    _draw() {\r\n        if (this._ctx) {\r\n            let bounds = this._redrawBounds;\r\n            this._ctx.save();\r\n            if (bounds) {\r\n                var size = bounds.getSize();\r\n                this._ctx.beginPath();\r\n                this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\r\n                this._ctx.clip();\r\n            }\r\n            this._drawing = true;\r\n            // console.time(\"draw\");\r\n            this._rasterLayers.forEach(layer => {\r\n                layer.draw(this._ctx, this._zoom, bounds || this._bounds);\r\n            });\r\n            this._featureLayers.forEach(layer => {\r\n                layer.draw(this._ctx, this._zoom, bounds || this._bounds);\r\n            });\r\n            this._graphicLayers.forEach(layer => {\r\n                layer.draw(this._ctx, this._zoom, bounds || this._bounds);\r\n            });\r\n            this._graphicLayer.draw(this._ctx, this._zoom, bounds || this._bounds);\r\n            // console.timeEnd(\"draw\");\r\n            this._drawing = false;\r\n            this._ctx.restore(); // Restore state before clipping.\r\n        }\r\n    }\r\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\r\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\r\n    _onClick(e) {\r\n        let screenXY = this._map.mouseEventToCanvasPixel(e);\r\n        // spatial query graphic && feature\r\n        let elements = this._graphicLayer.query(screenXY, this._zoom, this._bounds);\r\n        this._graphicLayers.forEach(layer => {\r\n            elements = elements.concat(layer.query(screenXY, this._zoom, this._bounds));\r\n        });\r\n        this._featureLayers.forEach(layer => {\r\n            elements = elements.concat(layer.query(screenXY, this._zoom, this._bounds));\r\n        });\r\n        if (elements.length > 0) {\r\n            DomEvent.fakeStop(e);\r\n            this._fireEvent(elements, e);\r\n        }\r\n    }\r\n    _onMouseMove(e) {\r\n        if (!this._map || !this._map.dragging || this._map.dragging.moving() || this._map._animatingZoom) {\r\n            return;\r\n        }\r\n        const point = this._map.mouseEventToCanvasPixel(e);\r\n        this._handleMouseHover(e, point);\r\n    }\r\n    _handleMouseOut(e) {\r\n        if (this._hoveredElement) {\r\n            // if we're leaving, fire mouseout\r\n            DomUtil.removeClass(this._container, 'leaflet-interactive');\r\n            this._fireEvent([this._hoveredElement], e, 'mouseout');\r\n            this._hoveredElement = null;\r\n            this._mouseHoverThrottled = false;\r\n        }\r\n    }\r\n    _handleMouseHover(e, screenXY) {\r\n        if (this._mouseHoverThrottled) {\r\n            return;\r\n        }\r\n        // spatial query graphic && feature\r\n        let elements = this._graphicLayer.query(screenXY, this._zoom, this._bounds);\r\n        this._graphicLayers.forEach(layer => {\r\n            elements = elements.concat(layer.query(screenXY, this._zoom, this._bounds));\r\n        });\r\n        this._featureLayers.forEach(layer => {\r\n            elements = elements.concat(layer.query(screenXY, this._zoom, this._bounds));\r\n        });\r\n        let candidateHoveredElement = elements.length > 0 ? elements[0] : null;\r\n        if (candidateHoveredElement !== this._hoveredElement) {\r\n            this._handleMouseOut(e);\r\n            if (candidateHoveredElement) {\r\n                DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor\r\n                this._fireEvent([candidateHoveredElement], e, 'mouseover');\r\n                this._hoveredElement = candidateHoveredElement;\r\n            }\r\n        }\r\n        if (this._hoveredElement) {\r\n            this._fireEvent([this._hoveredElement], e);\r\n        }\r\n        // throttle \r\n        this._mouseHoverThrottled = true;\r\n        setTimeout(() => {\r\n            this._mouseHoverThrottled = false;\r\n        }, 32);\r\n    }\r\n    _fireEvent(layers, e, type) {\r\n        this._map._fireDOMEvent(e, type || e.type, layers);\r\n    }\r\n}\r\n","import { HandlerObject } from '../../base/handler-object';\r\n/*\r\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\r\n */\r\nexport class DoubleClickZoomHandler extends HandlerObject {\r\n    addHooks() {\r\n        this._map.on('dblclick', this._onDoubleClick, this);\r\n    }\r\n    removeHooks() {\r\n        this._map.off('dblclick', this._onDoubleClick, this);\r\n    }\r\n    _onDoubleClick(e) {\r\n        var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\r\n        if (map.options.doubleClickZoom === 'center') {\r\n            map.setZoom(zoom);\r\n        }\r\n        else {\r\n            map.setZoomAround(e.containerPixel, zoom);\r\n        }\r\n    }\r\n}\r\n","import * as Util from '../../util/util';\r\nimport * as DomUtil from '../../util/dom-util';\r\nimport { HandlerObject } from '../../base/handler-object';\r\nimport { DraggableObject } from '../../base/draggable-object';\r\nimport { ScreenXY } from '../../common/screen-xy';\r\nimport { ScreenBounds } from '../../common/screen-bounds';\r\nimport { LatLng } from '../../common/latlng';\r\nexport class DragHandler extends HandlerObject {\r\n    addHooks() {\r\n        if (!this._draggable) {\r\n            var map = this._map;\r\n            this._draggable = new DraggableObject(map._mapPane, map._container);\r\n            this._draggable.on({\r\n                dragstart: this._onDragStart,\r\n                drag: this._onDrag,\r\n                dragend: this._onDragEnd\r\n            }, this);\r\n            this._draggable.on('predrag', this._onPreDragLimit, this);\r\n            if (map.options.worldCopyJump) {\r\n                this._draggable.on('predrag', this._onPreDragWrap, this);\r\n                map.on('zoomend', this._onZoomEnd, this);\r\n                map.whenReady(this._onZoomEnd, this);\r\n            }\r\n        }\r\n        DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\r\n        this._draggable.enable();\r\n        this._positions = [];\r\n        this._times = [];\r\n    }\r\n    removeHooks() {\r\n        DomUtil.removeClass(this._map._container, 'leaflet-grab');\r\n        DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');\r\n        this._draggable.disable();\r\n    }\r\n    moved() {\r\n        return this._draggable && this._draggable._moved;\r\n    }\r\n    moving() {\r\n        return this._draggable && this._draggable._moving;\r\n    }\r\n    _onDragStart() {\r\n        var map = this._map;\r\n        map._stop();\r\n        if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\r\n            var bounds = this._map.options.maxBounds;\r\n            this._offsetLimit = new ScreenBounds(this._map.latLngToContainerPixel(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPixel(bounds.getSouthEast()).multiplyBy(-1)\r\n                .add(this._map.getSize()));\r\n            this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\r\n        }\r\n        else {\r\n            this._offsetLimit = null;\r\n        }\r\n        map\r\n            .fire('movestart')\r\n            .fire('dragstart');\r\n        if (map.options.inertia) {\r\n            this._positions = [];\r\n            this._times = [];\r\n        }\r\n    }\r\n    _onDrag(e) {\r\n        if (this._map.options.inertia) {\r\n            var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\r\n            this._positions.push(pos);\r\n            this._times.push(time);\r\n            this._prunePositions(time);\r\n        }\r\n        this._map\r\n            .fire('move', e)\r\n            .fire('drag', e);\r\n    }\r\n    _prunePositions(time) {\r\n        while (this._positions.length > 1 && time - this._times[0] > 50) {\r\n            this._positions.shift();\r\n            this._times.shift();\r\n        }\r\n    }\r\n    _onZoomEnd() {\r\n        var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToCanvasPixel(new LatLng(0, 0));\r\n        this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\r\n        this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\r\n    }\r\n    _viscousLimit(value, threshold) {\r\n        return value - (value - threshold) * this._viscosity;\r\n    }\r\n    _onPreDragLimit() {\r\n        if (!this._viscosity || !this._offsetLimit) {\r\n            return;\r\n        }\r\n        var offset = this._draggable._newPos.subtract(this._draggable._startPos);\r\n        var limit = this._offsetLimit;\r\n        if (offset.x < limit.min.x) {\r\n            offset.x = this._viscousLimit(offset.x, limit.min.x);\r\n        }\r\n        if (offset.y < limit.min.y) {\r\n            offset.y = this._viscousLimit(offset.y, limit.min.y);\r\n        }\r\n        if (offset.x > limit.max.x) {\r\n            offset.x = this._viscousLimit(offset.x, limit.max.x);\r\n        }\r\n        if (offset.y > limit.max.y) {\r\n            offset.y = this._viscousLimit(offset.y, limit.max.y);\r\n        }\r\n        this._draggable._newPos = this._draggable._startPos.add(offset);\r\n    }\r\n    _onPreDragWrap() {\r\n        // TODO refactor to be able to adjust map pane position after zoom\r\n        var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\r\n        this._draggable._absPos = this._draggable._newPos.clone();\r\n        this._draggable._newPos.x = newX;\r\n    }\r\n    _onDragEnd(e) {\r\n        var map = this._map, options = map.options, noInertia = !options.inertia || this._times.length < 2;\r\n        map.fire('dragend', e);\r\n        if (noInertia) {\r\n            map.fire('moveend');\r\n        }\r\n        else {\r\n            this._prunePositions(+new Date());\r\n            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1000, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo(new ScreenXY(0, 0)), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\r\n            if (!offset.x && !offset.y) {\r\n                map.fire('moveend');\r\n            }\r\n            else {\r\n                offset = map._limitOffset(offset, map.options.maxBounds);\r\n                Util.requestAnimFrame(function () {\r\n                    map.panBy(offset, {\r\n                        duration: decelerationDuration,\r\n                        easeLinearity: ease,\r\n                        noMoveStart: true,\r\n                        animate: true\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n// @section Handlers\r\n// @property dragging: Handler\r\n// Map dragging handler (by both mouse and touch).\r\n// Map.addInitHook('addHandler', 'dragging', Drag);\r\n","import * as DomEvent from '../../util/dom-event';\r\nimport { HandlerObject } from '../../base/handler-object';\r\n/*\r\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\r\n */\r\n// @namespace Map\r\n// @section Interaction Options\r\n// Map.mergeOptions({\r\n// \t// @section Mouse wheel options\r\n// \t// @option scrollWheelZoom: Boolean|String = true\r\n// \t// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\r\n// \t// it will zoom to the center of the view regardless of where the mouse was.\r\n// \tscrollWheelZoom: true,\r\n// \t// @option wheelDebounceTime: Number = 40\r\n// \t// Limits the rate at which a wheel can fire (in milliseconds). By default\r\n// \t// user can't zoom via wheel more often than once per 40 ms.\r\n// \twheelDebounceTime: 40,\r\n// \t// @option wheelPxPerZoomLevel: Number = 60\r\n// \t// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\r\n// \t// mean a change of one full zoom level. Smaller values will make wheel-zooming\r\n// \t// faster (and vice versa).\r\n// \twheelPxPerZoomLevel: 60\r\n// });\r\nexport class ScrollWheelZoomHandler extends HandlerObject {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._delta = 0;\r\n    }\r\n    addHooks() {\r\n        DomEvent.on(this._map._container, 'wheel', this._onWheelScroll, this);\r\n        this._delta = 0;\r\n    }\r\n    removeHooks() {\r\n        DomEvent.off(this._map._container, 'wheel', this._onWheelScroll, this);\r\n    }\r\n    _onWheelScroll(e) {\r\n        var delta = DomEvent.getWheelDelta(e);\r\n        var debounce = this._map.options.wheelDebounceTime;\r\n        this._delta += delta;\r\n        this._lastMousePos = this._map.mouseEventToContainerPixel(e);\r\n        if (!this._startTime) {\r\n            this._startTime = +new Date();\r\n        }\r\n        var left = Math.max(debounce - (+new Date() - this._startTime), 0);\r\n        clearTimeout(this._timer);\r\n        this._timer = setTimeout(() => {\r\n            this._performZoom();\r\n        }, left);\r\n        DomEvent.stop(e);\r\n    }\r\n    _performZoom() {\r\n        var map = this._map, zoom = map.getZoom(), snap = this._map.options.zoomSnap || 0;\r\n        map._stop(); // stop panning and fly animations if any\r\n        // map the delta with a sigmoid function to -4..4 range leaning on -1..1\r\n        var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\r\n        this._delta = 0;\r\n        this._startTime = null;\r\n        if (!delta) {\r\n            return;\r\n        }\r\n        if (map.options.scrollWheelZoom === 'center') {\r\n            map.setZoom(zoom + delta);\r\n        }\r\n        else {\r\n            map.setZoomAround(this._lastMousePos, zoom + delta);\r\n        }\r\n    }\r\n}\r\n// @section Handlers\r\n// @property scrollWheelZoom: Handler\r\n// Scroll wheel zoom handler.\r\n// Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\r\n","import * as Util from '../util/util';\r\nimport * as Browser from '../util/browser';\r\nimport * as DomUtil from '../util/dom-util';\r\nimport * as DomEvent from '../util/dom-event';\r\nimport { EventedObject } from '../base/evented-object';\r\nimport { LatLng } from '../common/latlng';\r\nimport { LatLngBounds } from '../common/latlng-bounds';\r\nimport { ScreenBounds } from '../common/screen-bounds';\r\nimport { ScreenXY } from '../common/screen-xy';\r\nimport { EPSG3857 } from '../crs/crs-3857';\r\nimport { PosAnimation } from './position-animation';\r\nimport { DragHandler } from './handler/map-drag';\r\nimport { ScrollWheelZoomHandler } from './handler/map-scrollwheelzoom';\r\nimport { DoubleClickZoomHandler } from './handler/map-doubleclickzoom';\r\nimport { OptionsObject } from '../base/options-object';\r\nimport { Viewer } from './canvas/viewer';\r\nimport { Animater } from './canvas/animater';\r\n// import { Layer } from '../layer/layer';\r\n/*\r\n * @class Map\r\n * @aka L.Map\r\n * @inherits Evented\r\n *\r\n * The central class of the API — it is used to create a map on a page and manipulate it.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * // initialize the map on the \"map\" div with a given center and zoom\r\n * var map = L.map('map', {\r\n * \tcenter: [51.505, -0.09],\r\n * \tzoom: 13\r\n * });\r\n * ```\r\n *\r\n */\r\nexport class MapOptions extends OptionsObject {\r\n    constructor() {\r\n        // @section Map State Options\r\n        // @option crs: CRS = L.CRS.EPSG3857\r\n        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\r\n        // sure what it means.\r\n        // crs: Earth = new EPSG3857();\r\n        super(...arguments);\r\n        // @option center: LatLng = undefined\r\n        // Initial geographic center of the map\r\n        this.center = undefined;\r\n        // @option zoom: Number = undefined\r\n        // Initial map zoom level\r\n        this.zoom = undefined;\r\n        // @option minZoom: Number = *\r\n        // Minimum zoom level of the map.\r\n        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n        // the lowest of their `minZoom` options will be used instead.\r\n        this.minZoom = 1;\r\n        // @option maxZoom: Number = *\r\n        // Maximum zoom level of the map.\r\n        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n        // the highest of their `maxZoom` options will be used instead.\r\n        this.maxZoom = 20;\r\n        // @section Animation Options\r\n        // @option zoomAnimation: Boolean = true\r\n        // Whether the map zoom animation is enabled. By default it's enabled\r\n        // in all browsers that support CSS3 Transitions except Android.\r\n        this.zoomAnimation = true;\r\n        // @option zoomAnimationThreshold: Number = 4\r\n        // Won't animate zoom if the zoom difference exceeds this value.\r\n        this.zoomAnimationThreshold = 4;\r\n        // @option fadeAnimation: Boolean = true\r\n        // Whether the tile fade animation is enabled. By default it's enabled\r\n        // in all browsers that support CSS3 Transitions except Android.\r\n        this.fadeAnimation = true;\r\n        // @option markerZoomAnimation: Boolean = true\r\n        // Whether markers animate their zoom with the zoom animation, if disabled\r\n        // they will disappear for the length of the animation. By default it's\r\n        // enabled in all browsers that support CSS3 Transitions except Android.\r\n        this.markerZoomAnimation = true;\r\n        // @option transform3DLimit: Number = 2^23\r\n        // Defines the maximum size of a CSS translation transform. The default\r\n        // value should not be changed unless a web browser positions layers in\r\n        // the wrong place after doing a large `panBy`.\r\n        this.transform3DLimit = 8388608; // Precision limit of a 32-bit float\r\n        // @section Interaction Options\r\n        // @option zoomSnap: Number = 1\r\n        // Forces the map's zoom level to always be a multiple of this, particularly\r\n        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\r\n        // By default, the zoom level snaps to the nearest integer; lower values\r\n        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\r\n        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\r\n        this.zoomSnap = 1;\r\n        // @option zoomDelta: Number = 1\r\n        // Controls how much the map's zoom level will change after a\r\n        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\r\n        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\r\n        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\r\n        this.zoomDelta = 1;\r\n        // @option trackResize: Boolean = true\r\n        // Whether the map automatically handles browser window resize to update itself.\r\n        this.trackResize = true;\r\n        // @section Mouse wheel options\r\n        // @option scrollWheelZoom: Boolean|String = true\r\n        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\r\n        // it will zoom to the center of the view regardless of where the mouse was.\r\n        this.scrollWheelZoom = true;\r\n        // @option wheelDebounceTime: Number = 40\r\n        // Limits the rate at which a wheel can fire (in milliseconds). By default\r\n        // user can't zoom via wheel more often than once per 40 ms.\r\n        this.wheelDebounceTime = 40;\r\n        // @option wheelPxPerZoomLevel: Number = 60\r\n        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\r\n        // mean a change of one full zoom level. Smaller values will make wheel-zooming\r\n        // faster (and vice versa).\r\n        this.wheelPxPerZoomLevel = 60;\r\n        // @option dragging: Boolean = true\r\n        // Whether the map be draggable with mouse/touch or not.\r\n        this.dragging = true;\r\n        // @section Panning Inertia Options\r\n        // @option inertia: Boolean = *\r\n        // If enabled, panning of the map will have an inertia effect where\r\n        // the map builds momentum while dragging and continues moving in\r\n        // the same direction for some time. Feels especially nice on touch\r\n        // devices. Enabled by default unless running on old Android devices.\r\n        this.inertia = !Browser.android23;\r\n        // @option inertiaDeceleration: Number = 3000\r\n        // The rate with which the inertial movement slows down, in pixels/second².\r\n        this.inertiaDeceleration = 3400; // px/s^2\r\n        // @option inertiaMaxSpeed: Number = Infinity\r\n        // Max speed of the inertial movement, in pixels/second.\r\n        this.inertiaMaxSpeed = Infinity; // px/s\r\n        // @option easeLinearity: Number = 0.2\r\n        this.easeLinearity = 0.2;\r\n        // TODO refactor, move to CRS\r\n        // @option worldCopyJump: Boolean = false\r\n        // With this option enabled, the map tracks when you pan to another \"copy\"\r\n        // of the world and seamlessly jumps to the original one so that all overlays\r\n        // like markers and vector layers are still visible.\r\n        this.worldCopyJump = false;\r\n        // @option maxBoundsViscosity: Number = 0.0\r\n        // If `maxBounds` is set, this option will control how solid the bounds\r\n        // are when dragging the map around. The default value of `0.0` allows the\r\n        // user to drag outside the bounds at normal speed, higher values will\r\n        // slow down map dragging outside bounds, and `1.0` makes the bounds fully\r\n        // solid, preventing the user from dragging outside the bounds.\r\n        this.maxBounds = undefined;\r\n        this.maxBoundsViscosity = 0.0;\r\n        // @option doubleClickZoom: Boolean|String = true\r\n        // Whether the map can be zoomed in by double clicking on it and\r\n        // zoomed out by double clicking while holding shift. If passed\r\n        // `'center'`, double-click zoom will zoom to the center of the\r\n        //  view regardless of where the mouse was.\r\n        this.doubleClickZoom = true;\r\n    }\r\n}\r\nexport class Map extends EventedObject {\r\n    constructor(id, options) {\r\n        super();\r\n        this.options = new MapOptions();\r\n        this._loaded = false;\r\n        // container size changed\r\n        this._sizeChanged = true;\r\n        this._panes = {};\r\n        this._paneRenderers = {};\r\n        // event target\r\n        this._targets = {};\r\n        this._layers = {};\r\n        this._fadeAnimated = true;\r\n        this._zoomAnimated = true;\r\n        // handlers\r\n        this._handlers = [];\r\n        this._mouseEvents = ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'];\r\n        this.options.assign(options);\r\n        // Make sure to assign internal flags at the beginning,\r\n        // to avoid inconsistent state in some edge cases.\r\n        this._layers = {};\r\n        this._initContainer(id);\r\n        this._initLayout();\r\n        // hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n        // this._onResize = Util.bind(this._onResize, this);\r\n        this._initEvents();\r\n        if (this.options.zoom !== undefined) {\r\n            this._zoom = this._limitZoom(this.options.zoom);\r\n        }\r\n        this._crs = new EPSG3857();\r\n        // this._canvas = new Canvas(this);\r\n        // this._canvas.init();\r\n        this._animater = new Animater(this);\r\n        this._animater.init();\r\n        this._viewer = new Viewer(this);\r\n        this._viewer.init();\r\n        if (this.options.center && this.options.zoom !== undefined) {\r\n            this.setView(this.options.center, this.options.zoom, { reset: true });\r\n        }\r\n        // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\r\n        this._zoomAnimated = DomUtil.TRANSITION && Browser.any3d && !Browser.mobileOpera &&\r\n            this.options.zoomAnimation;\r\n        // zoom transitions run with the same duration for all layers, so if one of transitionend events\r\n        // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\r\n        if (this._zoomAnimated) {\r\n            this._createAnimProxy();\r\n            DomEvent.on(this._proxy, DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\r\n        }\r\n        if (this.options.dragging)\r\n            this.addHandler('dragging', new DragHandler(this));\r\n        if (this.options.scrollWheelZoom)\r\n            this.addHandler('scrollWheelZoom', new ScrollWheelZoomHandler(this));\r\n        if (this.options.doubleClickZoom)\r\n            this.addHandler('doubleClickZoom', new DoubleClickZoomHandler(this));\r\n    }\r\n    get loaded() {\r\n        return this._loaded;\r\n    }\r\n    // @section Methods for modifying map state\r\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\r\n    // Sets the view of the map (geographical center and zoom) with the given\r\n    // animation options.\r\n    setView(center, zoom, options) {\r\n        zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\r\n        center = this._limitCenter(center, zoom, this.options.maxBounds);\r\n        options = options || {};\r\n        this._stop();\r\n        if (this._loaded && !options.reset && options !== true) {\r\n            if (options.animate !== undefined) {\r\n                options.zoom = Object.assign({ animate: options.animate }, options.zoom);\r\n                options.pan = Object.assign({ animate: options.animate, duration: options.duration }, options.pan);\r\n            }\r\n            // try animating pan or zoom\r\n            const moved = (this._zoom !== zoom) ?\r\n                this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\r\n                this._tryAnimatedPan(center, options.pan);\r\n            if (moved) {\r\n                // prevent resize handler call, the view will refresh after animation anyway\r\n                clearTimeout(this._sizeTimer);\r\n                return this;\r\n            }\r\n        }\r\n        // animation didn't start, just reset the map view\r\n        this._resetView(center, zoom);\r\n        return this;\r\n    }\r\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\r\n    // Sets the zoom of the map.\r\n    setZoom(zoom, options) {\r\n        if (!this._loaded) {\r\n            this._zoom = zoom;\r\n            return this;\r\n        }\r\n        return this.setView(this.getCenter(), zoom, { zoom: options });\r\n    }\r\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\r\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n    zoomIn(delta, options) {\r\n        delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n        return this.setZoom(this._zoom + delta, options);\r\n    }\r\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\r\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n    zoomOut(delta, options) {\r\n        delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n        return this.setZoom(this._zoom - delta, options);\r\n    }\r\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\r\n    // Zooms the map while keeping a specified geographical point on the map\r\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\r\n    // @alternative\r\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\r\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\r\n    setZoomAround(specified, zoom, options) {\r\n        var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = specified instanceof ScreenXY ? specified : this.latLngToContainerPixel(specified), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPixelToLatLng(viewHalf.add(centerOffset));\r\n        return this.setView(newCenter, zoom, { zoom: options });\r\n    }\r\n    _getLatLngBoundsCenterZoom(bounds, options) {\r\n        options = options || {};\r\n        // bounds = bounds.getBounds ? bounds.getBounds() : bounds;\r\n        // pixel\r\n        const paddingTL = new ScreenXY(options.padding || 0, options.padding || 0), paddingBR = new ScreenXY(options.padding || 0, options.padding || 0);\r\n        let zoom = this.getLatLngBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n        zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\r\n        if (zoom === Infinity) {\r\n            return {\r\n                center: bounds.getCenter(),\r\n                zoom: zoom\r\n            };\r\n        }\r\n        const paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.latLngToWorldPixel(bounds.getSouthWest(), zoom), nePoint = this.latLngToWorldPixel(bounds.getNorthEast(), zoom), center = this.worldPixelToLatLng(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n        return {\r\n            center: center,\r\n            zoom: zoom\r\n        };\r\n    }\r\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n    // Sets a map view that contains the given geographical bounds with the\r\n    // maximum zoom level possible.\r\n    fitBounds(bounds, options) {\r\n        const target = this._getLatLngBoundsCenterZoom(bounds, options);\r\n        return this.setView(target.center, target.zoom, options);\r\n    }\r\n    // @method fitWorld(options?: fitBounds options): this\r\n    // Sets a map view that mostly contains the whole world with the maximum\r\n    // zoom level possible.\r\n    fitWorld(options) {\r\n        return this.fitBounds(new LatLngBounds(new LatLng(-90, -180), new LatLng(90, 180)), options);\r\n    }\r\n    // @method panTo(latlng: LatLng, options?: Pan options): this\r\n    // Pans the map to a given center.\r\n    panTo(center, options) {\r\n        return this.setView(center, this._zoom, { pan: options });\r\n    }\r\n    // @method panBy(offset: Point, options?: Pan options): this\r\n    // Pans the map by a given number of pixels (animated).\r\n    panBy(offset, options) {\r\n        offset = offset.round();\r\n        options = options || {};\r\n        if (!offset.x && !offset.y) {\r\n            return this.fire('moveend');\r\n        }\r\n        // If we pan too far, Chrome gets issues with tiles\r\n        // and makes them disappear or appear in the wrong place (slightly offset) #2602\r\n        if (options.animate !== true && !this.getSize().contains(offset)) {\r\n            this._resetView(this.worldPixelToLatLng(this.latLngToWorldPixel(this.getCenter()).add(offset)), this.getZoom());\r\n            return this;\r\n        }\r\n        if (!this._panAnim) {\r\n            this._panAnim = new PosAnimation(this._mapPane);\r\n            this._panAnim.on({\r\n                'step': this._onPanTransitionStep,\r\n                'end': this._onPanTransitionEnd\r\n            }, this);\r\n        }\r\n        // don't fire movestart if animating inertia\r\n        if (!options.noMoveStart) {\r\n            this.fire('movestart');\r\n        }\r\n        // animate pan unless animate: false specified\r\n        if (options.animate !== false) {\r\n            DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\r\n            const newPos = this._getMapPanePos().subtract(offset).round();\r\n            this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\r\n        }\r\n        else {\r\n            this._rawPanBy(offset);\r\n            this.fire('move').fire('moveend');\r\n        }\r\n        return this;\r\n    }\r\n    // @method setMinZoom(zoom: Number): this\r\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\r\n    setMinZoom(zoom) {\r\n        var oldZoom = this.options.minZoom;\r\n        this.options.minZoom = zoom;\r\n        if (this._loaded && oldZoom !== zoom) {\r\n            this.fire('zoomlevelschange');\r\n            if (this.getZoom() < this.options.minZoom) {\r\n                return this.setZoom(zoom);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    // @method setMaxZoom(zoom: Number): this\r\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\r\n    setMaxZoom(zoom) {\r\n        var oldZoom = this.options.maxZoom;\r\n        this.options.maxZoom = zoom;\r\n        if (this._loaded && oldZoom !== zoom) {\r\n            this.fire('zoomlevelschange');\r\n            if (this.getZoom() > this.options.maxZoom) {\r\n                return this.setZoom(zoom);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    // @method invalidateSize(options: Zoom/pan options): this\r\n    // Checks if the map container size changed and updates the map if so —\r\n    // call it after you've changed the map size dynamically, also animating\r\n    // pan by default. If `options.pan` is `false`, panning will not occur.\r\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\r\n    // that it doesn't happen often even if the method is called many\r\n    // times in a row.\r\n    // @alternative\r\n    // @method invalidateSize(animate: Boolean): this\r\n    // Checks if the map container size changed and updates the map if so —\r\n    // call it after you've changed the map size dynamically, also animating\r\n    // pan by default.\r\n    invalidateSize(options) {\r\n        if (!this._loaded) {\r\n            return this;\r\n        }\r\n        options = Object.assign({\r\n            animate: false,\r\n            pan: true\r\n        }, options === true ? { animate: true } : options);\r\n        const oldSize = this.getSize();\r\n        this._sizeChanged = true;\r\n        this._lastCenter = null;\r\n        const newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);\r\n        if (!offset.x && !offset.y) {\r\n            return this;\r\n        }\r\n        if (options.animate && options.pan) {\r\n            this.panBy(offset);\r\n        }\r\n        else {\r\n            if (options.pan) {\r\n                this._rawPanBy(offset);\r\n            }\r\n            this.fire('move');\r\n            if (options.debounceMoveend) {\r\n                clearTimeout(this._sizeTimer);\r\n                this._sizeTimer = setTimeout(() => {\r\n                    this.fire('moveend');\r\n                }, 200);\r\n            }\r\n            else {\r\n                this.fire('moveend');\r\n            }\r\n        }\r\n        // @section Map state change events\r\n        // @event resize: ResizeEvent\r\n        // Fired when the map is resized.\r\n        return this.fire('resize', {\r\n            oldSize: oldSize,\r\n            newSize: newSize\r\n        });\r\n    }\r\n    // @section Methods for modifying map state\r\n    // @method stop(): this\r\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\r\n    stop() {\r\n        this.setZoom(this._limitZoom(this._zoom));\r\n        if (!this.options.zoomSnap) {\r\n            this.fire('viewreset');\r\n        }\r\n        return this._stop();\r\n    }\r\n    // @method remove(): this\r\n    // Destroys the map and clears all related event listeners.\r\n    remove() {\r\n        this._initEvents(true);\r\n        this._stop();\r\n        // this._canvas.destroy();\r\n        this._viewer.destroy();\r\n        this._animater.destroy();\r\n        DomUtil.remove(this._mapPane);\r\n        if (this._resizeRequest) {\r\n            Util.cancelAnimFrame(this._resizeRequest);\r\n            this._resizeRequest = null;\r\n        }\r\n        this.clearHandlers();\r\n        if (this._loaded) {\r\n            // @section Map state change events\r\n            // @event unload: Event\r\n            // Fired when the map is destroyed with [remove](#map-remove) method.\r\n            this.fire('unload');\r\n        }\r\n        for (let i in this._layers) {\r\n            this._layers[i].remove();\r\n        }\r\n        for (let i in this._panes) {\r\n            DomUtil.remove(this._panes[i]);\r\n        }\r\n        this._layers = {};\r\n        this._panes = {};\r\n        delete this._mapPane;\r\n        // delete this._canvas;\r\n        delete this._viewer;\r\n        delete this._animater;\r\n        return this;\r\n    }\r\n    // @section Other Methods\r\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\r\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\r\n    // then returns it. The pane is created as a child of `container`, or\r\n    // as a child of the main map pane if not set.\r\n    createPane(name, container) {\r\n        const className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''), pane = DomUtil.create('div', className, container || this._mapPane);\r\n        if (name) {\r\n            this._panes[name] = pane;\r\n        }\r\n        return pane;\r\n    }\r\n    // @section Methods for Getting Map State\r\n    // @method getCenter(): LatLng\r\n    // Returns the geographical center of the map view\r\n    getCenter() {\r\n        if (this._lastCenter && !this._moved()) {\r\n            return this._lastCenter;\r\n        }\r\n        return this.canvasPixelToLatLng(this._getCenterCanvasPixel());\r\n    }\r\n    // @method getZoom(): Number\r\n    // Returns the current zoom level of the map view\r\n    getZoom() {\r\n        return this._zoom;\r\n    }\r\n    // @method getBounds(): LatLngBounds\r\n    // Returns the geographical bounds visible in the current map view\r\n    getLatLngBounds() {\r\n        const bounds = this.getPixelBounds(), sw = this.worldPixelToLatLng(bounds.getBottomLeft()), ne = this.worldPixelToLatLng(bounds.getTopRight());\r\n        return new LatLngBounds(sw, ne);\r\n    }\r\n    // @method getMinZoom(): Number\r\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\r\n    getMinZoom() {\r\n        return this.options.minZoom === undefined ? 1 : this.options.minZoom;\r\n    }\r\n    // @method getMaxZoom(): Number\r\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\r\n    getMaxZoom() {\r\n        return this.options.maxZoom === undefined ? 20 : this.options.maxZoom;\r\n    }\r\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\r\n    // Returns the maximum zoom level on which the given bounds fit to the map\r\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\r\n    // instead returns the minimum zoom level on which the map view fits into\r\n    // the given bounds in its entirety.\r\n    getLatLngBoundsZoom(bounds, inside = false, padding = new ScreenXY()) {\r\n        let zoom = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = new ScreenBounds(this.latLngToWorldPixel(se, zoom), this.latLngToWorldPixel(nw, zoom)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\r\n        zoom = this.getScaleZoom(scale, zoom);\r\n        if (snap) {\r\n            zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\r\n            zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\r\n        }\r\n        return Math.max(min, Math.min(max, zoom));\r\n    }\r\n    // @method getSize(): Point\r\n    // Returns the current size of the map container (in pixels).\r\n    getSize() {\r\n        if (!this._size || this._sizeChanged) {\r\n            this._size = new ScreenXY(this._container.clientWidth || 0, this._container.clientHeight || 0);\r\n            this._sizeChanged = false;\r\n        }\r\n        return this._size.clone();\r\n    }\r\n    // @method getPixelBounds(): Bounds\r\n    // Returns the bounds of the current map view in projected pixel\r\n    // coordinates (sometimes useful in layer and overlay implementations).\r\n    getPixelBounds(center, zoom) {\r\n        const topLeftPoint = this._getTopLeftPixel(center, zoom);\r\n        return new ScreenBounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n    }\r\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\r\n    // the map pane? \"left point of the map layer\" can be confusing, specially\r\n    // since there can be negative offsets.\r\n    // @method getPixelOrigin(): Point\r\n    // Returns the projected pixel coordinates of the top left point of\r\n    // the map layer (useful in custom layer and overlay implementations).\r\n    getPixelOrigin() {\r\n        return this._pixelOrigin;\r\n    }\r\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\r\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\r\n    // If `zoom` is omitted, the map's current zoom level is used.\r\n    getPixelWorldBounds(zoom) {\r\n        return this._crs.getScreenBounds(zoom === undefined ? this.getZoom() : zoom);\r\n    }\r\n    // @section Other Methods\r\n    // @method getPane(pane: String|HTMLElement): HTMLElement\r\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\r\n    getPane(pane) {\r\n        return typeof pane === 'string' ? this._panes[pane] : pane;\r\n    }\r\n    // @method getPanes(): Object\r\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\r\n    // the panes as values.\r\n    getPanes() {\r\n        return this._panes;\r\n    }\r\n    // @method getContainer: HTMLElement\r\n    // Returns the HTML element that contains the map.\r\n    getContainer() {\r\n        return this._container;\r\n    }\r\n    // @section Conversion Methods\r\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\r\n    // Returns the scale factor to be applied to a map transition from zoom level\r\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\r\n    getZoomScale(toZoom, fromZoom) {\r\n        // TODO replace with universal implementation after refactoring projections\r\n        fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n        return this._crs.scale(toZoom) / this._crs.scale(fromZoom);\r\n    }\r\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\r\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\r\n    // level and everything is scaled by a factor of `scale`. Inverse of\r\n    // [`getZoomScale`](#map-getZoomScale).\r\n    getScaleZoom(scale, fromZoom) {\r\n        fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n        const zoom = this._crs.zoom(scale * this._crs.scale(fromZoom));\r\n        return isNaN(zoom) ? Infinity : zoom;\r\n    }\r\n    // @method project(latlng: LatLng, zoom: Number): Point\r\n    // Projects a geographical coordinate `LatLng` according to the projection\r\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\r\n    // `Transformation`. The result is pixel coordinate relative to\r\n    // the CRS origin.\r\n    latLngToWorldPixel(latlng, zoom) {\r\n        zoom = zoom === undefined ? this._zoom : zoom;\r\n        return this._crs.latLngToScreenXY(latlng, zoom);\r\n    }\r\n    // @method unproject(point: Point, zoom: Number): LatLng\r\n    // Inverse of [`project`](#map-project).\r\n    worldPixelToLatLng(screenXY, zoom) {\r\n        zoom = zoom === undefined ? this._zoom : zoom;\r\n        return this._crs.screenXYToLatLng(screenXY, zoom);\r\n    }\r\n    // @method layerPointToLatLng(point: Point): LatLng\r\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n    // returns the corresponding geographical coordinate (for the current zoom level).\r\n    canvasPixelToLatLng(pixel) {\r\n        const absolute = pixel.add(this._pixelOrigin);\r\n        return this.worldPixelToLatLng(absolute);\r\n    }\r\n    // @method latLngToLayerPoint(latlng: LatLng): Point\r\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\r\n    // relative to the [origin pixel](#map-getpixelorigin).\r\n    latLngToCanvasPixel(latlng) {\r\n        const absolute = this.latLngToWorldPixel(latlng).round(false);\r\n        return absolute.subtract(this._pixelOrigin);\r\n    }\r\n    // @method wrapLatLng(latlng: LatLng): LatLng\r\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\r\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\r\n    // CRS's bounds.\r\n    // By default this means longitude is wrapped around the dateline so its\r\n    // value is between -180 and +180 degrees.\r\n    wrapLatLng(latlng) {\r\n        return this._crs.wrapLatLng(latlng);\r\n    }\r\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\r\n    // its center is within the CRS's bounds.\r\n    // By default this means the center longitude is wrapped around the dateline so its\r\n    // value is between -180 and +180 degrees, and the majority of the bounds\r\n    // overlaps the CRS's bounds.\r\n    wrapLatLngBounds(bounds) {\r\n        return this._crs.wrapLatLngBounds(bounds);\r\n    }\r\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n    // Returns the distance between two geographical coordinates according to\r\n    // the map's CRS. By default this measures distance in meters.\r\n    distance(latlng1, latlng2) {\r\n        return this._crs.distance(latlng1, latlng2);\r\n    }\r\n    // @method containerPointToLayerPoint(point: Point): Point\r\n    // Given a pixel coordinate relative to the map container, returns the corresponding\r\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\r\n    containerPixelToCanvasPixel(pixel) {\r\n        return pixel.subtract(this._getMapPanePos());\r\n    }\r\n    // @method layerPointToContainerPoint(point: Point): Point\r\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n    // returns the corresponding pixel coordinate relative to the map container.\r\n    canvasPixelToContainerPixel(pixel) {\r\n        return pixel.add(this._getMapPanePos());\r\n    }\r\n    // @method containerPointToLatLng(point: Point): LatLng\r\n    // Given a pixel coordinate relative to the map container, returns\r\n    // the corresponding geographical coordinate (for the current zoom level).\r\n    containerPixelToLatLng(pixel) {\r\n        return this.canvasPixelToLatLng(this.containerPixelToCanvasPixel(pixel));\r\n    }\r\n    // @method latLngToContainerPoint(latlng: LatLng): Point\r\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\r\n    // relative to the map container.\r\n    latLngToContainerPixel(latlng) {\r\n        return this.canvasPixelToContainerPixel(this.latLngToCanvasPixel(latlng));\r\n    }\r\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\r\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\r\n    // map container where the event took place.\r\n    mouseEventToContainerPixel(e) {\r\n        return DomEvent.getMousePosition(e, this._container);\r\n    }\r\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\r\n    // Given a MouseEvent object, returns the pixel coordinate relative to\r\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\r\n    mouseEventToCanvasPixel(e) {\r\n        return this.containerPixelToCanvasPixel(this.mouseEventToContainerPixel(e));\r\n    }\r\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\r\n    // Given a MouseEvent object, returns geographical coordinate where the\r\n    // event took place.\r\n    mouseEventToLatLng(e) {\r\n        return this.canvasPixelToLatLng(this.mouseEventToCanvasPixel(e));\r\n    }\r\n    // map initialization methods\r\n    _initContainer(id) {\r\n        const container = DomUtil.get(id);\r\n        if (!container) {\r\n            throw new Error('Map container not found.');\r\n        }\r\n        else if (container._leaflet_id) {\r\n            throw new Error('Map container is already initialized.');\r\n        }\r\n        this._container = container;\r\n        DomEvent.on(container, 'scroll', this._onScroll, this);\r\n        this._containerId = Util.stamp(container);\r\n    }\r\n    _initLayout() {\r\n        const container = this._container;\r\n        this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\r\n        DomUtil.addClass(container, 'leaflet-container' +\r\n            (Browser.touch ? ' leaflet-touch' : '') +\r\n            (Browser.retina ? ' leaflet-retina' : '') +\r\n            (Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n            (Browser.safari ? ' leaflet-safari' : '') +\r\n            (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\r\n        const position = DomUtil.getStyle(container, 'position');\r\n        if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n            container.style.position = 'relative';\r\n        }\r\n        this._initPanes();\r\n    }\r\n    _initPanes() {\r\n        const panes = this._panes = {};\r\n        this._paneRenderers = {};\r\n        // @section\r\n        //\r\n        // Panes are DOM elements used to control the ordering of layers on the map. You\r\n        // can access panes with [`map.getPane`](#map-getpane) or\r\n        // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\r\n        // [`map.createPane`](#map-createpane) method.\r\n        //\r\n        // Every map has the following default panes that differ only in zIndex.\r\n        //\r\n        // @pane mapPane: HTMLElement = 'auto'\r\n        // Pane that contains all other map panes\r\n        this._mapPane = this.createPane('mapPane', this._container);\r\n        DomUtil.setPosition(this._mapPane, new ScreenXY(0, 0));\r\n        // @pane tilePane: HTMLElement = 200\r\n        // Pane for `GridLayer`s and `TileLayer`s\r\n        this.createPane('tilePane');\r\n        // @pane vtilePane: HTMLElement = 250\r\n        this.createPane('vtilePane');\r\n        // @pane animatePane: HTMLElement = 300\r\n        this.createPane('animatePane');\r\n        // @pane overlayPane: HTMLElement = 400\r\n        // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\r\n        this.createPane('overlayPane');\r\n        // @pane shadowPane: HTMLElement = 500\r\n        // Pane for overlay shadows (e.g. `Marker` shadows)\r\n        // this.createPane('shadowPane');\r\n        // @pane markerPane: HTMLElement = 600\r\n        // Pane for `Icon`s of `Marker`s\r\n        // this.createPane('markerPane');\r\n        // @pane tooltipPane: HTMLElement = 650\r\n        // Pane for `Tooltip`s.\r\n        this.createPane('tooltipPane');\r\n        // @pane popupPane: HTMLElement = 700\r\n        // Pane for `Popup`s.\r\n        this.createPane('popupPane');\r\n    }\r\n    // private methods that modify map state\r\n    // @section Map state change events\r\n    _resetView(center, zoom) {\r\n        DomUtil.setPosition(this._mapPane, new ScreenXY(0, 0));\r\n        const loading = !this._loaded;\r\n        this._loaded = true;\r\n        zoom = this._limitZoom(zoom);\r\n        this.fire('viewprereset');\r\n        const zoomChanged = this._zoom !== zoom;\r\n        this\r\n            ._moveStart(zoomChanged, false)\r\n            ._move(center, zoom)\r\n            ._moveEnd(zoomChanged);\r\n        // @event viewreset: Event\r\n        // Fired when the map needs to redraw its content (this usually happens\r\n        // on map zoom or load). Very useful for creating custom overlays.\r\n        this.fire('viewreset');\r\n        // @event load: Event\r\n        // Fired when the map is initialized (when its center and zoom are set\r\n        // for the first time).\r\n        if (loading) {\r\n            this.fire('load');\r\n        }\r\n    }\r\n    _moveStart(zoomChanged, noMoveStart) {\r\n        // @event zoomstart: Event\r\n        // Fired when the map zoom is about to change (e.g. before zoom animation).\r\n        // @event movestart: Event\r\n        // Fired when the view of the map starts changing (e.g. user starts dragging the map).\r\n        if (zoomChanged) {\r\n            this.fire('zoomstart');\r\n        }\r\n        if (!noMoveStart) {\r\n            this.fire('movestart');\r\n        }\r\n        return this;\r\n    }\r\n    _move(center, zoom, data) {\r\n        if (zoom === undefined) {\r\n            zoom = this._zoom;\r\n        }\r\n        const zoomChanged = this._zoom !== zoom;\r\n        this._zoom = zoom;\r\n        this._lastCenter = center;\r\n        this._pixelOrigin = this._getNewPixelOrigin(center);\r\n        // @event zoom: Event\r\n        // Fired repeatedly during any change in zoom level, including zoom\r\n        // and fly animations.\r\n        if (zoomChanged || (data && data.pinch)) { // Always fire 'zoom' if pinching because #3530\r\n            this.fire('zoom', data);\r\n        }\r\n        // @event move: Event\r\n        // Fired repeatedly during any movement of the map, including pan and\r\n        // fly animations.\r\n        return this.fire('move', data);\r\n    }\r\n    _moveEnd(zoomChanged) {\r\n        // @event zoomend: Event\r\n        // Fired when the map has changed, after any animations.\r\n        if (zoomChanged) {\r\n            this.fire('zoomend');\r\n        }\r\n        // @event moveend: Event\r\n        // Fired when the center of the map stops changing (e.g. user stopped\r\n        // dragging the map).\r\n        return this.fire('moveend');\r\n    }\r\n    _stop() {\r\n        if (this._panAnim) {\r\n            this._panAnim.stop();\r\n        }\r\n        return this;\r\n    }\r\n    _rawPanBy(offset) {\r\n        DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n    }\r\n    _getZoomSpan() {\r\n        return this.getMaxZoom() - this.getMinZoom();\r\n    }\r\n    // DOM event handling\r\n    // @section Interaction events\r\n    _initEvents(remove) {\r\n        this._targets = {};\r\n        this._targets[this._containerId] = this;\r\n        const onOff = remove ? DomEvent.off : DomEvent.on;\r\n        // @event click: MouseEvent\r\n        // Fired when the user clicks (or taps) the map.\r\n        // @event dblclick: MouseEvent\r\n        // Fired when the user double-clicks (or double-taps) the map.\r\n        // @event mousedown: MouseEvent\r\n        // Fired when the user pushes the mouse button on the map.\r\n        // @event mouseup: MouseEvent\r\n        // Fired when the user releases the mouse button on the map.\r\n        // @event mouseover: MouseEvent\r\n        // Fired when the mouse enters the map.\r\n        // @event mouseout: MouseEvent\r\n        // Fired when the mouse leaves the map.\r\n        // @event mousemove: MouseEvent\r\n        // Fired while the mouse moves over the map.\r\n        // @event contextmenu: MouseEvent\r\n        // Fired when the user pushes the right mouse button on the map, prevents\r\n        // default browser context menu from showing if there are listeners on\r\n        // this event. Also fired on mobile when the user holds a single touch\r\n        // for a second (also called long press).\r\n        // @event keypress: KeyboardEvent\r\n        // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\r\n        // @event keydown: KeyboardEvent\r\n        // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\r\n        // the `keydown` event is fired for keys that produce a character value and for keys\r\n        // that do not produce a character value.\r\n        // @event keyup: KeyboardEvent\r\n        // Fired when the user releases a key from the keyboard while the map is focused.\r\n        onOff(this._container, 'click dblclick mousedown mouseup ' +\r\n            'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\r\n        // onOff(this._container, 'click dblclick mousedown mouseup ' +\r\n        // \t'mouseover mouseout contextmenu keypress keydown keyup', this._handleDOMEvent, this);\r\n        if (this.options.trackResize) {\r\n            onOff(window, 'resize', this._onResize, this);\r\n        }\r\n        if (Browser.any3d && this.options.transform3DLimit) {\r\n            (remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\r\n        }\r\n    }\r\n    _onResize() {\r\n        Util.cancelAnimFrame(this._resizeRequest);\r\n        this._resizeRequest = Util.requestAnimFrame(() => {\r\n            this.invalidateSize({ debounceMoveend: true });\r\n        }, this);\r\n    }\r\n    _onScroll() {\r\n        this._container.scrollTop = 0;\r\n        this._container.scrollLeft = 0;\r\n    }\r\n    _onMoveEnd() {\r\n        const pos = this._getMapPanePos();\r\n        if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\r\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\r\n            // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\r\n            this._resetView(this.getCenter(), this.getZoom());\r\n        }\r\n    }\r\n    _findEventTargets(e, type) {\r\n        var targets = [], target, isHover = type === 'mouseout' || type === 'mouseover', src = e.target || e.srcElement, dragging = false;\r\n        while (src) {\r\n            target = this._targets[Util.stamp(src)];\r\n            if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {\r\n                // Prevent firing click after you just dragged an object.\r\n                dragging = true;\r\n                break;\r\n            }\r\n            if (target && target.listens(type, true)) {\r\n                if (isHover && !DomEvent.isExternalTarget(src, e)) {\r\n                    break;\r\n                }\r\n                targets.push(target);\r\n                if (isHover) {\r\n                    break;\r\n                }\r\n            }\r\n            if (src === this._container) {\r\n                break;\r\n            }\r\n            src = src.parentNode;\r\n        }\r\n        if (!targets.length && !dragging && !isHover && DomEvent.isExternalTarget(src, e)) {\r\n            targets = [this];\r\n        }\r\n        return targets;\r\n    }\r\n    _handleDOMEvent(e) {\r\n        if (!this._loaded || DomEvent.skipped(e)) {\r\n            return;\r\n        }\r\n        this._fireDOMEvent(e, e.type);\r\n    }\r\n    _fireDOMEvent(e, type, targets) {\r\n        if (e.type === 'click') {\r\n            // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\r\n            // @event preclick: MouseEvent\r\n            // Fired before mouse click on the map (sometimes useful when you\r\n            // want something to happen on click before any existing click\r\n            // handlers start running).\r\n            // var synth = Util.extend({}, e);\r\n            const synth = Object.assign({}, e);\r\n            synth.type = 'preclick';\r\n            this._fireDOMEvent(synth, synth.type, targets);\r\n        }\r\n        if (e._stopped) {\r\n            return;\r\n        }\r\n        // Find the layer the event is propagating from and its parents.\r\n        targets = (targets || []).concat(this._findEventTargets(e, type));\r\n        if (!targets.length) {\r\n            return;\r\n        }\r\n        var target = targets[0];\r\n        if (type === 'contextmenu' && target.listens(type, true)) {\r\n            DomEvent.preventDefault(e);\r\n        }\r\n        var data = {\r\n            originalEvent: e\r\n        };\r\n        if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\r\n            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\r\n            data.containerPixel = isMarker ?\r\n                this.latLngToContainerPixel(target.getLatLng()) : this.mouseEventToContainerPixel(e);\r\n            data.canvasPixel = this.containerPixelToCanvasPixel(data.containerPixel);\r\n            data.latlng = isMarker ? target.getLatLng() : this.canvasPixelToLatLng(data.canvasPixel);\r\n        }\r\n        for (let i = 0; i < targets.length; i++) {\r\n            targets[i].fire(type, data, true);\r\n            if (data.originalEvent._stopped || this._mouseEvents.indexOf(type) !== -1) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _draggableMoved(obj) {\r\n        obj = obj.dragging && obj.dragging.enabled() ? obj : this;\r\n        return obj.dragging && obj.dragging.moved();\r\n    }\r\n    // @section Other Methods\r\n    // @method whenReady(fn: Function, context?: Object): this\r\n    // Runs the given function `fn` when the map gets initialized with\r\n    // a view (center and zoom) and at least one layer, or immediately\r\n    // if it's already initialized, optionally passing a function context.\r\n    whenReady(callback, context) {\r\n        if (this._loaded) {\r\n            callback.call(context || this, { target: this });\r\n        }\r\n        else {\r\n            this.on('load', callback, context);\r\n        }\r\n        return this;\r\n    }\r\n    // private methods for getting map state\r\n    _getMapPanePos() {\r\n        return DomUtil.getPosition(this._mapPane) || new ScreenXY(0, 0);\r\n    }\r\n    _moved() {\r\n        const pos = this._getMapPanePos();\r\n        return pos && !pos.equals(new ScreenXY(0, 0));\r\n    }\r\n    _getTopLeftPixel(center, zoom) {\r\n        const pixelOrigin = center && zoom !== undefined ?\r\n            this._getNewPixelOrigin(center, zoom) :\r\n            this.getPixelOrigin();\r\n        return pixelOrigin.subtract(this._getMapPanePos());\r\n    }\r\n    _getNewPixelOrigin(center, zoom) {\r\n        const viewHalf = this.getSize().divideBy(2);\r\n        return this.latLngToWorldPixel(center, zoom).subtract(viewHalf).add(this._getMapPanePos()).round(false);\r\n    }\r\n    // layer point of the current center\r\n    _getCenterCanvasPixel() {\r\n        return this.containerPixelToCanvasPixel(this.getSize().divideBy(2));\r\n    }\r\n    // offset of the specified place to the current center in pixels\r\n    _getCenterOffset(latlng) {\r\n        return this.latLngToCanvasPixel(latlng).subtract(this._getCenterCanvasPixel());\r\n    }\r\n    // adjust center for view to get inside bounds\r\n    _limitCenter(center, zoom, bounds) {\r\n        if (!bounds) {\r\n            return center;\r\n        }\r\n        const centerPoint = this.latLngToWorldPixel(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new ScreenBounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n        // If offset is less than a pixel, ignore.\r\n        // This prevents unstable projections from getting into\r\n        // an infinite loop of tiny offsets.\r\n        if (offset.round().equals(new ScreenXY(0, 0))) {\r\n            return center;\r\n        }\r\n        return this.worldPixelToLatLng(centerPoint.add(offset), zoom);\r\n    }\r\n    // adjust offset for view to get inside bounds\r\n    _limitOffset(offset, bounds) {\r\n        if (!bounds) {\r\n            return offset;\r\n        }\r\n        const viewBounds = this.getPixelBounds(), newBounds = new ScreenBounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n        return offset.add(this._getBoundsOffset(newBounds, bounds));\r\n    }\r\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n    _getBoundsOffset(pxBounds, maxBounds, zoom) {\r\n        const projectedMaxBounds = new ScreenBounds(this.latLngToWorldPixel(maxBounds.getNorthEast(), zoom), this.latLngToWorldPixel(maxBounds.getSouthWest(), zoom)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);\r\n        return new ScreenXY(dx, dy);\r\n    }\r\n    _rebound(left, right) {\r\n        return left + right > 0 ?\r\n            Math.round(left - right) / 2 :\r\n            Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n    }\r\n    _limitZoom(zoom) {\r\n        let min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;\r\n        if (snap) {\r\n            zoom = Math.round(zoom / snap) * snap;\r\n        }\r\n        return Math.max(min, Math.min(max, zoom));\r\n    }\r\n    _onPanTransitionStep() {\r\n        this.fire('move');\r\n    }\r\n    _onPanTransitionEnd() {\r\n        DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\r\n        this.fire('moveend');\r\n    }\r\n    _tryAnimatedPan(center, options) {\r\n        // difference between the new and current centers in pixels\r\n        var offset = this._getCenterOffset(center).trunc(false);\r\n        // don't animate too far unless animate: true specified in options\r\n        if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\r\n            return false;\r\n        }\r\n        this.panBy(offset, options);\r\n        return true;\r\n    }\r\n    _createAnimProxy() {\r\n        const proxy = this._proxy = DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');\r\n        this._panes.mapPane.appendChild(proxy);\r\n        this.on('zoomanim', (e) => {\r\n            if (!DomUtil.TRANSFORM)\r\n                return;\r\n            const prop = DomUtil.TRANSFORM, transform = this._proxy.style[prop];\r\n            DomUtil.setTransform(this._proxy, this.latLngToWorldPixel(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\r\n            // workaround for case when transform is the same and so transitionend event is not fired\r\n            if (transform === this._proxy.style[prop] && this._animatingZoom) {\r\n                this._onZoomTransitionEnd();\r\n            }\r\n        });\r\n        this.on('load moveend', this._animMoveEnd, this);\r\n        this._on('unload', this._destroyAnimProxy, this);\r\n    }\r\n    _destroyAnimProxy() {\r\n        DomUtil.remove(this._proxy);\r\n        this.off('load moveend', this._animMoveEnd, this);\r\n        delete this._proxy;\r\n    }\r\n    _animMoveEnd() {\r\n        const c = this.getCenter(), z = this.getZoom();\r\n        DomUtil.setTransform(this._proxy, this.latLngToWorldPixel(c, z), this.getZoomScale(z, 1));\r\n        // console.log(c.lat, c.lng);\r\n    }\r\n    _catchTransitionEnd(e) {\r\n        if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\r\n            this._onZoomTransitionEnd();\r\n        }\r\n    }\r\n    _nothingToAnimate() {\r\n        return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\r\n    }\r\n    _tryAnimatedZoom(center, zoom, options) {\r\n        if (this._animatingZoom) {\r\n            return true;\r\n        }\r\n        options = options || {};\r\n        // don't animate if disabled, not supported or zoom difference is too large\r\n        if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\r\n            Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\r\n            return false;\r\n        }\r\n        // offset is the pixel coords of the zoom origin relative to the current center\r\n        const scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center).divideBy(1 - 1 / scale);\r\n        // don't animate if the zoom origin isn't within one screen from the current center, unless forced\r\n        if (options.animate !== true && !this.getSize().contains(offset)) {\r\n            return false;\r\n        }\r\n        Util.requestAnimFrame(() => {\r\n            this\r\n                ._moveStart(true, false)\r\n                ._animateZoom(center, zoom, true);\r\n        });\r\n        return true;\r\n    }\r\n    _animateZoom(center, zoom, startAnim, noUpdate) {\r\n        if (!this._mapPane) {\r\n            return;\r\n        }\r\n        if (startAnim) {\r\n            this._animatingZoom = true;\r\n            // remember what center/zoom to set after animation\r\n            this._animateToCenter = center;\r\n            this._animateToZoom = zoom;\r\n            DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\r\n        }\r\n        // @section Other Events\r\n        // @event zoomanim: ZoomAnimEvent\r\n        // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\r\n        this.fire('zoomanim', {\r\n            center: center,\r\n            zoom: zoom,\r\n            noUpdate: noUpdate\r\n        });\r\n        // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\r\n        setTimeout(() => {\r\n            this._onZoomTransitionEnd();\r\n        }, 250);\r\n    }\r\n    _onZoomTransitionEnd() {\r\n        if (!this._animatingZoom) {\r\n            return;\r\n        }\r\n        if (this._mapPane) {\r\n            DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\r\n        }\r\n        this._animatingZoom = false;\r\n        this._move(this._animateToCenter, this._animateToZoom);\r\n        // This anim frame should prevent an obscure iOS webkit tile loading race condition.\r\n        Util.requestAnimFrame(() => {\r\n            this._moveEnd(true);\r\n        }, this);\r\n    }\r\n    getCRS() {\r\n        return this._crs;\r\n    }\r\n    addGraphic(graphic) {\r\n        // this._canvas.addGraphic(graphic);\r\n        this._viewer.addGraphic(graphic);\r\n    }\r\n    addGraphicLayer(graphicLayer) {\r\n        graphicLayer.crs = this._crs;\r\n        // this._canvas.addGraphicLayer(graphicLayer);\r\n        this._viewer.addGraphicLayer(graphicLayer);\r\n    }\r\n    addFeatureLayer(featureLayer) {\r\n        featureLayer.crs = this._crs;\r\n        // this._canvas.addFeatureLayer(featureLayer);\r\n        this._viewer.addFeatureLayer(featureLayer);\r\n    }\r\n    addRasterLayer(rasterLayer) {\r\n        rasterLayer.crs = this._crs;\r\n        // this._canvas.addRasterLayer(rasterLayer);\r\n        this._viewer.addRasterLayer(rasterLayer);\r\n    }\r\n    addAnimation(animation) {\r\n        animation.project(this._crs);\r\n        this._animater.addAnimation(animation);\r\n    }\r\n    addHandler(name, handler) {\r\n        this._handlers.push(handler);\r\n        this[name] = handler;\r\n        if (this.options[name]) {\r\n            handler.enable();\r\n        }\r\n        return this;\r\n    }\r\n    clearHandlers() {\r\n        for (let i = 0, len = this._handlers.length; i < len; i++) {\r\n            this._handlers[i].disable();\r\n        }\r\n    }\r\n}\r\n","import * as Util from '../util/util';\r\nimport * as DomUtil from '../util/dom-util';\r\nimport { EventedObject } from '../base/evented-object';\r\n/*\r\n * @class PosAnimation\r\n * @aka L.PosAnimation\r\n * @inherits Evented\r\n * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\r\n *\r\n * @example\r\n * ```js\r\n * var fx = new L.PosAnimation();\r\n * fx.run(el, [300, 500], 0.5);\r\n * ```\r\n *\r\n * @constructor L.PosAnimation()\r\n * Creates a `PosAnimation` object.\r\n *\r\n */\r\nexport class PosAnimation extends EventedObject {\r\n    constructor(el) {\r\n        super();\r\n        this._duration = 0.25;\r\n        this._el = el;\r\n    }\r\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\r\n    // Run an animation of a given element to a new position, optionally setting\r\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\r\n    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),\r\n    // `0.5` by default).\r\n    run(el, newPos, duration, easeLinearity) {\r\n        this.stop();\r\n        this._el = el;\r\n        this._inProgress = true;\r\n        this._duration = duration || 0.25;\r\n        this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\r\n        this._startPos = DomUtil.getPosition(el);\r\n        this._offset = newPos.subtract(this._startPos);\r\n        this._startTime = +new Date();\r\n        // @event start: Event\r\n        // Fired when the animation starts\r\n        this.fire('start');\r\n        this._animate();\r\n    }\r\n    // @method stop()\r\n    // Stops the animation (if currently running).\r\n    stop() {\r\n        if (!this._inProgress) {\r\n            return;\r\n        }\r\n        this._step(true);\r\n        this._complete();\r\n    }\r\n    _animate() {\r\n        // animation loop\r\n        this._animId = Util.requestAnimFrame(this._animate, this);\r\n        this._step();\r\n    }\r\n    _step(round) {\r\n        var elapsed = (+new Date()) - this._startTime, duration = this._duration * 1000;\r\n        if (elapsed < duration) {\r\n            this._runFrame(this._easeOut(elapsed / duration), round);\r\n        }\r\n        else {\r\n            this._runFrame(1);\r\n            this._complete();\r\n        }\r\n    }\r\n    _runFrame(progress, round) {\r\n        var pos = this._startPos.add(this._offset.multiplyBy(progress));\r\n        if (round) {\r\n            pos.round(false);\r\n        }\r\n        DomUtil.setPosition(this._el, pos);\r\n        // @event step: Event\r\n        // Fired continuously during the animation.\r\n        this.fire('step');\r\n    }\r\n    _complete() {\r\n        Util.cancelAnimFrame(this._animId);\r\n        this._inProgress = false;\r\n        // @event end: Event\r\n        // Fired when the animation ends.\r\n        this.fire('end');\r\n    }\r\n    _easeOut(t) {\r\n        return 1 - Math.pow(1 - t, this._easeOutPower);\r\n    }\r\n}\r\n","import { LatLng } from \"../common/latlng\";\r\nimport { LatLngBounds } from \"../common/latlng-bounds\";\r\n/*\r\n * 栅格\r\n */\r\nexport class Raster {\r\n    /**\r\n     * 创建栅格\r\n     * @remarks\r\n     * 遍历图形集合进行绘制\r\n     * @param {number} xmin - 经度左值\r\n     * @param {number} ymin - 纬度下值\r\n     * @param {number} xmax - 经度右值\r\n     * @param {number} ymax - 纬度上值\r\n     * @param {number} width - 栅格宽度\r\n     * @param {number} height - 栅格高度\r\n     * @param {number} cellsize - 栅格大小\r\n     */\r\n    constructor(xmin, ymin, xmax, ymax, width = 1000, height = 1000) {\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.width = width;\r\n        this._canvas.height = height;\r\n        this._latlngBounds = new LatLngBounds(new LatLng(ymin, xmin), new LatLng(ymax, xmax));\r\n    }\r\n    /*\r\n     * 动态栅格（实时渲染）\r\n     */\r\n    get dynamic() {\r\n        return false;\r\n    }\r\n    /*\r\n     * 画布存放Image\r\n     */\r\n    get canvas() {\r\n        return this._canvas;\r\n    }\r\n    /*\r\n     * 栅格经纬度边界\r\n     */\r\n    get bounds() {\r\n        return this._latlngBounds;\r\n    }\r\n    /**\r\n     * 包络矩形\r\n     * @remarks\r\n     * 注意bound的坐标类型：一般为地理平面坐标，即投影后坐标\r\n     */\r\n    get latlngBounds() {\r\n        return this._latlngBounds;\r\n    }\r\n    get planeBounds() {\r\n        return this._planeBounds;\r\n    }\r\n    get screenBounds() {\r\n        return this._screenBounds;\r\n    }\r\n    set crs(value) {\r\n        this._crs = value;\r\n        this.project();\r\n    }\r\n}\r\n","import { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Color } from \"../util/color\";\r\nimport { Renderer } from \"./renderer\";\r\n/**\r\n * 分类渲染项\r\n */\r\nexport class CategoryRendererItem {\r\n    constructor(value, symbol, label) {\r\n        /**\r\n         * 该类总数\r\n         */\r\n        this.count = 1;\r\n        this.value = value;\r\n        this.symbol = symbol;\r\n        this.label = label;\r\n    }\r\n}\r\n/**\r\n * 分类渲染\r\n * @remarks\r\n * 一般可通过设置分类字段，再调用generate自动生成分类渲染项\r\n * 也可通过手动添加和定义分类渲染项，完成分类渲染设置，通过items.push()\r\n */\r\nexport class CategoryRenderer extends Renderer {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 所有分类集合\r\n         */\r\n        this._items = [];\r\n    }\r\n    /**\r\n     * 分类字段\r\n     * @remarks\r\n     * 一般为字符串字段，也可为枚举域值，或是非布尔值\r\n     */\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    set field(value) {\r\n        this._field = value;\r\n    }\r\n    /**\r\n     * 所有分类集合\r\n     */\r\n    get items() {\r\n        return this._items;\r\n    }\r\n    /**\r\n     * 根据分类字段，自动生成分类渲染项\r\n     * @param {FeatureClass} featureClass - 要素类（要素集合）\r\n     * @param {Field} field - 分类字段\r\n     */\r\n    generate(featureClass, field) {\r\n        this._field = field;\r\n        this._items = [];\r\n        //分类统计\r\n        featureClass.features.map(feature => feature.properties[field.name]).forEach((value) => {\r\n            const item = this._items.find(item => item.value == value);\r\n            if (item) {\r\n                item.count += 1;\r\n            }\r\n            else {\r\n                const item = new CategoryRendererItem();\r\n                switch (featureClass.type) {\r\n                    case GeometryType.Point:\r\n                        // case GeometryType.MultiplePoint:\r\n                        const symbol1 = new SimplePointSymbol();\r\n                        symbol1.fillStyle = Color.random().toString();\r\n                        symbol1.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol1;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                    case GeometryType.Polyline:\r\n                        // case GeometryType.MultiplePolyline:\r\n                        const symbol2 = new SimpleLineSymbol();\r\n                        symbol2.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol2;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                    case GeometryType.Polygon:\r\n                        // case GeometryType.MultiplePolygon:\r\n                        const symbol3 = new SimpleFillSymbol();\r\n                        symbol3.fillStyle = Color.random().toString();\r\n                        symbol3.strokeStyle = Color.random().toString();\r\n                        item.symbol = symbol3;\r\n                        item.value = value;\r\n                        this._items.push(item);\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getSymbol(feature) {\r\n        const item = this.items.find(item => item.value == feature.properties[this.field.name]);\r\n        if (item)\r\n            return item.symbol;\r\n    }\r\n}\r\n","import { SimpleFillSymbol, SimpleLineSymbol, SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { Color } from \"../util/color\";\r\nimport { Renderer } from \"./renderer\";\r\n/**\r\n * 分级渲染项\r\n * @remarks\r\n * 分级区间一般为( ]: 即下开上闭\r\n */\r\nexport class ClassRendererItem {\r\n    constructor(low, high, symbol, label) {\r\n        this.low = low;\r\n        this.high = high;\r\n        this.symbol = symbol;\r\n        this.label = label;\r\n    }\r\n}\r\n/**\r\n * 分级渲染\r\n * @remarks\r\n * 一般可通过设置分级字段，再调用generate自动生成分级渲染项\r\n * 也可通过手动添加和定义分级渲染项，完成分级渲染设置，通过items.push()\r\n */\r\nexport class ClassRenderer extends Renderer {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 所有分级渲染项集合\r\n         */\r\n        this._items = [];\r\n    }\r\n    /**\r\n     * 分级字段\r\n     * @remarks\r\n     * 必须为数值型\r\n     */\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    set field(value) {\r\n        this._field = value;\r\n    }\r\n    /**\r\n     * 所有分级渲染项集合\r\n     */\r\n    get items() {\r\n        return this._items;\r\n    }\r\n    /**\r\n     * 自动生成分级渲染项\r\n     * @remarks\r\n     * TODO: 分级有多种方式，目前只实现均分\r\n     */\r\n    generate(featureClass, field, breaks) {\r\n        this._field = field;\r\n        this._items = [];\r\n        //获取该字段极值\r\n        const stat = featureClass.features.map(feature => feature.properties[field.name]).reduce((stat, cur) => {\r\n            stat.max = Math.max(cur, stat.max);\r\n            stat.min = Math.min(cur, stat.min);\r\n            return stat;\r\n        }, { min: Number.MAX_VALUE, max: Number.MIN_VALUE });\r\n        for (let i = 0; i < breaks; i++) {\r\n            const item = new ClassRendererItem();\r\n            switch (featureClass.type) {\r\n                case GeometryType.Point:\r\n                    // case GeometryType.MultiplePoint:\r\n                    const symbol1 = new SimplePointSymbol();\r\n                    symbol1.fillStyle = Color.random().toString();\r\n                    symbol1.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol1;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n                case GeometryType.Polyline:\r\n                    // case GeometryType.MultiplePolyline:\r\n                    const symbol2 = new SimpleLineSymbol();\r\n                    symbol2.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol2;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n                case GeometryType.Polygon:\r\n                    // case GeometryType.MultiplePolygon:\r\n                    const symbol3 = new SimpleFillSymbol();\r\n                    symbol3.fillStyle = Color.random().toString();\r\n                    symbol3.strokeStyle = Color.random().toString();\r\n                    item.symbol = symbol3;\r\n                    item.low = stat.min + i * (stat.max - stat.min) / breaks;\r\n                    item.high = stat.min + (i + 1) * (stat.max - stat.min) / breaks;\r\n                    item.label = item.low + \" - \" + item.high;\r\n                    this._items.push(item);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    getSymbol(feature) {\r\n        const item = this.items.find(item => item.low <= feature.properties[this.field.name] && item.high >= feature.properties[this.field.name]);\r\n        if (item)\r\n            return item.symbol;\r\n    }\r\n}\r\n","import { SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { Renderer } from \"./renderer\";\r\nimport { GeometryType } from \"../geometry/geometry\";\r\nimport { ClusterSymbol } from \"../symbol/cluster-symbol\";\r\n/**\r\n * 聚合渲染\r\n */\r\nexport class ClusterRenderer extends Renderer {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._defaultSymbol = new SimplePointSymbol();\r\n        this._tolerance = 50; //distance 50px\r\n        this._features = {}; // Map<id, count>\r\n    }\r\n    set featureClass(value) {\r\n        if (value.type == GeometryType.Point) {\r\n            this._featureClass = value;\r\n        }\r\n    }\r\n    set defaultSymbol(value) {\r\n        this._defaultSymbol = value;\r\n    }\r\n    set Tolerance(value) {\r\n        this._tolerance = value;\r\n    }\r\n    init(redrawBounds) {\r\n        this._features = {};\r\n        if (!this._featureClass)\r\n            return;\r\n        let feature = this._featureClass.first;\r\n        while (feature) {\r\n            if (!redrawBounds || (feature.geometry && feature.geometry.screenBounds && feature.geometry.screenBounds.intersects(redrawBounds))) {\r\n                let exist = false;\r\n                const keys = Object.keys(this._features);\r\n                for (let i = 0; i < keys.length; i++) {\r\n                    const id = keys[i];\r\n                    const item = this._featureClass.getFeature(id);\r\n                    if (item) {\r\n                        const p1 = feature.geometry;\r\n                        const p2 = item.geometry;\r\n                        if (p1.distance(p2) <= this._tolerance) {\r\n                            exist = true;\r\n                            this._features[id] += 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!exist) {\r\n                    this._features[feature.id] = 1;\r\n                }\r\n            }\r\n            feature = feature.next;\r\n        }\r\n    }\r\n    getSymbol(feature) {\r\n        const count = this._features[feature.id];\r\n        if (!count) {\r\n            return null;\r\n        }\r\n        else if (count == 1) {\r\n            return this._defaultSymbol;\r\n        }\r\n        else {\r\n            return new ClusterSymbol(count);\r\n        }\r\n    }\r\n}\r\n","import { SimplePointSymbol } from \"../symbol/symbol\";\r\nimport { Renderer } from \"./renderer\";\r\n/**\r\n * 点半径渲染\r\n * @remarks\r\n * 只适用点图层\r\n */\r\nexport class DotRenderer extends Renderer {\r\n    get field() {\r\n        return this._field;\r\n    }\r\n    set field(value) {\r\n        this._field = value;\r\n    }\r\n    getSymbol(feature) {\r\n        this.symbol = this.symbol || new SimplePointSymbol();\r\n        this.symbol.radius = Number(feature.properties[this.field.name] || 0);\r\n        return this.symbol;\r\n    }\r\n}\r\n","/**\r\n * 渲染方式基类\r\n */\r\nexport class Renderer {\r\n    init(redrawBounds) {\r\n        //do something before layer draw; \r\n        //etc ClusterRenderer\r\n    }\r\n}\r\n","import { Renderer } from \"./renderer\";\r\n/**\r\n * 单一渲染\r\n */\r\nexport class SimpleRenderer extends Renderer {\r\n    getSymbol(feature) {\r\n        return this.symbol;\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { LineSymbol } from \"./symbol\";\r\n/**\r\n * 简单线符号\r\n * @remarks\r\n * 最常用的线符号\r\n */\r\nexport class AlternateLineSymbol extends LineSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.color1 = \"#000000\";\r\n        this.color2 = \"#ffffff\";\r\n        this.alternate = 10;\r\n    }\r\n    /**\r\n     * 绘制线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][]} screen - 线对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screenXYs) {\r\n        if (screenXYs.length < 2)\r\n            return;\r\n        ctx.save();\r\n        ctx.strokeStyle = this.color1;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.setLineDash([this.alternate, this.alternate]);\r\n        ctx.beginPath();\r\n        screenXYs.forEach((screenXY, index) => {\r\n            if (index === 0) {\r\n                ctx.moveTo(screenXY.x, screenXY.y);\r\n            }\r\n            else {\r\n                ctx.lineTo(screenXY.x, screenXY.y);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        ctx.strokeStyle = this.color2;\r\n        ctx.lineDashOffset = this.alternate;\r\n        ctx.beginPath();\r\n        screenXYs.forEach((screenXY, index) => {\r\n            if (index === 0) {\r\n                ctx.moveTo(screenXY.x, screenXY.y);\r\n            }\r\n            else {\r\n                ctx.lineTo(screenXY.x, screenXY.y);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n    getScreenBounds(screenXYs) {\r\n        const bounds = new ScreenBounds();\r\n        screenXYs.forEach(screenXY => {\r\n            bounds.extend(screenXY);\r\n        });\r\n        // extend weight\r\n        return bounds;\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { ScreenXY } from \"../common/screen-xy\";\r\nimport { PointSymbol } from \"./symbol\";\r\nexport class AnimatePointSymbol extends PointSymbol {\r\n}\r\nexport class SimpleAnimatePointSymbol extends AnimatePointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 边宽\r\n         */\r\n        this.lineWidth = 3;\r\n        /**\r\n         * 颜色\r\n         */\r\n        this.color = \"#ff0000\";\r\n        /**\r\n         * 扩散速度\r\n         */\r\n        this.velocity = 10; //  px/s\r\n        /**\r\n         * 扩散的最大半径\r\n         */\r\n        this.limit = 30;\r\n        /**\r\n         * 扩散的光圈数\r\n         */\r\n        this.ring = 3;\r\n    }\r\n    draw(ctx, screenXY) {\r\n        this._screenXY = screenXY;\r\n        this._ctx = ctx;\r\n        this._frame && window.cancelAnimationFrame(this._frame);\r\n        this._start = undefined;\r\n        //this上下文绑定\r\n        this.animate = this.animate.bind(this);\r\n        //动画循环\r\n        this._frame = window.requestAnimationFrame(this.animate);\r\n    }\r\n    getScreenBounds(screenXY) {\r\n        let r = this.limit, w = this.stroke ? Math.ceil(this.weight / 2) : 0, p = new ScreenXY(r + w, r + w);\r\n        return new ScreenBounds(screenXY.subtract(p), screenXY.add(p));\r\n    }\r\n    /**\r\n     * 动画效果\r\n     * @remarks\r\n     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数\r\n     * @param {number} elapsed - 已逝去的时间，毫秒\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    animate(timestamp) {\r\n        const screenXY = this._screenXY;\r\n        const ctx = this._ctx;\r\n        if (this._start === undefined) {\r\n            this._start = timestamp;\r\n        }\r\n        const elapsed = timestamp - this._start;\r\n        ctx.save();\r\n        const bounds = this.getScreenBounds(screenXY);\r\n        const size = bounds.getSize();\r\n        ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        // ctx.setTransform(1,0,0,1,0,0);\r\n        /*ctx.arc(this._screenX, this._screenY, this.limit / this.ring, 0, Math.PI * 2, true);\r\n        ctx.fill();*/\r\n        for (let i = 0; i < this.ring; i++) {\r\n            ctx.beginPath(); //Start path\r\n            ctx.arc(screenXY.x, screenXY.y, (elapsed / 1000 * this.velocity + i * this.limit / this.ring) % this.limit, 0, Math.PI * 2, true);\r\n            //ctx.arc(this._screenX, this._screenY, this.limit / this.ring + ((elapsed/1000 + (this.limit - this.limit / this.ring) / this.velocity * (i/(this.ring - 1))) * this.velocity) % this.limit, 0, Math.PI * 2, true);\r\n            ctx.stroke();\r\n        }\r\n        ctx.restore();\r\n        //循环，下一帧\r\n        this._frame = window.requestAnimationFrame(this.animate);\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { LineSymbol } from \"./symbol\";\r\n/**\r\n * 箭头符号\r\n */\r\nexport class ArrowSymbol extends LineSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 线宽\r\n         */\r\n        this.lineWidth = 2;\r\n        /**\r\n         * 决定绘制箭头的最小线长\r\n         * @remarks 屏幕坐标，单位pixel\r\n         * 默认 >50pixels will draw arrow\r\n         */\r\n        this.minLength = 50;\r\n        /**\r\n         * 箭翼长度\r\n         */\r\n        this.arrowLength = 10;\r\n        /**\r\n         * 箭翼夹角\r\n         * @remarks 默认 angle 30 = Math.PI / 6\r\n         */\r\n        this.arrowAngle = Math.PI / 6;\r\n    }\r\n    /**\r\n     * 绘制线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][]} screen - 线对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screenXYs) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //keep lineWidth\r\n        // ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.beginPath();\r\n        screenXYs.forEach((screenXY, index) => {\r\n            const screenX = screenXY.x, screenY = screenXY.y;\r\n            if (index === 0) {\r\n                ctx.moveTo(screenX, screenY);\r\n            }\r\n            else {\r\n                ctx.lineTo(screenX, screenY);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        //已知 起点和终点  求沿线距起点定长的点\r\n        const _getPointAlongLine = (p1, p2, d) => {\r\n            //line length\r\n            let l = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n            let t = d / l;\r\n            return [(1 - t) * p1[0] + t * p2[0], (1 - t) * p1[1] + t * p2[1]];\r\n        };\r\n        //已知 起点 y = kx + b   求沿线距起点定长的点 两个点\r\n        const _getPointAlongLine2 = (k, b, p, d) => {\r\n            let x0 = p[0] + Math.sqrt((d * d) / (k * k + 1)), x1 = p[0] - Math.sqrt((d * d) / (k * k + 1));\r\n            return [[x0, k * x0 + b], [x1, k * x1 + b]];\r\n        };\r\n        screenXYs.reduce((prev, cur) => {\r\n            if (prev) {\r\n                const length = Math.sqrt((cur.x - prev.x) * (cur.x - prev.x) + (cur.y - prev.y) * (cur.y - prev.y));\r\n                if (length >= this.minLength) {\r\n                    //中点 即箭头\r\n                    const [middleX, middleY] = [(prev.x + cur.x) / 2, (prev.y + cur.y) / 2];\r\n                    //箭尾垂线的垂足\r\n                    const [footX, footY] = _getPointAlongLine([middleX, middleY], [prev.x, prev.y], Math.cos(this.arrowAngle) * this.arrowLength);\r\n                    const k = (cur.y - prev.y) / (cur.x - prev.x);\r\n                    // 1/k 垂线\r\n                    const points = _getPointAlongLine2(-1 / k, footY - footX * -1 / k, [footX, footY], Math.sin(this.arrowAngle) * this.arrowLength);\r\n                    //两点\r\n                    points.forEach(point => {\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(middleX, middleY);\r\n                        ctx.lineTo(point[0], point[1]);\r\n                        ctx.stroke();\r\n                    });\r\n                }\r\n                return cur;\r\n            }\r\n            else {\r\n                return cur;\r\n            }\r\n        });\r\n        ctx.restore();\r\n    }\r\n    getScreenBounds(screenXYs) {\r\n        const bounds = new ScreenBounds();\r\n        screenXYs.forEach(screenXY => {\r\n            bounds.extend(screenXY);\r\n        });\r\n        // extend weight\r\n        return bounds;\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { ScreenXY } from \"../common/screen-xy\";\r\nimport { Color } from \"../util/color\";\r\nimport { PointSymbol } from \"./symbol\";\r\n/**\r\n * 聚合符号\r\n * @remarks\r\n * 限制用于点图层\r\n */\r\nexport class ClusterSymbol extends PointSymbol {\r\n    /**\r\n     * 创建聚合符号\r\n     * @param {number} count - 聚合数量\r\n     */\r\n    constructor(count) {\r\n        super();\r\n        /**\r\n         * 聚合数量\r\n         */\r\n        this._count = 2;\r\n        /**\r\n         * 聚合符号的默认半径\r\n         */\r\n        this.radius = 10;\r\n        /**\r\n         * 重写描边样式\r\n         */\r\n        this.strokeStyle = \"#ffffff\"; //#ff0000\r\n        /**\r\n         * 聚合外圈填充样式\r\n         */\r\n        this.outerFillStyle = \"#ffffff\"; //#ff0000\r\n        /**\r\n         * 聚合数量字体颜色\r\n         */\r\n        this.fontColor = \"#ffffff\";\r\n        /**\r\n         * 聚合数量字体\r\n         */\r\n        this.fontFamily = \"YaHei\";\r\n        /**\r\n         * 聚合数量字体粗细\r\n         */\r\n        this.fontWeight = \"Bold\";\r\n        /**\r\n         * 色带起始色\r\n         */\r\n        this.startColor = \"#19caad\";\r\n        /**\r\n         * 色带终止色\r\n         */\r\n        this.endColor = \"#f4606c\";\r\n        this._count = count;\r\n    }\r\n    /**\r\n     * 聚合数量文本\r\n     * @remarks\r\n     * 大于99，标记为99+\r\n     */\r\n    get text() {\r\n        return this._count <= 99 ? this._count.toString() : \"99+\";\r\n    }\r\n    /**\r\n     * 内圈半径\r\n     */\r\n    get inner() {\r\n        return this._count <= 15 ? this.radius + this._count : this.radius + 15;\r\n    }\r\n    /**\r\n     * 外圈半径\r\n     */\r\n    get outer() {\r\n        return this.inner + 4;\r\n    }\r\n    /**\r\n     * 字体随数量递增，同时控制为非无限递增\r\n     */\r\n    get fontSize() {\r\n        if (this._count < 10) {\r\n            return 12;\r\n        }\r\n        else if (this._count >= 10 && this._count < 30) {\r\n            return 14;\r\n        }\r\n        else if (this._count >= 30 && this._count < 50) {\r\n            return 16;\r\n        }\r\n        else if (this._count >= 30 && this._count < 50) {\r\n            return 18;\r\n        }\r\n        else if (this._count > 50) {\r\n            return 20;\r\n        }\r\n    }\r\n    /**\r\n     * 聚合的内圈填充样式\r\n     * @remarks\r\n     * 采用色带，色带可自定义扩展\r\n     */\r\n    get innerFillStyle() {\r\n        //TODO 优化 setter hex, getter color\r\n        const colors = Color.ramp(Color.fromHex(this.startColor), Color.fromHex(this.endColor), 16);\r\n        return colors[this._count <= 15 ? this._count : 15].toString();\r\n    }\r\n    /**\r\n     * 绘制聚合符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenXY) {\r\n        ctx.save();\r\n        // ctx.setTransform(1,0,0,1,0,0);\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.outerFillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size 画外圈\r\n        ctx.arc(screenXY.x, screenXY.y, this.outer, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.fillStyle = this.innerFillStyle;\r\n        ctx.beginPath(); //Start path\r\n        //keep size 画内圈\r\n        ctx.arc(screenXY.x, screenXY.y, this.inner, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillStyle = this.fontColor;\r\n        ctx.font = this.fontSize + \"px/1 \" + this.fontFamily + \" \" + this.fontWeight;\r\n        ctx.fillText(this.text, screenXY.x, screenXY.y);\r\n        ctx.restore();\r\n    }\r\n    getScreenBounds(screenXY) {\r\n        let r = this.radius, w = this.stroke ? this.weight / 2 : 0, p = new ScreenXY(r + w, r + w);\r\n        return new ScreenBounds(screenXY.subtract(p), screenXY.add(p));\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { ScreenXY } from \"../common/screen-xy\";\r\nimport { PointSymbol } from \"./symbol\";\r\n/**\r\n * 字符符号\r\n * @remarks\r\n * 中英文皆可，注意控制长度，推荐单个字符\r\n */\r\nexport class LetterSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 外圈半径\r\n         */\r\n        this.radius = 10;\r\n        /**\r\n         * 字符，中英文皆可，推荐单个字符\r\n         */\r\n        this.letter = \"\";\r\n        /**\r\n         * 字体颜色\r\n         */\r\n        this.fontColor = \"#ff0000\";\r\n        /**\r\n         * 字体大小\r\n         */\r\n        this.fontSize = 12;\r\n        /**\r\n         * 字体\r\n         */\r\n        this.fontFamily = \"YaHei\";\r\n        /**\r\n         * 字体粗细\r\n         */\r\n        this.fontWeight = \"Bold\";\r\n    }\r\n    /**\r\n     * 绘制字符符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenXY) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        // ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //绘制外圈\r\n        ctx.arc(screenXY.x, screenXY.y, this.radius, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillStyle = this.fontColor;\r\n        ctx.font = this.fontSize + \"px/1 \" + this.fontFamily + \" \" + this.fontWeight;\r\n        //绘制字符\r\n        ctx.fillText(this.letter, screenXY.x, screenXY.y);\r\n        ctx.restore();\r\n    }\r\n    getScreenBounds(screenXY) {\r\n        let r = this.radius, w = this.stroke ? this.weight / 2 : 0, p = new ScreenXY(r + w, r + w);\r\n        return new ScreenBounds(screenXY.subtract(p), screenXY.add(p));\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { FillSymbol } from \"./symbol\";\r\n/**\r\n * 模式填充面符号\r\n * @remarks\r\n * 最常用的面填充符号\r\n */\r\nexport class PatternFillSymbol extends FillSymbol {\r\n    /**\r\n     * 绘制面\r\n     * @remarks\r\n     * 奇偶填充\r\n     * https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fill\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][][]} screen - 面对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screenXYs) {\r\n        // ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.createPattern(ctx);\r\n        // ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //TODO:  exceeding the maximum extent(bound), best way is overlap by extent. find out: maximum is [-PI*R, PI*R]??\r\n        ctx.beginPath();\r\n        screenXYs.forEach(ring => {\r\n            if (ring.length < 3)\r\n                return;\r\n            ring.forEach((screenXY, index) => {\r\n                if (index === 0) {\r\n                    ctx.moveTo(screenXY.x, screenXY.y);\r\n                }\r\n                else {\r\n                    ctx.lineTo(screenXY.x, screenXY.y);\r\n                }\r\n            });\r\n        });\r\n        ctx.closePath();\r\n        //奇偶填充\r\n        //https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fill\r\n        ctx.fill(\"evenodd\");\r\n        ctx.stroke();\r\n        // ctx.restore();\r\n    }\r\n    getScreenBounds(screenXYs) {\r\n        const bounds = new ScreenBounds();\r\n        screenXYs.forEach(ring => {\r\n            ring.forEach(screenXY => {\r\n                bounds.extend(screenXY);\r\n            });\r\n        });\r\n        // extend weight\r\n        return bounds;\r\n    }\r\n}\r\nexport class LinePatternFillSymbol extends PatternFillSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.patternLineWidth = 2;\r\n        this.size = 16;\r\n        this.angle = 45; //(0, 180)\r\n    }\r\n    get radian() {\r\n        return this.angle * Math.PI / 180;\r\n    }\r\n    createPattern(ctx) {\r\n        const canvas = document.createElement(\"canvas\");\r\n        const width = this.size;\r\n        const height = this.angle == 0 || this.angle == 90 || this.angle == 180 ? this.size : Math.round(this.size * Math.abs(Math.tan(this.radian)));\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const context = canvas.getContext(\"2d\");\r\n        context.strokeStyle = this.strokeStyle;\r\n        context.lineWidth = this.patternLineWidth;\r\n        if (this.angle == 0 || this.angle == 180) {\r\n            context.beginPath();\r\n            context.moveTo(0, height / 2);\r\n            context.lineTo(width, height / 2);\r\n            context.stroke();\r\n        }\r\n        else if (this.angle == 90) {\r\n            context.beginPath();\r\n            context.moveTo(width / 2, 0);\r\n            context.lineTo(width / 2, height);\r\n            context.stroke();\r\n        }\r\n        else if (this.angle < 90 && this.angle > 0) {\r\n            // 中间过中心\r\n            context.setTransform(1, Math.tan(this.radian), 0, 1, width / 2, height / 2);\r\n            context.beginPath();\r\n            context.moveTo(-width / 2, 0);\r\n            context.lineTo(width / 2, 0);\r\n            context.stroke();\r\n            // 上半从中点开始到右上角\r\n            // context.setTransform(1, Math.tan(this.angle), 0, 1, this.size/2, 0);\r\n            context.beginPath();\r\n            context.moveTo(0, -height / 2);\r\n            context.lineTo(width / 2, -height / 2);\r\n            // context.moveTo(0, 0);\r\n            // context.lineTo(this.size/2, 0);\r\n            context.stroke();\r\n            // 下半从左下角开始到中点\r\n            // context.setTransform(1, Math.tan(this.angle), 0, 1, this.size/2, this.size);\r\n            context.beginPath();\r\n            context.moveTo(-width / 2, height / 2);\r\n            context.lineTo(0, height / 2);\r\n            // context.moveTo(-this.size/2, 0);\r\n            // context.lineTo(0, 0);\r\n            context.stroke();\r\n        }\r\n        else if (this.angle < 180 && this.angle > 90) {\r\n            // 中间过中心\r\n            context.setTransform(1, -Math.tan(Math.PI - this.radian), 0, 1, width / 2, height / 2);\r\n            context.beginPath();\r\n            context.moveTo(-width / 2, 0);\r\n            context.lineTo(width / 2, 0);\r\n            context.stroke();\r\n            // 上半从左上角开始到中点\r\n            // context.setTransform(1, Math.tan(this.angle), 0, 1, this.size/2, 0);\r\n            context.beginPath();\r\n            context.moveTo(-width / 2, -height / 2);\r\n            context.lineTo(0, -height / 2);\r\n            // context.moveTo(0, 0);\r\n            // context.lineTo(this.size/2, 0);\r\n            context.stroke();\r\n            // 下半从中点开始到右下角\r\n            // context.setTransform(1, Math.tan(this.angle), 0, 1, this.size/2, this.size);\r\n            context.beginPath();\r\n            context.moveTo(0, height / 2);\r\n            context.lineTo(width / 2, height / 2);\r\n            // context.moveTo(-this.size/2, 0);\r\n            // context.lineTo(0, 0);\r\n            context.stroke();\r\n        }\r\n        return ctx.createPattern(canvas, \"repeat\");\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { ScreenXY } from \"../common/screen-xy\";\r\nimport { PointSymbol } from \"./symbol\";\r\nexport class ShapeSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 圆点半径，像素值\r\n        */\r\n        this.radius = 10;\r\n        /**\r\n         * 边数\r\n        */\r\n        this.sides = 4;\r\n        this.angle = 0; //(0, 360)\r\n    }\r\n    get radian() {\r\n        return this.angle * Math.PI / 180;\r\n    }\r\n    draw(ctx, screenXY) {\r\n        ctx.save();\r\n        //keep size\r\n        //地理坐标 转回 屏幕坐标\r\n        // ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        const screenX = screenXY.x;\r\n        const screenY = screenXY.y;\r\n        //ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n        ctx.moveTo(screenX + this.radius * Math.sin(this.radian), screenY - this.radius * Math.cos(this.radian));\r\n        for (let i = 1; i < this.sides; i++) {\r\n            let rad = 2 * Math.PI / this.sides * i;\r\n            ctx.lineTo(screenX + this.radius * Math.sin(this.radian + rad), screenY - this.radius * Math.cos(this.radian + rad));\r\n        }\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 包络矩形\r\n    */\r\n    getScreenBounds(screenXY) {\r\n        let r = this.radius, w = this.stroke ? this.weight / 2 : 0, p = new ScreenXY(r + w, r + w);\r\n        return new ScreenBounds(screenXY.subtract(p), screenXY.add(p));\r\n    }\r\n}\r\n","import { ScreenBounds } from \"../common/screen-bounds\";\r\nimport { ScreenXY } from \"../common/screen-xy\";\r\n/**\r\n * 符号基类\r\n * @remarks\r\n * 如按现实世界来抽取对象基类，下述属性不应放在基类\r\n * 但考虑到Canvas的上下文设定，才决定抽取到基类\r\n */\r\nexport class Symbol {\r\n    constructor() {\r\n        /**\r\n         * 线宽\r\n         */\r\n        this.lineWidth = 2;\r\n        this.stroke = true;\r\n        /**\r\n         * 描边样式\r\n         */\r\n        this.strokeStyle = \"#ff0000\";\r\n        this.strokeColor = \"#ff0000\";\r\n        this.strokeOpacity = 1;\r\n        this.fill = true;\r\n        /**\r\n         * 填充样式\r\n         */\r\n        this.fillStyle = \"#ff000088\";\r\n        this.fillColor = \"#ff0000\";\r\n        this.fillOpacity = 0.5;\r\n        // abstract contain(screenXY: ScreenXY): boolean;\r\n    }\r\n    get weight() {\r\n        return this.lineWidth;\r\n    }\r\n    set weight(value) {\r\n        this.lineWidth = value;\r\n    }\r\n}\r\n/**\r\n * 点符号基类\r\n */\r\nexport class PointSymbol extends Symbol {\r\n}\r\n/**\r\n * 线符号基类\r\n */\r\nexport class LineSymbol extends Symbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.lineWidth = 3;\r\n    }\r\n}\r\n/**\r\n* 面符号基类\r\n* @remarks\r\n* aka 填充符号\r\n*/\r\nexport class FillSymbol extends Symbol {\r\n}\r\n/**\r\n * 简单圆点符号\r\n * @remarks\r\n * 最常用的点符号\r\n */\r\nexport class SimplePointSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 圆点半径，像素值\r\n         */\r\n        this.radius = 10;\r\n    }\r\n    /**\r\n     * 绘制点\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenXY) {\r\n        //ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        ctx.arc(screenXY.x, screenXY.y, this.radius, 0, Math.PI * 2, false);\r\n        // ctx.globalAlpha = this.fillOpacity;\r\n        // ctx.fillStyle = this.fillColor;\r\n        ctx.fill('evenodd');\r\n        // ctx.globalAlpha = this.strokeOpacity;\r\n        // ctx.strokeStyle = this.strokeColor;\r\n        // ctx.lineWidth = this.lineWidth;\r\n        ctx.stroke();\r\n        //ctx.restore();\r\n    }\r\n    getScreenBounds(screenXY) {\r\n        let r = this.radius, w = this.stroke ? this.weight / 2 : 0, p = new ScreenXY(r + w, r + w);\r\n        return new ScreenBounds(screenXY.subtract(p), screenXY.add(p));\r\n    }\r\n}\r\n/**\r\n * 图标符号\r\n * @remarks\r\n * 常用于POI兴趣点的渲染\r\n */\r\nexport class SimpleMarkerSymbol extends PointSymbol {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * 宽\r\n         */\r\n        this.width = 16;\r\n        /**\r\n         * 高\r\n         */\r\n        this.height = 16;\r\n        /**\r\n         * offset，坐标点对应图标的位置\r\n         * 例如，宽16px，高16px，offsetX为-8，offsetY为-8：\r\n         * 该图标的中心点对应渲染点的坐标。\r\n         */\r\n        this.offsetX = -8;\r\n        /**\r\n         * offset，坐标点对应图标的位置\r\n         * 例如，宽16px，高16px，offsetX为-8，offsetY为-8：\r\n         * 该图标的中心点对应渲染点的坐标。\r\n         */\r\n        this.offsetY = -8;\r\n    }\r\n    /**\r\n     * 记录是否已完成异步图标加载\r\n     */\r\n    get loaded() {\r\n        return this._loaded;\r\n    }\r\n    /**\r\n     * 异步加载图标\r\n     * @return {Color} 生成随机色带\r\n     */\r\n    load() {\r\n        return new Promise((resolve, reject) => {\r\n            let img = new Image();\r\n            img.onload = () => {\r\n                createImageBitmap(img).then(icon => {\r\n                    this.image = icon;\r\n                    this._loaded = true;\r\n                    resolve(icon);\r\n                }, err => reject(err));\r\n            };\r\n            img.onerror = reject;\r\n            img.src = this.url;\r\n        });\r\n    }\r\n    /**\r\n     * 绘制图标\r\n     * @remarks\r\n     * 注意异步加载\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenX - 屏幕坐标X\r\n     * @param {number} screenY - 屏幕坐标Y\r\n     */\r\n    draw(ctx, screenXY) {\r\n        // if (!this._loaded) {\r\n        //     this.image = new Image();\r\n        //     this.image.src = this.url;\r\n        //     this.image.onload = () => {\r\n        //       ctx.drawImage(this.image, screenXY.x + this.offsetX, screenXY.y + this.offsetY, this.width, this.height);\r\n        //     }\r\n        //     this._loaded = true;\r\n        // } else {\r\n        //   if (!this._loading) {\r\n        //     ctx.drawImage(this.image, screenXY.x + this.offsetX, screenXY.y + this.offsetY, this.width, this.height);\r\n        //   }\r\n        // }\r\n        // find a better way\r\n        // now we need await image load\r\n        if (!this._loaded) {\r\n            this.image = new Image();\r\n            this.image.src = this.url;\r\n            this._loaded = true;\r\n        }\r\n        else {\r\n            ctx.drawImage(this.image, screenXY.x + this.offsetX, screenXY.y + this.offsetY, this.width, this.height);\r\n        }\r\n    }\r\n    getScreenBounds(screenXY) {\r\n        let p1 = new ScreenXY(this.offsetX, this.offsetY);\r\n        let p2 = new ScreenXY(this.offsetX + this.width, this.offsetY + this.height);\r\n        return new ScreenBounds(screenXY.add(p1), screenXY.add(p2));\r\n    }\r\n}\r\n/**\r\n * 简单线符号\r\n * @remarks\r\n * 最常用的线符号\r\n */\r\nexport class SimpleLineSymbol extends LineSymbol {\r\n    /**\r\n     * 绘制线\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][]} screen - 线对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screenXYs) {\r\n        if (screenXYs.length < 2)\r\n            return;\r\n        // ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath();\r\n        screenXYs.forEach((screenXY, index) => {\r\n            if (index === 0) {\r\n                ctx.moveTo(screenXY.x, screenXY.y);\r\n            }\r\n            else {\r\n                ctx.lineTo(screenXY.x, screenXY.y);\r\n            }\r\n        });\r\n        ctx.stroke();\r\n        // ctx.restore();\r\n    }\r\n    getScreenBounds(screenXYs) {\r\n        const bounds = new ScreenBounds();\r\n        screenXYs.forEach(screenXY => {\r\n            bounds.extend(screenXY);\r\n        });\r\n        // extend weight\r\n        return bounds;\r\n    }\r\n}\r\n/**\r\n * 简单面符号\r\n * @remarks\r\n * 最常用的面填充符号\r\n */\r\nexport class SimpleFillSymbol extends FillSymbol {\r\n    /**\r\n     * 绘制面\r\n     * @remarks\r\n     * 奇偶填充\r\n     * https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fill\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number[][][]} screen - 面对应坐标点的屏幕坐标集合\r\n     */\r\n    draw(ctx, screenXYs) {\r\n        // ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        //TODO:  exceeding the maximum extent(bound), best way is overlap by extent. find out: maximum is [-PI*R, PI*R]??\r\n        ctx.beginPath();\r\n        screenXYs.forEach(ring => {\r\n            if (ring.length < 3)\r\n                return;\r\n            ring.forEach((screenXY, index) => {\r\n                if (index === 0) {\r\n                    ctx.moveTo(screenXY.x, screenXY.y);\r\n                }\r\n                else {\r\n                    ctx.lineTo(screenXY.x, screenXY.y);\r\n                }\r\n            });\r\n        });\r\n        ctx.closePath();\r\n        //奇偶填充\r\n        //https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fill\r\n        ctx.fill(\"evenodd\");\r\n        ctx.stroke();\r\n        // ctx.restore();\r\n    }\r\n    getScreenBounds(screenXYs) {\r\n        const bounds = new ScreenBounds();\r\n        screenXYs.forEach(ring => {\r\n            ring.forEach(screenXY => {\r\n                bounds.extend(screenXY);\r\n            });\r\n        });\r\n        // extend weight\r\n        return bounds;\r\n    }\r\n}\r\n","/**\r\n * 文本符号\r\n * @remarks\r\n * 常用于文本标注\r\n */\r\nexport class Text {\r\n    constructor() {\r\n        /**\r\n         * 边框宽\r\n         */\r\n        this.lineWidth = 3;\r\n        /**\r\n         * 边框色\r\n         */\r\n        this.strokeStyle = \"#ff0000\"; //#ffffff\r\n        /**\r\n         * 填充色\r\n         */\r\n        this.fillStyle = \"#ffffff\"; //#ffffff\r\n        /**\r\n         * X偏移\r\n         */\r\n        this.offsetX = 0;\r\n        /**\r\n         * Y偏移\r\n         */\r\n        this.offsetY = 1;\r\n        /**\r\n         * 周边留白\r\n         */\r\n        this.padding = 5;\r\n        /**\r\n         * 字体颜色\r\n         */\r\n        this.fontColor = \"#ff0000\";\r\n        /**\r\n         * 字体大小\r\n         */\r\n        this.fontSize = 12;\r\n        /**\r\n         * 字体\r\n         */\r\n        this.fontFamily = \"YaHei\";\r\n        /**\r\n         * 字体粗细\r\n         */\r\n        this.fontWeight = \"Bold\";\r\n        /**\r\n         * 放置位置\r\n         */\r\n        this.placement = \"BOTTOM\"; //BOTTOM TOP LEFT RIGHT\r\n        /**\r\n         * 自动调整位置\r\n         */\r\n        this.auto = false;\r\n        /**\r\n         * 标注点符号的宽度\r\n         */\r\n        this.pointSymbolWidth = 0;\r\n        /**\r\n         * 标注点符号的高度\r\n         */\r\n        this.pointSymbolHeight = 0;\r\n    }\r\n    /**\r\n     * 自动调整位置\r\n     * @remarks 按逆时针方向寻找合适位置\r\n     */\r\n    replacement() {\r\n        if (this.auto) {\r\n            switch (this.placement) {\r\n                case \"BOTTOM\":\r\n                    this.placement = \"RIGHT\";\r\n                    break;\r\n                case \"RIGHT\":\r\n                    this.placement = \"TOP\";\r\n                    break;\r\n                case \"TOP\":\r\n                    this.placement = \"LEFT\";\r\n                    break;\r\n                case \"LEFT\":\r\n                    this.placement = \"BOTTOM\";\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import * as Util from './util';\r\n/*\r\n * NOT SUPPORT IE ANY MORE\r\n */\r\n/*\r\n * @namespace Browser\r\n * @aka L.Browser\r\n *\r\n * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * if (L.Browser.ielt9) {\r\n *   alert('Upgrade your browser, dude!');\r\n * }\r\n * ```\r\n */\r\nconst style = document.documentElement.style;\r\n// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\r\nexport const ie = 'ActiveXObject' in window;\r\n// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\r\nexport const ielt9 = ie && !document.addEventListener;\r\n// @property edge: Boolean; `true` for the Edge web browser.\r\nexport const edge = 'msLaunchUri' in navigator && !('documentMode' in document);\r\n// @property webkit: Boolean;\r\n// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\r\nexport const webkit = userAgentContains('webkit');\r\n// @property android: Boolean\r\n// `true` for any browser running on an Android platform.\r\nexport const android = userAgentContains('android');\r\n// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.\r\nexport const android23 = userAgentContains('android 2') || userAgentContains('android 3');\r\n/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\r\n// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)\r\nexport const androidStock = (function () {\r\n    const agent = /WebKit\\/([0-9]+)|$/.exec(navigator.userAgent); // also matches AppleWebKit\r\n    if (agent) {\r\n        const webkitVer = parseInt(agent[1], 10);\r\n        return android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}());\r\n// @property opera: Boolean; `true` for the Opera browser\r\nexport const opera = !!window.opera;\r\n// @property chrome: Boolean; `true` for the Chrome browser.\r\nexport const chrome = !edge && userAgentContains('chrome');\r\n// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\r\nexport const gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\r\n// @property safari: Boolean; `true` for the Safari browser.\r\nexport const safari = !chrome && userAgentContains('safari');\r\nexport const phantom = userAgentContains('phantom');\r\n// @property opera12: Boolean\r\n// `true` for the Opera browser supporting CSS transforms (version 12 or later).\r\nexport const opera12 = 'OTransition' in style;\r\n// @property win: Boolean; `true` when the browser is running in a Windows platform\r\nexport const win = navigator.platform.indexOf('Win') === 0;\r\n// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\r\nexport const ie3d = ie && ('transition' in style);\r\n// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\r\nexport const webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;\r\n// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\r\nexport const gecko3d = 'MozPerspective' in style;\r\n// @property any3d: Boolean\r\n// `true` for all browsers supporting CSS transforms.\r\nexport const any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\r\n// @property mobile: Boolean; `true` for all browsers running in a mobile device.\r\nexport const mobile = typeof window.screen.orientation !== 'undefined' || userAgentContains('mobile');\r\n// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\r\nexport const mobileWebkit = mobile && webkit;\r\n// @property mobileWebkit3d: Boolean\r\n// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\r\nexport const mobileWebkit3d = mobile && webkit3d;\r\n// @property msPointer: Boolean\r\n// `true` for browsers implementing the Microsoft touch events model (notably IE10).\r\nexport const msPointer = !window.PointerEvent && window.MSPointerEvent;\r\n// @property pointer: Boolean\r\n// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\r\nexport const pointer = !!(window.PointerEvent || msPointer);\r\n// @property touch: Boolean\r\n// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\r\n// This does not necessarily mean that the browser is running in a computer with\r\n// a touchscreen, it only means that the browser is capable of understanding\r\n// touch events.\r\n// export const touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||\r\n// \t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\nexport const touch = !window.L_NO_TOUCH;\r\n// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\r\nexport const mobileOpera = mobile && opera;\r\n// @property mobileGecko: Boolean\r\n// `true` for gecko-based browsers running in a mobile device.\r\nexport const mobileGecko = mobile && gecko;\r\n// @property retina: Boolean\r\n// `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\r\nexport const retina = window.devicePixelRatio > 1;\r\n// @property passiveEvents: Boolean\r\n// `true` for browsers that support passive events.\r\nexport const passiveEvents = (function () {\r\n    let supportsPassiveOption = false;\r\n    try {\r\n        const opts = Object.defineProperty({}, 'passive', {\r\n            get: function () {\r\n                supportsPassiveOption = true;\r\n            }\r\n        });\r\n        window.addEventListener('testPassiveEventSupport', Util.falseFn, opts);\r\n        window.removeEventListener('testPassiveEventSupport', Util.falseFn, opts);\r\n    }\r\n    catch (e) {\r\n        // Errors can safely be ignored since this is only a browser support test.\r\n    }\r\n    return supportsPassiveOption;\r\n}());\r\n// @property canvas: Boolean\r\n// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\r\nexport const canvas = (function () {\r\n    return !!document.createElement('canvas').getContext;\r\n}());\r\nfunction userAgentContains(str) {\r\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\r\n}\r\n","/**\r\n * 颜色工具类\r\n * @remarks\r\n * 此处有太多可扩展内容，如更优雅的生成色带，给色带更多的配置项等等\r\n * 但由于相关内容，并非GIS API的关注重点，故未花太多精力扩展此内容\r\n * 各位可根据项目需求，自行发挥，达到更优雅美观的颜色渲染效果。\r\n * TODO: a lot of things to be done\r\n */\r\nexport class Color {\r\n    /**\r\n     * 创建颜色\r\n     * @param {number} r - red\r\n     * @param {number} g - green\r\n     * @param {number} b - blue\r\n     * @param {number} a - alpha\r\n     */\r\n    constructor(r, g, b, a = 1) {\r\n        /**\r\n         * alpha\r\n         */\r\n        this.a = 1;\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n    /**\r\n     * 输出rgba值\r\n     * @return {string} rgba\r\n     */\r\n    toString() {\r\n        return \"rgba(\" + this.r + \",\" + this.g + \",\" + this.b + \",\" + this.a + \")\";\r\n    }\r\n    /**\r\n     * 16进制表示法颜色 转十进制 R G B\r\n     * @param {string} hex - 十六进制 #ffffff\r\n     * @return {string} 十进制 R G B\r\n     */\r\n    static fromHex(hex) {\r\n        let reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/;\r\n        hex = hex.toLowerCase();\r\n        if (hex && reg.test(hex)) {\r\n            //处理三位的颜色值\r\n            if (hex.length === 4) {\r\n                var sColorNew = \"#\";\r\n                for (var i = 1; i < 4; i += 1) {\r\n                    sColorNew += hex.slice(i, i + 1).concat(hex.slice(i, i + 1));\r\n                }\r\n                hex = sColorNew;\r\n            }\r\n            //处理六位的颜色值\r\n            if (hex.length === 7) {\r\n                hex += \"ff\";\r\n            }\r\n            let sColorChange = [];\r\n            for (let i = 1; i < 9; i += 2) {\r\n                sColorChange.push(parseInt(\"0x\" + hex.slice(i, i + 2)));\r\n            }\r\n            return new Color(sColorChange[0], sColorChange[1], sColorChange[2], sColorChange[3] / 255);\r\n        }\r\n    }\r\n    /**\r\n     * 生成随机色带\r\n     * @param {Color} start - 色带起始色\r\n     * @param {Color} end - 色带终止色\r\n     * @param {number} count - 随机颜色数，默认值10个\r\n     * @return {Color} 生成随机色带\r\n     */\r\n    static ramp(start, end, count = 10) {\r\n        const colors = [];\r\n        for (let i = 0; i < count; i += 1) {\r\n            colors.push(new Color((end.r - start.r) * i / count + start.r, (end.g - start.g) * i / count + start.g, (end.b - start.b) * i / count + start.b, (end.a - start.a) * i / count + start.a));\r\n        }\r\n        return colors;\r\n    }\r\n    /**\r\n     * 生成随机色\r\n     * @return {Color} 生成随机色\r\n     */\r\n    static random() {\r\n        return new Color(Math.random() * 255, Math.random() * 255, Math.random() * 255);\r\n    }\r\n}\r\n","import * as Util from './util';\r\nimport * as Browser from './browser';\r\n// import { addPointerListener, removePointerListener } from './dom-event-pointer';\r\n// import { addDoubleTapListener, removeDoubleTapListener } from './dom-event-double-tap';\r\nimport { getScale } from './dom-util';\r\nimport { ScreenXY } from '../common/screen-xy';\r\n/*\r\n * @namespace DomEvent\r\n * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n */\r\n// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\r\n// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n// Adds a listener function (`fn`) to a particular DOM event type of the\r\n// element `el`. You can optionally specify the context of the listener\r\n// (object the `this` keyword will point to). You can also pass several\r\n// space-separated types (e.g. `'click dblclick'`).\r\n// @alternative\r\n// @function on(el: HTMLElement, eventMap: Object, context?: Object): this\r\n// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\nexport function on(obj, types, fn, context) {\r\n    if (typeof types === 'object') {\r\n        for (let type in types) {\r\n            addOne(obj, type, types[type], fn);\r\n        }\r\n    }\r\n    else {\r\n        types = Util.splitWords(types);\r\n        for (let i = 0, len = types.length; i < len; i++) {\r\n            addOne(obj, types[i], fn, context);\r\n        }\r\n    }\r\n    return context;\r\n}\r\nconst eventsKey = '_leaflet_events';\r\n// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n// Removes a previously added listener function.\r\n// Note that if you passed a custom context to on, you must pass the same\r\n// context to `off` in order to remove the listener.\r\n// @alternative\r\n// @function off(el: HTMLElement, eventMap: Object, context?: Object): this\r\n// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\nexport function off(obj, types, fn, context) {\r\n    if (typeof types === 'object') {\r\n        for (let type in types) {\r\n            removeOne(obj, type, types[type], fn);\r\n        }\r\n    }\r\n    else if (types && fn) {\r\n        types = Util.splitWords(types);\r\n        for (let i = 0, len = types.length; i < len; i++) {\r\n            removeOne(obj, types[i], fn, context);\r\n        }\r\n    }\r\n    else {\r\n        for (let j in obj[eventsKey]) {\r\n            removeOne(obj, j, obj[eventsKey][j]);\r\n        }\r\n        delete obj[eventsKey];\r\n    }\r\n    return context;\r\n}\r\nfunction browserFiresNativeDblClick() {\r\n    // See https://github.com/w3c/pointerevents/issues/171\r\n    if (Browser.pointer) {\r\n        return !(Browser.edge || Browser.safari);\r\n    }\r\n}\r\nconst mouseSubst = {\r\n    mouseenter: 'mouseover',\r\n    mouseleave: 'mouseout',\r\n    wheel: !('onwheel' in window) && 'mousewheel'\r\n};\r\nfunction addOne(obj, type, fn, context) {\r\n    var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : '');\r\n    if (obj[eventsKey] && obj[eventsKey][id]) {\r\n        return context;\r\n    }\r\n    let handler = function (e) {\r\n        return fn.call(context || obj, e || window.event);\r\n    };\r\n    const originalHandler = handler;\r\n    if (Browser.pointer && type.indexOf('touch') === 0) {\r\n        // Needs DomEvent.Pointer.js\r\n        // addPointerListener(obj, type, handler, id);\r\n    }\r\n    else if (Browser.touch && (type === 'dblclick') && !browserFiresNativeDblClick()) {\r\n        // addDoubleTapListener(obj, handler, id);\r\n    }\r\n    else if ('addEventListener' in obj) {\r\n        if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {\r\n            obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);\r\n        }\r\n        else if (type === 'mouseenter' || type === 'mouseleave') {\r\n            handler = function (e) {\r\n                e = e || window.event;\r\n                if (isExternalTarget(obj, e)) {\r\n                    originalHandler(e);\r\n                }\r\n            };\r\n            obj.addEventListener(mouseSubst[type], handler, false);\r\n        }\r\n        else {\r\n            obj.addEventListener(type, originalHandler, false);\r\n        }\r\n    }\r\n    else if ('attachEvent' in obj) {\r\n        obj.attachEvent('on' + type, handler);\r\n    }\r\n    obj[eventsKey] = obj[eventsKey] || {};\r\n    obj[eventsKey][id] = handler;\r\n}\r\nfunction removeOne(obj, type, fn, context) {\r\n    var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : ''), handler = obj[eventsKey] && obj[eventsKey][id];\r\n    if (!handler) {\r\n        return context;\r\n    }\r\n    if (Browser.pointer && type.indexOf('touch') === 0) {\r\n        // removePointerListener(obj, type, id);\r\n    }\r\n    else if (Browser.touch && (type === 'dblclick') && !browserFiresNativeDblClick()) {\r\n        // removeDoubleTapListener(obj, id);\r\n    }\r\n    else if ('removeEventListener' in obj) {\r\n        obj.removeEventListener(mouseSubst[type] || type, handler, false);\r\n    }\r\n    else if ('detachEvent' in obj) {\r\n        obj.detachEvent('on' + type, handler);\r\n    }\r\n    obj[eventsKey][id] = null;\r\n}\r\n// @function stopPropagation(ev: DOMEvent): this\r\n// Stop the given event from propagation to parent elements. Used inside the listener functions:\r\n// ```js\r\n// L.DomEvent.on(div, 'click', function (ev) {\r\n// \tL.DomEvent.stopPropagation(ev);\r\n// });\r\n// ```\r\nexport function stopPropagation(e) {\r\n    if (e.stopPropagation) {\r\n        e.stopPropagation();\r\n    }\r\n    else if (e.originalEvent) { // In case of Leaflet event.\r\n        e.originalEvent._stopped = true;\r\n    }\r\n    else {\r\n        e.cancelBubble = true;\r\n    }\r\n    skipped(e);\r\n    // return this;\r\n}\r\n// @function disableScrollPropagation(el: HTMLElement): this\r\n// Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\r\nexport function disableScrollPropagation(el) {\r\n    addOne(el, 'wheel', stopPropagation);\r\n    // return this;\r\n}\r\n// @function disableClickPropagation(el: HTMLElement): this\r\n// Adds `stopPropagation` to the element's `'click'`, `'dblclick'`,\r\n// `'mousedown'` and `'touchstart'` events (plus browser variants).\r\nexport function disableClickPropagation(el) {\r\n    on(el, 'mousedown touchstart dblclick', stopPropagation);\r\n    addOne(el, 'click', fakeStop);\r\n    // return this;\r\n}\r\n// @function preventDefault(ev: DOMEvent): this\r\n// Prevents the default action of the DOM Event `ev` from happening (such as\r\n// following a link in the href of the a element, or doing a POST request\r\n// with page reload when a `<form>` is submitted).\r\n// Use it inside listener functions.\r\nexport function preventDefault(e) {\r\n    if (e.preventDefault) {\r\n        e.preventDefault();\r\n    }\r\n    else {\r\n        e.returnValue = false;\r\n    }\r\n    // return this;\r\n}\r\n// @function stop(ev: DOMEvent): this\r\n// Does `stopPropagation` and `preventDefault` at the same time.\r\nexport function stop(e) {\r\n    preventDefault(e);\r\n    stopPropagation(e);\r\n    // return this;\r\n}\r\n// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\r\n// Gets normalized mouse position from a DOM event relative to the\r\n// `container` (border excluded) or to the whole page if not specified.\r\nexport function getMousePosition(e, container) {\r\n    if (!container) {\r\n        return new ScreenXY(e.clientX, e.clientY);\r\n    }\r\n    const scale = getScale(container), offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\r\n    return new ScreenXY(\r\n    // offset.left/top values are in page scale (like clientX/Y),\r\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\r\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\r\n}\r\n// Chrome on Win scrolls double the pixels as in other platforms (see #4538),\r\n// and Firefox scrolls device pixels, not CSS pixels\r\nconst wheelPxFactor = (Browser.win && Browser.chrome) ? 2 * window.devicePixelRatio :\r\n    Browser.gecko ? window.devicePixelRatio : 1;\r\n// @function getWheelDelta(ev: DOMEvent): Number\r\n// Gets normalized wheel delta from a wheel DOM event, in vertical\r\n// pixels scrolled (negative if scrolling down).\r\n// Events from pointing devices without precise scrolling are mapped to\r\n// a best guess of 60 pixels.\r\nexport function getWheelDelta(e) {\r\n    return (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\r\n        (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels\r\n            (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines\r\n                (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages\r\n                    (e.deltaX || e.deltaZ) ? 0 : // Skip horizontal/depth wheel events\r\n                        e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\r\n                            (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines\r\n                                e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\r\n                                    0;\r\n}\r\nconst skipEvents = {};\r\nexport function fakeStop(e) {\r\n    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)\r\n    skipEvents[e.type] = true;\r\n}\r\nexport function skipped(e) {\r\n    const events = skipEvents[e.type];\r\n    // reset when checking, as it's only used in map container and propagates outside of the map\r\n    skipEvents[e.type] = false;\r\n    return events;\r\n}\r\n// check if element really left/entered the event target (for mouseenter/mouseleave)\r\nexport function isExternalTarget(el, e) {\r\n    var related = e.relatedTarget;\r\n    if (!related) {\r\n        return true;\r\n    }\r\n    try {\r\n        while (related && (related !== el)) {\r\n            related = related.parentNode;\r\n        }\r\n    }\r\n    catch (err) {\r\n        return false;\r\n    }\r\n    return (related !== el);\r\n}\r\n// @function addListener(…): this\r\n// Alias to [`L.DomEvent.on`](#domevent-on)\r\nexport { on as addListener };\r\n// @function removeListener(…): this\r\n// Alias to [`L.DomEvent.off`](#domevent-off)\r\nexport { off as removeListener };\r\n","import * as Util from './util';\r\nimport * as Browser from './browser';\r\nimport { ScreenXY } from '../common/screen-xy';\r\n/*\r\n * @namespace DomUtil\r\n *\r\n * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n * tree, used by Leaflet internally.\r\n *\r\n * Most functions expecting or returning a `HTMLElement` also work for\r\n * SVG elements. The only difference is that classes refer to CSS classes\r\n * in HTML and SVG classes in SVG.\r\n */\r\n// @property TRANSFORM: String\r\n// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\r\nexport const TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n// @property TRANSITION: String\r\n// Vendor-prefixed transition style name.\r\nexport const TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n// @property TRANSITION_END: String\r\n// Vendor-prefixed transitionend event name.\r\nexport const TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\r\n// @function get(id: String|HTMLElement): HTMLElement\r\n// Returns an element given its DOM id, or returns the element itself\r\n// if it was passed directly.\r\nexport function get(id) {\r\n    return typeof id === 'string' ? document.getElementById(id) : id;\r\n}\r\n// @function getStyle(el: HTMLElement, styleAttrib: String): String\r\n// Returns the value for a certain style attribute on an element,\r\n// including computed values or values set through CSS.\r\nexport function getStyle(el, style) {\r\n    let value = el.style[style] || (el.currentStyle && el.currentStyle[style]);\r\n    if ((!value || value === 'auto') && document.defaultView) {\r\n        const css = document.defaultView.getComputedStyle(el, null);\r\n        value = css ? css[style] : null;\r\n    }\r\n    return value === 'auto' ? null : value;\r\n}\r\n// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\r\n// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\r\nexport function create(tagName, className, container) {\r\n    const el = document.createElement(tagName);\r\n    el.className = className || '';\r\n    if (container) {\r\n        container.appendChild(el);\r\n    }\r\n    return el;\r\n}\r\n// @function remove(el: HTMLElement)\r\n// Removes `el` from its parent element\r\nexport function remove(el) {\r\n    const parent = el.parentNode;\r\n    if (parent) {\r\n        parent.removeChild(el);\r\n    }\r\n}\r\n// @function empty(el: HTMLElement)\r\n// Removes all of `el`'s children elements from `el`\r\nexport function empty(el) {\r\n    while (el.firstChild) {\r\n        el.removeChild(el.firstChild);\r\n    }\r\n}\r\n// @function toFront(el: HTMLElement)\r\n// Makes `el` the last child of its parent, so it renders in front of the other children.\r\nexport function toFront(el) {\r\n    const parent = el.parentNode;\r\n    if (parent && parent.lastChild !== el) {\r\n        parent.appendChild(el);\r\n    }\r\n}\r\n// @function toBack(el: HTMLElement)\r\n// Makes `el` the first child of its parent, so it renders behind the other children.\r\nexport function toBack(el) {\r\n    const parent = el.parentNode;\r\n    if (parent && parent.firstChild !== el) {\r\n        parent.insertBefore(el, parent.firstChild);\r\n    }\r\n}\r\n// @function hasClass(el: HTMLElement, name: String): Boolean\r\n// Returns `true` if the element's class attribute contains `name`.\r\nexport function hasClass(el, name) {\r\n    if (el.classList !== undefined) {\r\n        return el.classList.contains(name);\r\n    }\r\n    const className = getClass(el);\r\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n}\r\n// @function addClass(el: HTMLElement, name: String)\r\n// Adds `name` to the element's class attribute.\r\nexport function addClass(el, name) {\r\n    if (el.classList !== undefined) {\r\n        const classes = Util.splitWords(name);\r\n        for (let i = 0, len = classes.length; i < len; i++) {\r\n            el.classList.add(classes[i]);\r\n        }\r\n    }\r\n    else if (!hasClass(el, name)) {\r\n        const className = getClass(el);\r\n        setClass(el, (className ? className + ' ' : '') + name);\r\n    }\r\n}\r\n// @function removeClass(el: HTMLElement, name: String)\r\n// Removes `name` from the element's class attribute.\r\nexport function removeClass(el, name) {\r\n    if (el.classList !== undefined) {\r\n        el.classList.remove(name);\r\n    }\r\n    else {\r\n        setClass(el, Util.trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n    }\r\n}\r\n// @function setClass(el: HTMLElement, name: String)\r\n// Sets the element's class.\r\nexport function setClass(el, name) {\r\n    if (el.className.baseVal === undefined) {\r\n        el.className = name;\r\n    }\r\n    else {\r\n        // in case of SVG element\r\n        el.className.baseVal = name;\r\n    }\r\n}\r\n// @function getClass(el: HTMLElement): String\r\n// Returns the element's class.\r\nexport function getClass(el) {\r\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\r\n    // (Required for linked SVG elements in IE11.)\r\n    if (el.correspondingElement) {\r\n        el = el.correspondingElement;\r\n    }\r\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n}\r\n// @function setOpacity(el: HTMLElement, opacity: Number)\r\n// Set the opacity of an element (including old IE support).\r\n// `opacity` must be a number from `0` to `1`.\r\nexport function setOpacity(el, value) {\r\n    el.style.opacity = value.toString();\r\n}\r\n// @function testProp(props: String[]): String|false\r\n// Goes through the array of style names and returns the first name\r\n// that is a valid style name for an element. If no such name is found,\r\n// it returns false. Useful for vendor-prefixed styles like `transform`.\r\nexport function testProp(props) {\r\n    const style = document.documentElement.style;\r\n    for (let i = 0; i < props.length; i++) {\r\n        if (props[i] in style) {\r\n            return props[i];\r\n        }\r\n    }\r\n    return false;\r\n}\r\n// @function setTransform(el: HTMLElement, offset: ScreenXY, scale?: Number)\r\n// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\r\n// and optionally scaled by `scale`. Does not have an effect if the\r\n// browser doesn't support 3D CSS transforms.\r\nexport function setTransform(el, offset, scale) {\r\n    const pos = offset || new ScreenXY(0, 0);\r\n    if (TRANSFORM) {\r\n        el.style[TRANSFORM] =\r\n            (Browser.ie3d ?\r\n                'translate(' + pos.x + 'px,' + pos.y + 'px)' :\r\n                'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +\r\n                (scale ? ' scale(' + scale + ')' : '');\r\n    }\r\n}\r\n// @function setPosition(el: HTMLElement, position: ScreenXY)\r\n// Sets the position of `el` to coordinates specified by `position`,\r\n// using CSS translate or top/left positioning depending on the browser\r\n// (used by Leaflet internally to position its layers).\r\nexport function setPosition(el, position) {\r\n    /*eslint-disable */\r\n    el._leaflet_pos = position;\r\n    /* eslint-enable */\r\n    if (Browser.any3d) {\r\n        setTransform(el, position);\r\n    }\r\n    else {\r\n        el.style.left = position.x + 'px';\r\n        el.style.top = position.y + 'px';\r\n    }\r\n}\r\n// @function getPosition(el: HTMLElement): ScreenXY\r\n// Returns the coordinates of an element previously positioned with setPosition.\r\nexport function getPosition(el) {\r\n    // this method is only used for elements previously positioned using setPosition,\r\n    // so it's safe to cache the position for performance\r\n    return el._leaflet_pos || new ScreenXY(0, 0);\r\n}\r\n// @function getSizedParentNode(el: HTMLElement): HTMLElement\r\n// Finds the closest parent node which size (width and height) is not null.\r\nexport function getSizedParentNode(element) {\r\n    do {\r\n        element = element.parentNode;\r\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\r\n    return element;\r\n}\r\n// @function getScale(el: HTMLElement): Object\r\n// Computes the CSS scale currently applied on the element.\r\n// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\r\n// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\r\nexport function getScale(element) {\r\n    const rect = element.getBoundingClientRect(); // Read-only in old browsers.\r\n    return {\r\n        x: rect.width / element.offsetWidth || 1,\r\n        y: rect.height / element.offsetHeight || 1,\r\n        boundingClientRect: rect\r\n    };\r\n}\r\n","import { ScreenXY } from '../common/screen-xy';\r\n/*\r\n * @namespace LineUtil\r\n *\r\n * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n */\r\n// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n// Improves rendering performance dramatically by lessening the number of points to draw.\r\n// @function simplify(points: Point[], tolerance: Number): Point[]\r\n// Dramatically reduces the number of points in a polyline while retaining\r\n// its shape and returns a new array of simplified points, using the\r\n// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).\r\n// Used for a huge performance boost when processing/displaying Leaflet polylines for\r\n// each zoom level and also reducing visual noise. tolerance affects the amount of\r\n// simplification (lesser value means higher quality but slower and with more points).\r\n// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).\r\nexport function simplify(points, tolerance) {\r\n    if (!tolerance || !points.length) {\r\n        return points.slice();\r\n    }\r\n    let sqTolerance = tolerance * tolerance;\r\n    // stage 1: vertex reduction\r\n    points = _reducePoints(points, sqTolerance);\r\n    // stage 2: Douglas-Peucker simplification\r\n    points = _simplifyDP(points, sqTolerance);\r\n    return points;\r\n}\r\n// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\r\n// Returns the distance between point `p` and segment `p1` to `p2`.\r\nexport function pointToSegmentDistance(p, p1, p2) {\r\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\r\n}\r\n// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\r\n// Returns the closest point from a point `p` on a segment `p1` to `p2`.\r\nexport function closestPointOnSegment(p, p1, p2) {\r\n    return _sqClosestPointOnSegment(p, p1, p2);\r\n}\r\n// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\nfunction _simplifyDP(points, sqTolerance) {\r\n    let len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array, markers = new ArrayConstructor(len);\r\n    markers[0] = markers[len - 1] = 1;\r\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n    var i, newPoints = [];\r\n    for (i = 0; i < len; i++) {\r\n        if (markers[i]) {\r\n            newPoints.push(points[i]);\r\n        }\r\n    }\r\n    return newPoints;\r\n}\r\nfunction _simplifyDPStep(points, markers, sqTolerance, first, last) {\r\n    let maxSqDist = 0, index, i, sqDist;\r\n    for (i = first + 1; i <= last - 1; i++) {\r\n        sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n        if (typeof sqDist === 'number' && sqDist > maxSqDist) {\r\n            index = i;\r\n            maxSqDist = sqDist;\r\n        }\r\n    }\r\n    if (index !== undefined && maxSqDist > sqTolerance) {\r\n        markers[index] = 1;\r\n        _simplifyDPStep(points, markers, sqTolerance, first, index);\r\n        _simplifyDPStep(points, markers, sqTolerance, index, last);\r\n    }\r\n}\r\n// reduce points that are too close to each other to a single point\r\nfunction _reducePoints(points, sqTolerance) {\r\n    var reducedPoints = [points[0]];\r\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n        if (_sqDist(points[i], points[prev]) > sqTolerance) {\r\n            reducedPoints.push(points[i]);\r\n            prev = i;\r\n        }\r\n    }\r\n    if (prev < len - 1) {\r\n        reducedPoints.push(points[len - 1]);\r\n    }\r\n    return reducedPoints;\r\n}\r\nlet _lastCode;\r\n// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\r\n// Clips the segment a to b by rectangular bounds with the\r\n// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\r\n// (modifying the segment points directly!). Used by Leaflet to only show polyline\r\n// points that are on the screen or near, increasing performance.\r\nexport function clipSegment(a, b, bounds, useLastCode, round) {\r\n    let codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;\r\n    // save 2nd code to avoid calculating it on the next segment\r\n    _lastCode = codeB;\r\n    while (true) {\r\n        // if a,b is inside the clip window (trivial accept)\r\n        if (!(codeA | codeB)) {\r\n            return [a, b];\r\n        }\r\n        // if a,b is outside the clip window (trivial reject)\r\n        if (codeA & codeB) {\r\n            return false;\r\n        }\r\n        // other cases\r\n        codeOut = codeA || codeB;\r\n        p = _getEdgeIntersection(a, b, codeOut, bounds, round);\r\n        newCode = _getBitCode(p, bounds);\r\n        if (codeOut === codeA) {\r\n            a = p;\r\n            codeA = newCode;\r\n        }\r\n        else {\r\n            b = p;\r\n            codeB = newCode;\r\n        }\r\n    }\r\n}\r\nexport function _getEdgeIntersection(a, b, code, bounds, round) {\r\n    var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x = 0, y = 0;\r\n    if (code & 8) { // top\r\n        x = a.x + dx * (max.y - a.y) / dy;\r\n        y = max.y;\r\n    }\r\n    else if (code & 4) { // bottom\r\n        x = a.x + dx * (min.y - a.y) / dy;\r\n        y = min.y;\r\n    }\r\n    else if (code & 2) { // right\r\n        x = max.x;\r\n        y = a.y + dy * (max.x - a.x) / dx;\r\n    }\r\n    else if (code & 1) { // left\r\n        x = min.x;\r\n        y = a.y + dy * (min.x - a.x) / dx;\r\n    }\r\n    return round ? new ScreenXY(Math.round(x), Math.round(y)) : new ScreenXY(x, y);\r\n}\r\nexport function _getBitCode(p, bounds) {\r\n    var code = 0;\r\n    if (p.x < bounds.min.x) { // left\r\n        code |= 1;\r\n    }\r\n    else if (p.x > bounds.max.x) { // right\r\n        code |= 2;\r\n    }\r\n    if (p.y < bounds.min.y) { // bottom\r\n        code |= 4;\r\n    }\r\n    else if (p.y > bounds.max.y) { // top\r\n        code |= 8;\r\n    }\r\n    return code;\r\n}\r\n// square distance (to avoid unnecessary Math.sqrt calls)\r\nfunction _sqDist(p1, p2) {\r\n    var dx = p2.x - p1.x, dy = p2.y - p1.y;\r\n    return dx * dx + dy * dy;\r\n}\r\n// return closest point on segment or distance to that point\r\nexport function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\r\n    var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;\r\n    if (dot > 0) {\r\n        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n        if (t > 1) {\r\n            x = p2.x;\r\n            y = p2.y;\r\n        }\r\n        else if (t > 0) {\r\n            x += dx * t;\r\n            y += dy * t;\r\n        }\r\n    }\r\n    dx = p.x - x;\r\n    dy = p.y - y;\r\n    return sqDist ? dx * dx + dy * dy : new ScreenXY(x, y);\r\n}\r\n","// @property lastId: Number\r\n// Last unique ID used by [`stamp()`](#util-stamp)\r\nexport var lastId = 0;\r\n// @function stamp(obj: Object): Number\r\n// Returns the unique ID of an object, assigning it one if it doesn't have it.\r\nexport function stamp(obj) {\r\n    /*eslint-disable */\r\n    obj._leaflet_id = obj._leaflet_id || ++lastId;\r\n    return obj._leaflet_id;\r\n    /* eslint-enable */\r\n}\r\n// @function stamp(obj: Object): Number\r\n// Returns the unique ID of an object, assigning it one if it doesn't have it.\r\n// export function stamp(obj: any): string {\r\n// \t/*eslint-disable */\r\n// \tobj._leaflet_id = obj._leaflet_id || (new Date().getTime() / 1000 | 0).toString(16) + 'xxxxxxxxxxxxxxxx'.replace(/[x]/g, function() {\r\n// \t\treturn (Math.random() * 16 | 0).toString(16);\r\n// \t}).toLowerCase();\r\n// \treturn obj._leaflet_id;\r\n// \t/* eslint-enable */\r\n// }\r\n// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\r\n// Returns the number `num` modulo `range` in such a way so it lies within\r\n// `range[0]` and `range[1]`. The returned value will be always smaller than\r\n// `range[1]` unless `includeMax` is set to `true`.\r\nexport function wrapNum(x, range, includeMax = false) {\r\n    var max = range[1], min = range[0], d = max - min;\r\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\r\n}\r\n// @function falseFn(): Function\r\n// Returns a function which always returns `false`.\r\nexport function falseFn() { return false; }\r\n// @function formatNum(num: Number, digits?: Number): Number\r\n// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.\r\nexport function formatNum(num, digits = 6) {\r\n    const pow = Math.pow(10, digits);\r\n    return Math.round(num * pow) / pow;\r\n}\r\n// @function trim(str: String): String\r\n// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\r\nexport function trim(str) {\r\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n}\r\n// @function splitWords(str: String): String[]\r\n// Trims and splits the string on whitespace and returns the array of parts.\r\nexport function splitWords(str) {\r\n    return trim(str).split(/\\s+/);\r\n}\r\n// @property emptyImageUrl: String\r\n// Data URI string containing a base64-encoded empty GIF image.\r\n// Used as a hack to free memory from unused images on WebKit-powered\r\n// mobile devices (by setting image `src` to this string).\r\nexport var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\r\n// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\nfunction getPrefixed(name) {\r\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\r\n}\r\nexport var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame');\r\nexport var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||\r\n    getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };\r\n// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\r\n// Schedules `fn` to be executed when the browser repaints. `fn` is bound to\r\n// `context` if given. When `immediate` is set, `fn` is called immediately if\r\n// the browser doesn't have native support for\r\n// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\r\n// otherwise it's delayed. Returns a request ID that can be used to cancel the request.\r\nexport function requestAnimFrame(fn, context, immediate) {\r\n    return requestFn.call(window, fn.bind(context));\r\n}\r\n// @function cancelAnimFrame(id: Number): undefined\r\n// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\r\nexport function cancelAnimFrame(id) {\r\n    if (id) {\r\n        cancelFn.call(window, id);\r\n    }\r\n}\r\n// @function template(str: String, data: Object): String\r\n// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\r\n// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\r\n// `('Hello foo, bar')`. You can also specify functions instead of strings for\r\n// data values — they will be evaluated passing `data` as an argument.\r\nexport function template(str, data) {\r\n    return str.replace(/\\{ *([\\w_ -]+) *\\}/g, function (str, key) {\r\n        var value = data[key];\r\n        if (value === undefined) {\r\n            throw new Error('No value provided for variable ' + str);\r\n        }\r\n        else if (typeof value === 'function') {\r\n            value = value(data);\r\n        }\r\n        return value;\r\n    });\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\r\nimport {\r\n  LatLng, Map, FeatureLayer, FeatureClass, GeometryType,\r\n  SimpleRenderer, Field, FieldType, Tile, GeoJSONAdapter, SimpleLineSymbol\r\n} from \"../dist\";\r\n\r\nwindow.load = async () => {\r\n\r\n  //创建地图\r\n  const map = new Map(\"foo\");\r\n  //加载OSM切片\r\n  const tile = new Tile('http://{s}.tile.osm.org/{z}/{x}/{y}.png');\r\n  tile.addTo(map);\r\n\r\n  map.setView(new LatLng(39.909186, 116.397411), 12);\r\n\r\n  const geojsonAdapter = new GeoJSONAdapter(GeometryType.Polyline, \"https://raw.githubusercontent.com/shengzheng1981/green-leaf/master/demo/assets/geojson/line1.json\");\r\n  // const geojsonAdapter = new GeoJSONAdapter(GeometryType.Polygon, \"assets/geojson/beijing.json\");\r\n  //新建要素类\r\n  const featureClass = new FeatureClass(GeometryType.Polyline);\r\n  //新建字段\r\n  const field = new Field(\"name\", FieldType.String);\r\n  featureClass.addField(field);\r\n  await featureClass.load(geojsonAdapter);\r\n  //新建矢量图层\r\n  const featureLayer = new FeatureLayer();\r\n  featureLayer.featureClass = featureClass;\r\n  //设置渲染方式——分类渲染\r\n  const renderer = new SimpleRenderer();\r\n  renderer.symbol = new SimpleLineSymbol();\r\n  renderer.symbol.strokeStyle = \"rgb(192,58,47)\";\r\n  renderer.symbol.weight = 3;\r\n  featureLayer.renderer = renderer;\r\n  featureLayer.zoom = [5, 20];\r\n\r\n  //添加矢量图层\r\n  map.addFeatureLayer(featureLayer);\r\n}"],"names":[],"sourceRoot":""}